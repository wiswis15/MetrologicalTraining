From 4abfdc6b753d836cbe1f28b551faa0e51de7679b Mon Sep 17 00:00:00 2001
From: Neeraj Deshpande <neeraj.deshpande@valuelabs.com>
Date: Sat, 22 Dec 2018 19:14:22 +0530
Subject: [PATCH 03/10] Add rpi graphics support and virtualinput support.

---
 .../eventloop/virtualinput/EventLoopNull.cpp  |  164 ++
 .../virtualinput/gibbon_eventloop.cmake       |    5 +
 .../eventloop/virtualinput/linux_keycodes.h   |  407 +++++
 partner/graphics/rpi/EffectsGLES2.cpp         | 1572 +++++++++++++++++
 partner/graphics/rpi/EffectsGLES2.h           |  208 +++
 partner/graphics/rpi/GraphicsEngineGLES2.cpp  |  621 +++++++
 partner/graphics/rpi/OpenGLContext.cpp        |  540 ++++++
 partner/graphics/rpi/OpenGLContext.h          |  216 +++
 partner/graphics/rpi/OpenGLContextCommon.h    |   17 +
 partner/graphics/rpi/OpenGLContextEGL.cpp     |  370 ++++
 partner/graphics/rpi/OpenGLContextEGL.h       |   39 +
 partner/graphics/rpi/OpenGLContextGLX.cpp     |  491 +++++
 partner/graphics/rpi/OpenGLContextGLX.h       |   54 +
 partner/graphics/rpi/OpenGLContextOSMESA.cpp  |  108 ++
 partner/graphics/rpi/OpenGLContextOSX.h       |   22 +
 partner/graphics/rpi/OpenGLContextOSX.mm      |  557 ++++++
 partner/graphics/rpi/OpenGLFBO.cpp            |  243 +++
 partner/graphics/rpi/OpenGLFBO.h              |  109 ++
 partner/graphics/rpi/OpenGLFloats.h           |   38 +
 partner/graphics/rpi/OpenGLShaders.cpp        |  241 +++
 partner/graphics/rpi/OpenGLShaders.h          | 1292 ++++++++++++++
 partner/graphics/rpi/OpenGLState.h            |  717 ++++++++
 partner/graphics/rpi/OpenGLVBO.cpp            |   19 +
 partner/graphics/rpi/OpenGLVBO.h              |   28 +
 partner/graphics/rpi/PlayerGLES2.cpp          |   94 +
 partner/graphics/rpi/ScreenGLES2.cpp          |  440 +++++
 partner/graphics/rpi/SurfaceGLES2.cpp         |  410 +++++
 partner/graphics/rpi/gibbon_graphics.cmake    |   46 +
 partner/graphics/rpi/graphics.xml             |   33 +
 partner/graphics/rpi/test.cpp                 |  535 ++++++
 30 files changed, 9636 insertions(+)
 create mode 100644 partner/eventloop/virtualinput/EventLoopNull.cpp
 create mode 100644 partner/eventloop/virtualinput/gibbon_eventloop.cmake
 create mode 100644 partner/eventloop/virtualinput/linux_keycodes.h
 create mode 100644 partner/graphics/rpi/EffectsGLES2.cpp
 create mode 100644 partner/graphics/rpi/EffectsGLES2.h
 create mode 100644 partner/graphics/rpi/GraphicsEngineGLES2.cpp
 create mode 100644 partner/graphics/rpi/OpenGLContext.cpp
 create mode 100644 partner/graphics/rpi/OpenGLContext.h
 create mode 100644 partner/graphics/rpi/OpenGLContextCommon.h
 create mode 100644 partner/graphics/rpi/OpenGLContextEGL.cpp
 create mode 100644 partner/graphics/rpi/OpenGLContextEGL.h
 create mode 100644 partner/graphics/rpi/OpenGLContextGLX.cpp
 create mode 100644 partner/graphics/rpi/OpenGLContextGLX.h
 create mode 100644 partner/graphics/rpi/OpenGLContextOSMESA.cpp
 create mode 100644 partner/graphics/rpi/OpenGLContextOSX.h
 create mode 100644 partner/graphics/rpi/OpenGLContextOSX.mm
 create mode 100644 partner/graphics/rpi/OpenGLFBO.cpp
 create mode 100644 partner/graphics/rpi/OpenGLFBO.h
 create mode 100644 partner/graphics/rpi/OpenGLFloats.h
 create mode 100644 partner/graphics/rpi/OpenGLShaders.cpp
 create mode 100644 partner/graphics/rpi/OpenGLShaders.h
 create mode 100644 partner/graphics/rpi/OpenGLState.h
 create mode 100644 partner/graphics/rpi/OpenGLVBO.cpp
 create mode 100644 partner/graphics/rpi/OpenGLVBO.h
 create mode 100644 partner/graphics/rpi/PlayerGLES2.cpp
 create mode 100644 partner/graphics/rpi/ScreenGLES2.cpp
 create mode 100644 partner/graphics/rpi/SurfaceGLES2.cpp
 create mode 100644 partner/graphics/rpi/gibbon_graphics.cmake
 create mode 100644 partner/graphics/rpi/graphics.xml
 create mode 100644 partner/graphics/rpi/test.cpp

diff --git a/partner/eventloop/virtualinput/EventLoopNull.cpp b/partner/eventloop/virtualinput/EventLoopNull.cpp
new file mode 100644
index 00000000..c7c69bf3
--- /dev/null
+++ b/partner/eventloop/virtualinput/EventLoopNull.cpp
@@ -0,0 +1,164 @@
+/* (c) 2012 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+
+
+// TODO: this shouldn't be in "null" dir, create own dir, e.g. "VirtualInput"
+
+#include <Screen.h>
+#include <GibbonEventLoop.h>
+#include <GibbonApplication.h>
+#include <GibbonEvent.h>
+
+#include <nrdbase/ScopedMutex.h>
+#include <nrdbase/Time.h>
+
+#include <WPEFramework/virtualinput/VirtualKeyboard.h>
+#include "linux_keycodes.h"
+
+using namespace netflix::gibbon;
+using namespace netflix;
+
+void* handle = nullptr;
+
+static const char *ActionToString[] = {
+        "Released", "Pressed", "Repeat", "Completed"
+};
+
+static bool shiftPressed = false;
+
+static inline KeyEvent::Key keyCodeToKey(uint16_t c)
+{
+    KeyEvent::Key code = KeyEvent::NETFLIX51_KEY_UNKNOWN;
+    switch (c) {
+       case LINUX_KEY_ENTER: code = KeyEvent::NETFLIX51_KEY_RETURN; break;
+       case LINUX_KEY_END: code = KeyEvent::NETFLIX51_KEY_END; break;
+       case LINUX_KEY_HOME: code = KeyEvent::NETFLIX51_KEY_HOME; break;
+       case LINUX_KEY_F1: code = KeyEvent::NETFLIX51_KEY_F1; break;
+       case LINUX_KEY_F2: code = KeyEvent::NETFLIX51_KEY_F2; break;
+       case LINUX_KEY_F3: code = KeyEvent::NETFLIX51_KEY_F3; break;
+       case LINUX_KEY_F4: code = KeyEvent::NETFLIX51_KEY_F4; break;
+       case LINUX_KEY_F5: code = KeyEvent::NETFLIX51_KEY_DELETE; break;
+       case LINUX_KEY_F6: code = KeyEvent::NETFLIX51_KEY_F6; break;
+       case LINUX_KEY_F7: code = KeyEvent::NETFLIX51_KEY_F7; break;
+       case LINUX_KEY_F8: code = KeyEvent::NETFLIX51_KEY_F8; break;
+       case LINUX_KEY_F9: code = KeyEvent::NETFLIX51_KEY_F9; break;
+       case LINUX_KEY_F10: code = KeyEvent::NETFLIX51_KEY_F10; break;
+       case LINUX_KEY_F11: code = KeyEvent::NETFLIX51_KEY_F11; break;
+       case LINUX_KEY_F12: code = KeyEvent::NETFLIX51_KEY_F12; break;
+       case LINUX_KEY_F13: code = KeyEvent::NETFLIX51_KEY_F13; break;
+       case LINUX_KEY_F14: code = KeyEvent::NETFLIX51_KEY_F14; break;
+       case LINUX_KEY_F15: code = KeyEvent::NETFLIX51_KEY_F15; break;
+       case LINUX_KEY_F16: code = KeyEvent::NETFLIX51_KEY_F16; break;
+       case LINUX_KEY_F17: code = KeyEvent::NETFLIX51_KEY_F17; break;
+       case LINUX_KEY_F18: code = KeyEvent::NETFLIX51_KEY_F18; break;
+       case LINUX_KEY_F19: code = KeyEvent::NETFLIX51_KEY_F19; break;
+       case LINUX_KEY_F20: code = KeyEvent::NETFLIX51_KEY_F20; break;
+       case LINUX_KEY_F21: code = KeyEvent::NETFLIX51_KEY_F21; break;
+       case LINUX_KEY_F22: code = KeyEvent::NETFLIX51_KEY_F22; break;
+       case LINUX_KEY_F23: code = KeyEvent::NETFLIX51_KEY_F23; break;
+       case LINUX_KEY_F24: code = KeyEvent::NETFLIX51_KEY_F24; break;
+       case LINUX_KEY_LEFT: code = KeyEvent::NETFLIX51_KEY_LEFT; break;
+       case LINUX_KEY_UP: code = KeyEvent::NETFLIX51_KEY_UP; break;
+       case LINUX_KEY_RIGHT: code = KeyEvent::NETFLIX51_KEY_RIGHT; break;
+       case LINUX_KEY_DOWN: code = KeyEvent::NETFLIX51_KEY_DOWN; break;
+       case LINUX_KEY_BACKSPACE: code = KeyEvent::NETFLIX51_KEY_BACKSPACE; break;
+       case LINUX_KEY_LEFTSHIFT:
+       case LINUX_KEY_RIGHTSHIFT: code = KeyEvent::NETFLIX51_KEY_SHIFT; break;
+       case LINUX_KEY_LEFTCTRL:
+       case LINUX_KEY_RIGHTCTRL: code = KeyEvent::NETFLIX51_KEY_CONTROL; break;
+       case LINUX_KEY_LEFTALT:
+       case LINUX_KEY_RIGHTALT: code = KeyEvent::NETFLIX51_KEY_ALT; break;
+       case LINUX_KEY_LEFTMETA:
+       case LINUX_KEY_RIGHTMETA: code = KeyEvent::NETFLIX51_KEY_META; break;
+       case LINUX_KEY_CAPSLOCK: code = KeyEvent::NETFLIX51_KEY_CAPSLOCK; break;
+       case LINUX_KEY_NUMLOCK: code = KeyEvent::NETFLIX51_KEY_NUMLOCK; break;
+       case LINUX_KEY_SCROLLLOCK: code = KeyEvent::NETFLIX51_KEY_SCROLLLOCK; break;
+       case LINUX_KEY_ESC: code = KeyEvent::NETFLIX51_KEY_ESCAPE; break;
+       case LINUX_KEY_TAB: code = KeyEvent::NETFLIX51_KEY_TAB; break;
+       case LINUX_KEY_INSERT: code = KeyEvent::NETFLIX51_KEY_INSERT; break;
+       case LINUX_KEY_DELETE: code = KeyEvent::NETFLIX51_KEY_DELETE; break;
+       default:
+           break;
+    }
+    return code;
+}
+
+// let's hope the keys in input.h don't change
+static const char* ltxt = "\t\t1234567890-=\t\tqwertyuiop[]\t\tasdfghjkl;'`\t\\zxcvbnm,./\t\t\t ";
+static const char* utxt = "\t\t!@#$%^&*()_+\t\tQWERTYUIOP{}\t\tASDFGHJKL:\"~\t|ZXCVBNM<>?\t\t\t ";
+
+static inline std::string keyCodeToString(uint16_t code, bool shift)
+{
+    assert(LINUX_KEY_1 == 2 && LINUX_KEY_SPACE == 57);
+    if (code >= LINUX_KEY_1 && code <= LINUX_KEY_SPACE && *(utxt + code) != '\t')
+        return std::string(shift ? (utxt + code) : (ltxt + code), 1);
+    return std::string();
+}
+
+static void VirtualKeyboardCallback(enum actiontype type, unsigned int code)
+{
+   printf("VirtualKeyboard event, keycode %u, action %s\n", code, ActionToString[type]);
+
+   const KeyEvent::Key key = keyCodeToKey(code);
+
+   switch (type) {
+      case PRESSED:
+         shiftPressed = (key == KeyEvent::NETFLIX51_KEY_SHIFT ? true : shiftPressed);
+         fprintf(stderr, "Sending key pressed [%d] -> [%d] to Netflix.\n", code, key);
+         GibbonApplication::instance()->sendEvent(new KeyEvent(GibbonEvent::Type_KeyPress, key, keyCodeToString(code, shiftPressed)));
+
+         // TODO: figure out auto repeat
+         //GibbonApplication::instance()->getInputManager()->startAutoRepeat(key, keyCodeToString(code, shiftPressed));
+         break;
+      case RELEASED:
+         // TODO: figure out auto repeat
+         //GibbonApplication::instance()->getInputManager()->endAutoRepeat();
+         shiftPressed = (key == KeyEvent::NETFLIX51_KEY_SHIFT ? false : shiftPressed);
+         fprintf(stderr, "Sending key released [%d] -> [%d] to Netflix.\n", code, key);
+
+         GibbonApplication::instance()->sendEvent(new KeyEvent(GibbonEvent::Type_KeyRelease, key, keyCodeToString(code, shiftPressed)));
+         break;
+      default:
+         return;
+   }
+}
+
+void GibbonEventLoop::init()
+{
+   handle = ::Construct("netflix5", "/tmp/keyhandler", VirtualKeyboardCallback);
+   if (handle == nullptr) {
+      fprintf(stderr, "Failed to construct virtual keyboard\n");
+   }
+}
+
+void GibbonEventLoop::cleanup()
+{
+   // TODO: clean up
+   //::Destruct(handle);
+}
+
+void GibbonEventLoop::startInput_sys()
+{
+}
+
+void GibbonEventLoop::stopInput_sys()
+{
+}
+
+void GibbonEventLoop::moveMouse(const Point &)
+{
+}
+
+void GibbonEventLoop::wait(llong mseconds)
+{
+    EventLoop::wait(mseconds);
+}
+
+void GibbonEventLoop::wakeup()
+{
+    EventLoop::wakeup();
+}
+
+bool GibbonEventLoop::hasEvents() const
+{
+    return false;
+}
diff --git a/partner/eventloop/virtualinput/gibbon_eventloop.cmake b/partner/eventloop/virtualinput/gibbon_eventloop.cmake
new file mode 100644
index 00000000..7e74cd80
--- /dev/null
+++ b/partner/eventloop/virtualinput/gibbon_eventloop.cmake
@@ -0,0 +1,5 @@
+# (c) 2011 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc.
+
+set(GIBBON_EVENTLOOP_NULL TRUE)
+gibbon_add_sources(EventLoopNull.cpp)
+gibbon_add_libraries(WPEFrameworkVirtualInput)
diff --git a/partner/eventloop/virtualinput/linux_keycodes.h b/partner/eventloop/virtualinput/linux_keycodes.h
new file mode 100644
index 00000000..16ec20b6
--- /dev/null
+++ b/partner/eventloop/virtualinput/linux_keycodes.h
@@ -0,0 +1,407 @@
+// TODO: deal with overlap between linux and netflix keycodes
+#pragma once
+
+#define LINUX_KEY_RESERVED		0
+#define LINUX_KEY_ESC			1
+#define LINUX_KEY_1			2
+#define LINUX_KEY_2			3
+#define LINUX_KEY_3			4
+#define LINUX_KEY_4			5
+#define LINUX_KEY_5			6
+#define LINUX_KEY_6			7
+#define LINUX_KEY_7			8
+#define LINUX_KEY_8			9
+#define LINUX_KEY_9			10
+#define LINUX_KEY_0			11
+#define LINUX_KEY_MINUS		12
+#define LINUX_KEY_EQUAL		13
+#define LINUX_KEY_BACKSPACE		14
+#define LINUX_KEY_TAB			15
+#define LINUX_KEY_Q			16
+#define LINUX_KEY_W			17
+#define LINUX_KEY_E			18
+#define LINUX_KEY_R			19
+#define LINUX_KEY_T			20
+#define LINUX_KEY_Y			21
+#define LINUX_KEY_U			22
+#define LINUX_KEY_I			23
+#define LINUX_KEY_O			24
+#define LINUX_KEY_P			25
+#define LINUX_KEY_LEFTBRACE		26
+#define LINUX_KEY_RIGHTBRACE		27
+#define LINUX_KEY_ENTER		28
+#define LINUX_KEY_LEFTCTRL		29
+#define LINUX_KEY_A			30
+#define LINUX_KEY_S			31
+#define LINUX_KEY_D			32
+#define LINUX_KEY_F			33
+#define LINUX_KEY_G			34
+#define LINUX_KEY_H			35
+#define LINUX_KEY_J			36
+#define LINUX_KEY_K			37
+#define LINUX_KEY_L			38
+#define LINUX_KEY_SEMICOLON		39
+#define LINUX_KEY_APOSTROPHE		40
+#define LINUX_KEY_GRAVE		41
+#define LINUX_KEY_LEFTSHIFT		42
+#define LINUX_KEY_BACKSLASH		43
+#define LINUX_KEY_Z			44
+#define LINUX_KEY_X			45
+#define LINUX_KEY_C			46
+#define LINUX_KEY_V			47
+#define LINUX_KEY_B			48
+#define LINUX_KEY_N			49
+#define LINUX_KEY_M			50
+#define LINUX_KEY_COMMA		51
+#define LINUX_KEY_DOT			52
+#define LINUX_KEY_SLASH		53
+#define LINUX_KEY_RIGHTSHIFT		54
+#define LINUX_KEY_KPASTERISK		55
+#define LINUX_KEY_LEFTALT		56
+#define LINUX_KEY_SPACE		57
+#define LINUX_KEY_CAPSLOCK		58
+#define LINUX_KEY_F1			59
+#define LINUX_KEY_F2			60
+#define LINUX_KEY_F3			61
+#define LINUX_KEY_F4			62
+#define LINUX_KEY_F5			63
+#define LINUX_KEY_F6			64
+#define LINUX_KEY_F7			65
+#define LINUX_KEY_F8			66
+#define LINUX_KEY_F9			67
+#define LINUX_KEY_F10			68
+#define LINUX_KEY_NUMLOCK		69
+#define LINUX_KEY_SCROLLLOCK		70
+#define LINUX_KEY_KP7			71
+#define LINUX_KEY_KP8			72
+#define LINUX_KEY_KP9			73
+#define LINUX_KEY_KPMINUS		74
+#define LINUX_KEY_KP4			75
+#define LINUX_KEY_KP5			76
+#define LINUX_KEY_KP6			77
+#define LINUX_KEY_KPPLUS		78
+#define LINUX_KEY_KP1			79
+#define LINUX_KEY_KP2			80
+#define LINUX_KEY_KP3			81
+#define LINUX_KEY_KP0			82
+#define LINUX_KEY_KPDOT		83
+#define LINUX_KEY_ZENKAKUHANKAKU	85
+#define LINUX_KEY_102ND		86
+#define LINUX_KEY_F11			87
+#define LINUX_KEY_F12			88
+#define LINUX_KEY_RO			89
+#define LINUX_KEY_KATAKANA		90
+#define LINUX_KEY_HIRAGANA		91
+#define LINUX_KEY_HENKAN		92
+#define LINUX_KEY_KATAKANAHIRAGANA	93
+#define LINUX_KEY_MUHENKAN		94
+#define LINUX_KEY_KPJPCOMMA		95
+#define LINUX_KEY_KPENTER		96
+#define LINUX_KEY_RIGHTCTRL		97
+#define LINUX_KEY_KPSLASH		98
+#define LINUX_KEY_SYSRQ		99
+#define LINUX_KEY_RIGHTALT		100
+#define LINUX_KEY_LINEFEED		101
+#define LINUX_KEY_HOME		102
+#define LINUX_KEY_UP			103
+#define LINUX_KEY_PAGEUP		104
+#define LINUX_KEY_LEFT		105
+#define LINUX_KEY_RIGHT		106
+#define LINUX_KEY_END			107
+#define LINUX_KEY_DOWN		108
+#define LINUX_KEY_PAGEDOWN		109
+#define LINUX_KEY_INSERT		110
+#define LINUX_KEY_DELETE		111
+#define LINUX_KEY_MACRO		112
+#define LINUX_KEY_MUTE		113
+#define LINUX_KEY_VOLUMEDOWN		114
+#define LINUX_KEY_VOLUMEUP		115
+#define LINUX_KEY_POWER		116	/* SC System Power Down */
+#define LINUX_KEY_KPEQUAL		117
+#define LINUX_KEY_KPPLUSMINUS		118
+#define LINUX_KEY_PAUSE		119
+#define LINUX_KEY_SCALE		120	/* AL Compiz Scale (Expose) */
+#define LINUX_KEY_KPCOMMA		121
+#define LINUX_KEY_HANGEUL		122
+#define LINUX_KEY_HANGUEL		KEY_HANGEUL
+#define LINUX_KEY_HANJA		123
+#define LINUX_KEY_YEN			124
+#define LINUX_KEY_LEFTMETA		125
+#define LINUX_KEY_RIGHTMETA		126
+#define LINUX_KEY_COMPOSE		127
+#define LINUX_KEY_STOP		128	/* AC Stop */
+#define LINUX_KEY_AGAIN		129
+#define LINUX_KEY_PROPS		130	/* AC Properties */
+#define LINUX_KEY_UNDO		131	/* AC Undo */
+#define LINUX_KEY_FRONT		132
+#define LINUX_KEY_COPY		133	/* AC Copy */
+#define LINUX_KEY_OPEN		134	/* AC Open */
+#define LINUX_KEY_PASTE		135	/* AC Paste */
+#define LINUX_KEY_FIND		136	/* AC Search */
+#define LINUX_KEY_CUT			137	/* AC Cut */
+#define LINUX_KEY_HELP		138	/* AL Integrated Help Center */
+#define LINUX_KEY_MENU		139	/* Menu (show menu) */
+#define LINUX_KEY_CALC		140	/* AL Calculator */
+#define LINUX_KEY_SETUP		141
+#define LINUX_KEY_SLEEP		142	/* SC System Sleep */
+#define LINUX_KEY_WAKEUP		143	/* System Wake Up */
+#define LINUX_KEY_FILE		144	/* AL Local Machine Browser */
+#define LINUX_KEY_SENDFILE		145
+#define LINUX_KEY_DELETEFILE		146
+#define LINUX_KEY_XFER		147
+#define LINUX_KEY_PROG1		148
+#define LINUX_KEY_PROG2		149
+#define LINUX_KEY_WWW			150	/* AL Internet Browser */
+#define LINUX_KEY_MSDOS		151
+#define LINUX_KEY_COFFEE		152	/* AL Terminal Lock/Screensaver */
+#define LINUX_KEY_SCREENLOCK		KEY_COFFEE
+#define LINUX_KEY_DIRECTION		153
+#define LINUX_KEY_CYCLEWINDOWS	154
+#define LINUX_KEY_MAIL		155
+#define LINUX_KEY_BOOKMARKS		156	/* AC Bookmarks */
+#define LINUX_KEY_COMPUTER		157
+#define LINUX_KEY_BACK		158	/* AC Back */
+#define LINUX_KEY_FORWARD		159	/* AC Forward */
+#define LINUX_KEY_CLOSECD		160
+#define LINUX_KEY_EJECTCD		161
+#define LINUX_KEY_EJECTCLOSECD	162
+#define LINUX_KEY_NEXTSONG		163
+#define LINUX_KEY_PLAYPAUSE		164
+#define LINUX_KEY_PREVIOUSSONG	165
+#define LINUX_KEY_STOPCD		166
+#define LINUX_KEY_RECORD		167
+#define LINUX_KEY_REWIND		168
+#define LINUX_KEY_PHONE		169	/* Media Select Telephone */
+#define LINUX_KEY_ISO			170
+#define LINUX_KEY_CONFIG		171	/* AL Consumer Control Configuration */
+#define LINUX_KEY_HOMEPAGE		172	/* AC Home */
+#define LINUX_KEY_REFRESH		173	/* AC Refresh */
+#define LINUX_KEY_EXIT		174	/* AC Exit */
+#define LINUX_KEY_MOVE		175
+#define LINUX_KEY_EDIT		176
+#define LINUX_KEY_SCROLLUP		177
+#define LINUX_KEY_SCROLLDOWN		178
+#define LINUX_KEY_KPLEFTPAREN		179
+#define LINUX_KEY_KPRIGHTPAREN	180
+#define LINUX_KEY_NEW			181	/* AC New */
+#define LINUX_KEY_REDO		182	/* AC Redo/Repeat */
+#define LINUX_KEY_F13			183
+#define LINUX_KEY_F14			184
+#define LINUX_KEY_F15			185
+#define LINUX_KEY_F16			186
+#define LINUX_KEY_F17			187
+#define LINUX_KEY_F18			188
+#define LINUX_KEY_F19			189
+#define LINUX_KEY_F20			190
+#define LINUX_KEY_F21			191
+#define LINUX_KEY_F22			192
+#define LINUX_KEY_F23			193
+#define LINUX_KEY_F24			194
+#define LINUX_KEY_PLAYCD		200
+#define LINUX_KEY_PAUSECD		201
+#define LINUX_KEY_PROG3		202
+#define LINUX_KEY_PROG4		203
+#define LINUX_KEY_DASHBOARD		204	/* AL Dashboard */
+#define LINUX_KEY_SUSPEND		205
+#define LINUX_KEY_CLOSE		206	/* AC Close */
+#define LINUX_KEY_PLAY		207
+#define LINUX_KEY_FASTFORWARD		208
+#define LINUX_KEY_BASSBOOST		209
+#define LINUX_KEY_PRINT		210	/* AC Print */
+#define LINUX_KEY_HP			211
+#define LINUX_KEY_CAMERA		212
+#define LINUX_KEY_SOUND		213
+#define LINUX_KEY_QUESTION		214
+#define LINUX_KEY_EMAIL		215
+#define LINUX_KEY_CHAT		216
+#define LINUX_KEY_SEARCH		217
+#define LINUX_KEY_CONNECT		218
+#define LINUX_KEY_FINANCE		219	/* AL Checkbook/Finance */
+#define LINUX_KEY_SPORT		220
+#define LINUX_KEY_SHOP		221
+#define LINUX_KEY_ALTERASE		222
+#define LINUX_KEY_CANCEL		223	/* AC Cancel */
+#define LINUX_KEY_BRIGHTNESSDOWN	224
+#define LINUX_KEY_BRIGHTNESSUP	225
+#define LINUX_KEY_MEDIA		226
+#define LINUX_KEY_SWITCHVIDEOMODE	227	/* Cycle between available video */
+#define LINUX_KEY_KBDILLUMTOGGLE	228
+#define LINUX_KEY_KBDILLUMDOWN	229
+#define LINUX_KEY_KBDILLUMUP		230
+#define LINUX_KEY_SEND		231	/* AC Send */
+#define LINUX_KEY_REPLY		232	/* AC Reply */
+#define LINUX_KEY_FORWARDMAIL		233	/* AC Forward Msg */
+#define LINUX_KEY_SAVE		234	/* AC Save */
+#define LINUX_KEY_DOCUMENTS		235
+#define LINUX_KEY_BATTERY		236
+#define LINUX_KEY_BLUETOOTH		237
+#define LINUX_KEY_WLAN		238
+#define LINUX_KEY_UWB			239
+#define LINUX_KEY_UNKNOWN		240
+#define LINUX_KEY_VIDEO_NEXT		241	/* drive next video source */
+#define LINUX_KEY_VIDEO_PREV		242	/* drive previous video source */
+#define LINUX_KEY_BRIGHTNESS_CYCLE	243	/* brightness up, after max is min */
+#define LINUX_KEY_BRIGHTNESS_ZERO	244	/* brightness off, use ambient */
+#define LINUX_KEY_DISPLAY_OFF		245	/* display device to off state */
+#define LINUX_KEY_WWAN		246	/* Wireless WAN (LTE, UMTS, GSM, etc.) */
+#define LINUX_KEY_WIMAX		KEY_WWAN
+#define LINUX_KEY_RFKILL		247	/* Key that controls all radios */
+#define LINUX_KEY_MICMUTE		248	/* Mute / unmute the microphone */
+#define LINUX_KEY_OK			0x160
+#define LINUX_KEY_SELECT		0x161
+#define LINUX_KEY_GOTO		0x162
+#define LINUX_KEY_CLEAR		0x163
+#define LINUX_KEY_POWER2		0x164
+#define LINUX_KEY_OPTION		0x165
+#define LINUX_KEY_INFO		0x166	/* AL OEM Features/Tips/Tutorial */
+#define LINUX_KEY_TIME		0x167
+#define LINUX_KEY_VENDOR		0x168
+#define LINUX_KEY_ARCHIVE		0x169
+#define LINUX_KEY_PROGRAM		0x16a	/* Media Select Program Guide */
+#define LINUX_KEY_CHANNEL		0x16b
+#define LINUX_KEY_FAVORITES		0x16c
+#define LINUX_KEY_EPG			0x16d
+#define LINUX_KEY_PVR			0x16e	/* Media Select Home */
+#define LINUX_KEY_MHP			0x16f
+#define LINUX_KEY_LANGUAGE		0x170
+#define LINUX_KEY_TITLE		0x171
+#define LINUX_KEY_SUBTITLE		0x172
+#define LINUX_KEY_ANGLE		0x173
+#define LINUX_KEY_ZOOM		0x174
+#define LINUX_KEY_MODE		0x175
+#define LINUX_KEY_KEYBOARD		0x176
+#define LINUX_KEY_SCREEN		0x177
+#define LINUX_KEY_PC			0x178	/* Media Select Computer */
+#define LINUX_KEY_TV			0x179	/* Media Select TV */
+#define LINUX_KEY_TV2			0x17a	/* Media Select Cable */
+#define LINUX_KEY_VCR			0x17b	/* Media Select VCR */
+#define LINUX_KEY_VCR2		0x17c	/* VCR Plus */
+#define LINUX_KEY_SAT			0x17d	/* Media Select Satellite */
+#define LINUX_KEY_SAT2		0x17e
+#define LINUX_KEY_CD			0x17f	/* Media Select CD */
+#define LINUX_KEY_TAPE		0x180	/* Media Select Tape */
+#define LINUX_KEY_RADIO		0x181
+#define LINUX_KEY_TUNER		0x182	/* Media Select Tuner */
+#define LINUX_KEY_PLAYER		0x183
+#define LINUX_KEY_TEXT		0x184
+#define LINUX_KEY_DVD			0x185	/* Media Select DVD */
+#define LINUX_KEY_AUX			0x186
+#define LINUX_KEY_MP3			0x187
+#define LINUX_KEY_AUDIO		0x188	/* AL Audio Browser */
+#define LINUX_KEY_VIDEO		0x189	/* AL Movie Browser */
+#define LINUX_KEY_DIRECTORY		0x18a
+#define LINUX_KEY_LIST		0x18b
+#define LINUX_KEY_MEMO		0x18c	/* Media Select Messages */
+#define LINUX_KEY_CALENDAR		0x18d
+#define LINUX_KEY_RED			0x18e
+#define LINUX_KEY_GREEN		0x18f
+#define LINUX_KEY_YELLOW		0x190
+#define LINUX_KEY_BLUE		0x191
+#define LINUX_KEY_CHANNELUP		0x192	/* Channel Increment */
+#define LINUX_KEY_CHANNELDOWN		0x193	/* Channel Decrement */
+#define LINUX_KEY_FIRST		0x194
+#define LINUX_KEY_LAST		0x195	/* Recall Last */
+#define LINUX_KEY_AB			0x196
+#define LINUX_KEY_NEXT		0x197
+#define LINUX_KEY_RESTART		0x198
+#define LINUX_KEY_SLOW		0x199
+#define LINUX_KEY_SHUFFLE		0x19a
+#define LINUX_KEY_BREAK		0x19b
+#define LINUX_KEY_PREVIOUS		0x19c
+#define LINUX_KEY_DIGITS		0x19d
+#define LINUX_KEY_TEEN		0x19e
+#define LINUX_KEY_TWEN		0x19f
+#define LINUX_KEY_VIDEOPHONE		0x1a0	/* Media Select Video Phone */
+#define LINUX_KEY_GAMES		0x1a1	/* Media Select Games */
+#define LINUX_KEY_ZOOMIN		0x1a2	/* AC Zoom In */
+#define LINUX_KEY_ZOOMOUT		0x1a3	/* AC Zoom Out */
+#define LINUX_KEY_ZOOMRESET		0x1a4	/* AC Zoom */
+#define LINUX_KEY_WORDPROCESSOR	0x1a5	/* AL Word Processor */
+#define LINUX_KEY_EDITOR		0x1a6	/* AL Text Editor */
+#define LINUX_KEY_SPREADSHEET		0x1a7	/* AL Spreadsheet */
+#define LINUX_KEY_GRAPHICSEDITOR	0x1a8	/* AL Graphics Editor */
+#define LINUX_KEY_PRESENTATION	0x1a9	/* AL Presentation App */
+#define LINUX_KEY_DATABASE		0x1aa	/* AL Database App */
+#define LINUX_KEY_NEWS		0x1ab	/* AL Newsreader */
+#define LINUX_KEY_VOICEMAIL		0x1ac	/* AL Voicemail */
+#define LINUX_KEY_ADDRESSBOOK		0x1ad	/* AL Contacts/Address Book */
+#define LINUX_KEY_MESSENGER		0x1ae	/* AL Instant Messaging */
+#define LINUX_KEY_DISPLAYTOGGLE	0x1af	/* Turn display (LCD) on and off */
+#define LINUX_KEY_SPELLCHECK		0x1b0   /* AL Spell Check */
+#define LINUX_KEY_LOGOFF		0x1b1   /* AL Logoff */
+#define LINUX_KEY_DOLLAR		0x1b2
+#define LINUX_KEY_EURO		0x1b3
+#define LINUX_KEY_FRAMEBACK		0x1b4	/* Consumer - transport controls */
+#define LINUX_KEY_FRAMEFORWARD	0x1b5
+#define LINUX_KEY_CONTEXT_MENU	0x1b6	/* GenDesc - system context menu */
+#define LINUX_KEY_MEDIA_REPEAT	0x1b7	/* Consumer - transport control */
+#define LINUX_KEY_10CHANNELSUP	0x1b8	/* 10 channels up (10+) */
+#define LINUX_KEY_10CHANNELSDOWN	0x1b9	/* 10 channels down (10-) */
+#define LINUX_KEY_IMAGES		0x1ba	/* AL Image Browser */
+#define LINUX_KEY_DEL_EOL		0x1c0
+#define LINUX_KEY_DEL_EOS		0x1c1
+#define LINUX_KEY_INS_LINE		0x1c2
+#define LINUX_KEY_DEL_LINE		0x1c3
+#define LINUX_KEY_FN			0x1d0
+#define LINUX_KEY_FN_ESC		0x1d1
+#define LINUX_KEY_FN_F1		0x1d2
+#define LINUX_KEY_FN_F2		0x1d3
+#define LINUX_KEY_FN_F3		0x1d4
+#define LINUX_KEY_FN_F4		0x1d5
+#define LINUX_KEY_FN_F5		0x1d6
+#define LINUX_KEY_FN_F6		0x1d7
+#define LINUX_KEY_FN_F7		0x1d8
+#define LINUX_KEY_FN_F8		0x1d9
+#define LINUX_KEY_FN_F9		0x1da
+#define LINUX_KEY_FN_F10		0x1db
+#define LINUX_KEY_FN_F11		0x1dc
+#define LINUX_KEY_FN_F12		0x1dd
+#define LINUX_KEY_FN_1		0x1de
+#define LINUX_KEY_FN_2		0x1df
+#define LINUX_KEY_FN_D		0x1e0
+#define LINUX_KEY_FN_E		0x1e1
+#define LINUX_KEY_FN_F		0x1e2
+#define LINUX_KEY_FN_S		0x1e3
+#define LINUX_KEY_FN_B		0x1e4
+#define LINUX_KEY_BRL_DOT1		0x1f1
+#define LINUX_KEY_BRL_DOT2		0x1f2
+#define LINUX_KEY_BRL_DOT3		0x1f3
+#define LINUX_KEY_BRL_DOT4		0x1f4
+#define LINUX_KEY_BRL_DOT5		0x1f5
+#define LINUX_KEY_BRL_DOT6		0x1f6
+#define LINUX_KEY_BRL_DOT7		0x1f7
+#define LINUX_KEY_BRL_DOT8		0x1f8
+#define LINUX_KEY_BRL_DOT9		0x1f9
+#define LINUX_KEY_BRL_DOT10		0x1fa
+#define LINUX_KEY_NUMERIC_0		0x200	/* used by phones, remote controls, */
+#define LINUX_KEY_NUMERIC_1		0x201	/* and other keypads */
+#define LINUX_KEY_NUMERIC_2		0x202
+#define LINUX_KEY_NUMERIC_3		0x203
+#define LINUX_KEY_NUMERIC_4		0x204
+#define LINUX_KEY_NUMERIC_5		0x205
+#define LINUX_KEY_NUMERIC_6		0x206
+#define LINUX_KEY_NUMERIC_7		0x207
+#define LINUX_KEY_NUMERIC_8		0x208
+#define LINUX_KEY_NUMERIC_9		0x209
+#define LINUX_KEY_NUMERIC_STAR	0x20a
+#define LINUX_KEY_NUMERIC_POUND	0x20b
+#define LINUX_KEY_CAMERA_FOCUS	0x210
+#define LINUX_KEY_WPS_BUTTON		0x211	/* WiFi Protected Setup key */
+#define LINUX_KEY_TOUCHPAD_TOGGLE	0x212	/* Request switch touchpad on or off */
+#define LINUX_KEY_TOUCHPAD_ON		0x213
+#define LINUX_KEY_TOUCHPAD_OFF	0x214
+#define LINUX_KEY_CAMERA_ZOOMIN	0x215
+#define LINUX_KEY_CAMERA_ZOOMOUT	0x216
+#define LINUX_KEY_CAMERA_UP		0x217
+#define LINUX_KEY_CAMERA_DOWN		0x218
+#define LINUX_KEY_CAMERA_LEFT		0x219
+#define LINUX_KEY_CAMERA_RIGHT	0x21a
+#define LINUX_KEY_ATTENDANT_ON	0x21b
+#define LINUX_KEY_ATTENDANT_OFF	0x21c
+#define LINUX_KEY_ATTENDANT_TOGGLE	0x21d	/* Attendant call on or off */
+#define LINUX_KEY_LIGHTS_TOGGLE	0x21e	/* Reading light on or off */
+#define LINUX_KEY_ALS_TOGGLE		0x230	/* Ambient light sensor */
+#define LINUX_KEY_MIN_INTERESTING	LINUX_KEY_MUTE
+#define LINUX_KEY_MAX			0x2ff
+#define LINUX_KEY_CNT			(LINUX_KEY_MAX+1)
+
diff --git a/partner/graphics/rpi/EffectsGLES2.cpp b/partner/graphics/rpi/EffectsGLES2.cpp
new file mode 100644
index 00000000..0c2b7a00
--- /dev/null
+++ b/partner/graphics/rpi/EffectsGLES2.cpp
@@ -0,0 +1,1572 @@
+/* (c) 2013 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+
+#include "EffectsGLES2.h"
+#include "Animation.h"
+#include "Screen.h"
+#include "WidgetBridge.h"
+#include "SurfaceCache.h"
+#include <nrdbase/Instrumentation.h>
+#include <GibbonDebug.h>
+#include <nrdbase/VarLengthArray.h>
+
+using namespace netflix;
+using namespace netflix::gibbon;
+
+struct BlurShaderGenerator
+{
+    struct Data
+    {
+        std::string vertex;
+        std::string fragment;
+    };
+
+    static void generate(const GLfloat *weights, uint32_t weightCount, Data& data);
+};
+
+// Shader generator based on code from https://github.com/BradLarson/GPUImage/, under the following BSD license:
+
+// Copyright (c) 2012, Brad Larson, Ben Cochran, Hugues Lismonde, Keitaroh Kobayashi, Alaric Cole, Matthew Clark, Jacob Gundersen, Chris Williams.
+// All rights reserved.
+
+// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
+
+// Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+
+// Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation
+// and/or other materials provided with the distribution.
+
+// Neither the name of the GPUImage framework nor the names of its contributors may be used to endorse or promote products derived from this software
+// without specific prior written permission.
+
+// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
+// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR
+// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+// LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+// EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+void BlurShaderGenerator::generate(const GLfloat *weights, uint32_t weightCount, Data &data)
+{
+    const uint32_t actualOffsets = (weightCount-1) / 2;
+    const uint32_t optimizedOffsets = std::min(actualOffsets, static_cast<uint32_t>(7));
+
+    VarLengthArray<GLfloat, 25> offsets(optimizedOffsets);
+    for(uint32_t i = 0; i < optimizedOffsets; ++i) {
+        const uint32_t offset1 = i * 2 + 1, offset2 = i * 2 + 2;
+        const GLfloat value1 = weights[offset1], value2 = weights[offset2];
+        const GLfloat weight = value1 + value2;
+        offsets[i] = (value1 * offset1 + value2 * offset2) / weight;
+    }
+
+    data.vertex = StringFormatter::sformat(
+        "attribute vec4 position;\n"
+        "attribute vec2 inputTextureCoordinate;\n"
+        "uniform float texelWidthOffset;\n"
+        "uniform float texelHeightOffset;\n"
+        "uniform mat4 projectionMatrix;\n"
+        "uniform mat4 mvMatrix;\n"
+        "varying vec2 blurCoordinates[%u];\n"
+        "void main() {\n"
+        "  gl_Position = (projectionMatrix * mvMatrix) * position;\n"
+        //"  gl_Position = projectionMatrix * position;\n"
+        "  vec2 singleStepOffset = vec2(texelWidthOffset, texelHeightOffset);\n",
+        1 + (optimizedOffsets * 2));
+    data.vertex += "  blurCoordinates[0] = inputTextureCoordinate;\n";
+    for(uint32_t i = 0; i < optimizedOffsets; ++i) {
+        data.vertex += StringFormatter::sformat("  blurCoordinates[%u] = inputTextureCoordinate + singleStepOffset * %f;\n", i * 2 + 1, offsets[i]);
+        data.vertex += StringFormatter::sformat("  blurCoordinates[%u] = inputTextureCoordinate - singleStepOffset * %f;\n", i * 2 + 2, offsets[i]);
+    }
+    data.vertex += "}\n";
+
+    data.fragment = StringFormatter::sformat(
+        "#ifdef GL_ES\n"
+        "precision highp float;\n"
+        "#endif\n"
+        "uniform sampler2D inputImageTexture;\n"
+        "uniform float texelWidthOffset;\n"
+        "uniform float texelHeightOffset;\n"
+        "uniform float opacity;\n"
+        "varying vec2 blurCoordinates[%u];\n"
+        "void main() {\n"
+        "  vec4 sum = vec4(0.0);\n",
+        1 + (optimizedOffsets * 2));
+    data.fragment += StringFormatter::sformat("  sum += texture2D(inputImageTexture, blurCoordinates[0]) * %f;\n", weights[0]);
+    GLfloat weightSum = weights[0];
+    for(uint32_t i = 0; i < optimizedOffsets; ++i) {
+        const uint32_t offset1 = i * 2 + 1, offset2 = i * 2 + 2;
+        const GLfloat value1 = weights[offset1], value2 = weights[offset2];
+        const GLfloat weight = value1 + value2;
+        weightSum += (weight * 2);
+        data.fragment += StringFormatter::sformat("  sum += texture2D(inputImageTexture, blurCoordinates[%u]) * %f;\n", offset1, weight);
+        data.fragment += StringFormatter::sformat("  sum += texture2D(inputImageTexture, blurCoordinates[%u]) * %f;\n", offset2, weight);
+    }
+    if(actualOffsets > optimizedOffsets) {
+        data.fragment += "  vec2 singleStepOffset = vec2(texelWidthOffset, texelHeightOffset);\n";
+        for(uint32_t i = optimizedOffsets; i < actualOffsets; ++i) {
+            const uint32_t offset1 = i * 2 + 1, offset2 = i * 2 + 2;
+            const GLfloat value1 = weights[offset1], value2 = weights[offset2];
+            const GLfloat weight = value1 + value2;
+            weightSum += (weight * 2);
+            const GLfloat offset = (value1 * offset1 + value2 * offset2) / weight;
+            data.fragment += StringFormatter::sformat("  sum += texture2D(inputImageTexture, blurCoordinates[0] + singleStepOffset * %f) * %f;\n",
+                                                      offset, weight);
+            data.fragment += StringFormatter::sformat("  sum += texture2D(inputImageTexture, blurCoordinates[0] - singleStepOffset * %f) * %f;\n",
+                                                      offset, weight);
+        }
+    }
+    if(!fuzzy_compare(weightSum, 1.0f)) {
+        data.fragment +=
+            "  if(sum.a >= " + StringFormatter::sformat("%f", floor(weightSum * 100.) / 100.) + ")\n"
+            "    sum.a = 1.0;\n";
+    }
+    data.fragment +=
+        "  gl_FragColor = sum * opacity;\n"
+        "}\n";
+}
+
+namespace netflix {
+namespace gibbon {
+class BlurEffectGLES2Command : public DisplayList::Command
+{
+public:
+    BlurEffectGLES2Command() : Command(Type_GLBlurEffect) { }
+    BlurEffectGLES2Command(const std::shared_ptr<EffectBlurGLES2::Shader> &shader, const DisplayList::SharedPtr &displayList,
+                           const Rect &rect, const Rect &resultRect, const EffectBlur::Data &data) : Command(Type_GLBlurEffect), mRect(rect), mResultRect(resultRect),
+                                                                                                     mDisplayList(displayList), mData(data), mShader(shader)
+    { }
+
+    virtual DisplayList::SharedPtr getSubcommands() const override { return mDisplayList; }
+    virtual uint8_t getFlags() const override { return Flag_Renderable; }
+    virtual Rect getRect(State *state) const override
+    {
+        if(!state)
+            return mResultRect;
+        return state->map(mResultRect);
+    }
+    virtual std::string describe() const override
+    {
+        StringBuilder s;
+        s << "Blur()";
+        return s.str();
+    }
+    virtual void execute(GraphicsEngine *graphics, State *state) const override;
+
+private:
+    Rect mRect, mResultRect;
+    DisplayList::SharedPtr mDisplayList;
+    EffectBlur::Data mData;
+    std::shared_ptr<EffectBlurGLES2::Shader> mShader;
+};
+
+class ShaderEffectGLES2Command : public DisplayList::Command
+{
+public:
+    enum TexturesUpdate {
+        TexturesUpdate_Pending,
+        TexturesUpdate_Ready,
+        TexturesUpdate_ReadyNoContent,
+        TexturesUpdate_Error,
+    };
+    ShaderEffectGLES2Command() : Command(Type_GLShaderEffect), mTexturesUpdate(TexturesUpdate_Pending) { }
+    ShaderEffectGLES2Command(const std::shared_ptr<OpenGLShader> &shader, const DisplayList::SharedPtr &displayList,
+                             const Rect &rect, const Rect &resultRect, const EffectShader::Data &data) : Command(Type_GLShaderEffect),
+                                                                                                         mTexturesUpdate(TexturesUpdate_Pending),
+                                                                                                         mRect(rect), mResultRect(resultRect),
+                                                                                                         mDisplayList(displayList), mData(data),
+                                                                                                         mShader(shader) { }
+
+    virtual DisplayList::SharedPtr getSubcommands() const override { return mDisplayList; }
+    virtual uint8_t getFlags() const override { return Flag_Renderable; }
+    virtual Rect getRect(State *state) const override
+    {
+        if(state)
+            return state->map(mRect);
+        return mRect;
+    }
+    virtual std::string describe() const override
+    {
+        StringBuilder s;
+        s << "Shader()";
+        return s.str();
+    }
+    virtual void prerender() override;
+    virtual void execute(GraphicsEngine *graphics, State *state) const override;
+    void applyUniform(OpenGLState *glState, const EffectShader::Data::Uniform &uniform,
+                      GraphicsEngine *graphics, State *state, const Surface::SharedPtr &content,
+                      unsigned int &boundTexture) const;
+
+private:
+    void updateTextures(Flags<GraphicsEngine::Flag> flags) const;
+    mutable Surface::SharedPtr mContent;
+    mutable TexturesUpdate mTexturesUpdate;
+
+    Rect mRect, mResultRect;
+    DisplayList::SharedPtr mDisplayList;
+    EffectShader::Data mData;
+    std::shared_ptr<OpenGLShader> mShader;
+};
+
+class OpenGLShaderManagerCommand : public DisplayList::Command
+{
+public:
+    OpenGLShaderManagerCommand(const std::shared_ptr<TextureShader> &shader,
+                               const DisplayList::SharedPtr &displayList, const Rect &rect,
+                               const Rect &resultRect) : Command(Type_GLManagerEffect), mRect(rect),
+                                                         mResultRect(resultRect),
+                                                         mDisplayList(displayList), mShader(shader)
+    {
+    }
+
+    virtual DisplayList::SharedPtr getSubcommands() const override { return mDisplayList; }
+    virtual uint8_t getFlags() const override { return Flag_Renderable; }
+    virtual Rect getRect(State *state) const override
+    {
+        if(state)
+            return state->map(mRect);
+        return mRect;
+    }
+    virtual std::string describe() const override
+    {
+        return std::string("ShaderManagerCommand(") + mShader->describe() + ")";
+    }
+
+    virtual void execute(GraphicsEngine *graphics, State *state) const override;
+
+protected:
+    Rect mRect, mResultRect;
+    DisplayList::SharedPtr mDisplayList;
+    std::shared_ptr<TextureShader> mShader;
+};
+
+void OpenGLShaderManagerCommand::execute(GraphicsEngine *graphics, State *state) const
+{
+    const Surface::SharedPtr surface = mDisplayList->flatten();
+    if(!surface || !surface->isValid())
+        return;
+
+    if(!Surface::isValidRect(mResultRect))
+        return;
+
+    OpenGLContext *context = OpenGLContext::context();
+    OpenGLState *glstate = context->state();
+
+    GLuint texture = surface->getTexture();
+    if(!texture)
+        Log::warn(TRACE_GIBBON_GRAPHICS, "Bind failed %fx%f", surface->getWidth(), surface->getHeight());
+
+    OpenGLState::Scope stateScope(glstate);
+    OpenGLShader::Scope scope(mShader);
+    OpenGLProgram::SharedPtr program = mShader->program();
+
+    Transform projectionMatrix;
+    if(graphics->isScreen())
+        projectionMatrix.scale(1, -1);
+    const Rect dstRect = state->map(mResultRect);
+    const Transform modelViewMatrix = graphics->transform();
+
+    stateScope.setFormat(surface->getFormat(), graphics->getSurface()->getFormat());
+    stateScope.setCompositionMode(graphics->getCompositionMode());
+
+    const Rect oldClip = graphics->clip();
+    if(!GibbonDebug::TestGraphicsNoClip) {
+        Rect clip(dstRect);
+        if(graphics->hasTransform())
+            clip = modelViewMatrix.map(clip, graphics->getRect());
+        if(graphics->hasClip())
+            clip.intersect(oldClip);
+        graphics->updateClip(clip);
+        stateScope.enableScissor(true);
+    }
+    GL_ASSERT(glstate);
+
+    glUniformMatrix4fv(program->variable(TextureShader::ProjMatrix), 1, GL_FALSE, projectionMatrix.matrix());
+    glUniformMatrix4fv(program->variable(TextureShader::MVMatrix), 1, GL_FALSE, modelViewMatrix.matrix());
+
+    GLfloat opacity[4] = { 1.0f, 1.0f, 1.0f, state->opacity };
+    if((surface->getFormat() & Surface::Flag_Premultiplied)) {
+        opacity[0] *= opacity[3];
+        opacity[1] *= opacity[3];
+        opacity[2] *= opacity[3];
+    }
+    glUniform4fv(program->variable(TextureShader::Opacity), 1, opacity);
+
+    const GLfloat texTransform[4] = { 0, 0, dstRect.width / surface->getWidth(), dstRect.height / surface->getHeight() };
+    glUniform4fv(program->variable(TextureShader::TextureTransform), 1, texTransform);
+
+    GL_ASSERT(glstate);
+    const GLfloat vertices[4] = {
+        graphics->mapX(dstRect.left()),  graphics->mapY(dstRect.top()),
+        graphics->mapX(dstRect.right()), graphics->mapY(dstRect.bottom())
+    };
+    glUniform4fv(program->variable(TextureShader::Rect), 1, vertices);
+
+    GL_ASSERT(glstate);
+    mShader->bindVertexBuffer();
+
+    GL_ASSERT(glstate);
+    glstate->bindTexture(texture);
+
+    stateScope.flush();
+
+    mShader->render();
+    graphics->updateClip(oldClip);
+}
+
+class BlurShaderCache
+{
+public:
+    typedef EffectBlurGLES2::Shader Shader;
+
+    static Shader::SharedPtr get(OpenGLContext *context, const GLfloat *weights, uint32_t weightCount, uint32_t weightHash);
+};
+
+BlurShaderCache::Shader::SharedPtr BlurShaderCache::get(OpenGLContext *context, const GLfloat *weights, uint32_t weightCount, uint32_t weightHash)
+{
+    const std::string name = StringFormatter::sformat("BlurShader%d", weightHash);
+    if (const OpenGLProgram::SharedPtr program = OpenGLShaders::findProgramByName(name))
+        return Shader::SharedPtr(new Shader(program, weightHash));
+
+    BlurShaderGenerator::Data generated;
+    BlurShaderGenerator::generate(weights, weightCount, generated);
+
+    Shader::SharedPtr shader(new Shader(context, generated.vertex.c_str(), generated.fragment.c_str(), name, weightHash));
+    shader->use();
+    GL_ASSERT(context->state());
+
+    OpenGLProgram::SharedPtr program = shader->program();
+    program->defineAttribute(Shader::Position, "position");
+    program->defineAttribute(Shader::TexCoord, "inputTextureCoordinate");
+    program->defineUniform(Shader::TexelWidth, "texelWidthOffset");
+    program->defineUniform(Shader::TexelHeight, "texelHeightOffset");
+    program->defineUniform(Shader::ProjMatrix, "projectionMatrix");
+    program->defineUniform(Shader::MVMatrix, "mvMatrix");
+    program->defineUniform(Shader::Opacity, "opacity");
+
+    glUniform1i(glGetUniformLocation(program->program(), "inputImageTexture"), 0);
+    return shader;
+}
+
+}} // namespace netflix::gibbon
+
+EffectBlurGLES2::GLES2Renderer::~GLES2Renderer()
+{
+}
+
+EffectBlurGLES2::Renderer::SharedPtr EffectBlurGLES2::getDefaultRenderer()
+{
+    if(mData.weights.size()) {
+        uint32_t weightHash = 0xDEADB33F;
+        for(uint32_t i = 0; i < mData.weights.size(); ++i)
+            weightHash ^= uint32_t(mData.weights[i]);
+        if(!mShader || mShader->weightHash() != weightHash)
+            mShader = BlurShaderCache::get(OpenGLContext::context(), mData.weights.data(), mData.radius+1, weightHash);
+    } else {
+        assert(mData.radius > 0);
+        const uint32_t weightHash = mData.radius;
+        if(!mShader || mShader->weightHash() != weightHash) {
+            GLfloat weightSum = 0.;
+            const GLfloat minWeight = 1. / 256.;
+            const uint32_t weightCount = static_cast<uint32_t>(floor(sqrt(-2. * pow(mData.radius, 2.) * log(minWeight * sqrt(2. * M_PI * pow(mData.radius, 2.)))))) + 1;
+            VarLengthArray<GLfloat, 50> weights(weightCount);
+            for(uint32_t i = 0; i < weightCount; ++i) {
+                weights[i] = (1. / sqrt(2. * M_PI * pow(mData.radius, 2.))) * exp(-pow(i, 2.) / (2. * pow(mData.radius, 2.)));
+                if(i)
+                    weightSum += 2. * weights[i];
+                else
+                    weightSum += weights[i];
+            }
+            for(uint32_t i = 0; i < weightCount; ++i)
+                weights[i] /= weightSum;
+            mShader = BlurShaderCache::get(OpenGLContext::context(), weights.constData(), weightCount, weightHash);
+        }
+    }
+    return Renderer::SharedPtr(new GLES2Renderer(mShader, mData));
+}
+
+void BlurEffectGLES2Command::execute(GraphicsEngine *graphics, State *state) const
+{
+    const Rect &dlRect = mDisplayList->getRect();
+    const Rect scaledRect(0, 0, (dlRect.width / mData.factor) + (mData.radius * 2), (dlRect.height / mData.factor) + (mData.radius * 2));
+
+    const Surface::SharedPtr flattened = mDisplayList->flatten();
+    if (!flattened || !flattened->isValid())
+        return;
+
+    Surface::SharedPtr surface1;
+    if (flattened->getRect() != scaledRect || flattened->getRect() != dlRect) {
+        surface1 = Effect::requestSurface(scaledRect.width, scaledRect.height, true);
+        assert(surface1);
+        surface1->setDescription(describe() + ":source");
+        {
+            GraphicsEngine engine(surface1, GraphicsEngine::ColorBuffer, graphics->transferFlags());
+            engine.clear(scaledRect);
+            engine.setSmoothScale(GraphicsEngine::SmoothScale_Linear);
+            engine.blit(flattened, dlRect, Rect(mData.radius, mData.radius, dlRect.width / mData.factor, dlRect.height / mData.factor));
+        }
+    } else {
+        surface1 = flattened;
+    }
+
+    OpenGLContext *context = OpenGLContext::context();
+    OpenGLState *glState = context->state();
+
+    const Rect mappedRect = state->transform.map(state->map(mRect));
+
+    GL_ASSERT(glState);
+
+    Surface::SharedPtr surface2, surface3;
+    if(mData.direction == EffectBlur::Data::Direction_Both) {
+        surface2 = Effect::requestSurface(scaledRect.width, scaledRect.height, true);
+        assert(surface2);
+        surface2->setDescription(describe() + ":horizontal");
+
+        GLuint texture = surface1->getTexture();
+        if(!texture)
+            Log::warn(TRACE_GIBBON_GRAPHICS, "Bind failed %fx%f", surface1->getWidth(), surface1->getHeight());
+
+        GraphicsEngine engine(surface2, GraphicsEngine::ColorBuffer, graphics->transferFlags());
+        engine.clear(scaledRect);
+
+        OpenGLShader::Scope scope(mShader);
+        OpenGLState::Scope stateScope(glState);
+        OpenGLProgram::SharedPtr program = mShader->program();
+
+        stateScope.disableCap(GL_SCISSOR_TEST);
+
+        Transform projMatrix;
+        projMatrix.scale(1, -1);
+        glUniformMatrix4fv(program->variable(EffectBlurGLES2::Shader::ProjMatrix), 1, GL_FALSE, projMatrix.matrix());
+        GL_ASSERT(glState);
+
+        Transform mvMatrix;
+        glUniformMatrix4fv(program->variable(EffectBlurGLES2::Shader::MVMatrix), 1, GL_FALSE, mvMatrix.matrix());
+
+        GL_ASSERT(glState);
+
+        if(mData.texelWidth == -1)
+            glUniform1f(program->variable(EffectBlurGLES2::Shader::TexelWidth), 1. / (mappedRect.width * 2.));
+        else
+            glUniform1f(program->variable(EffectBlurGLES2::Shader::TexelWidth), 1. / (mData.texelWidth * 2.));
+        glUniform1f(program->variable(EffectBlurGLES2::Shader::TexelHeight), 0);
+        glUniform1f(program->variable(EffectBlurGLES2::Shader::Opacity), 1.);
+
+        GL_ASSERT(glState);
+        stateScope.setFormat(surface1->getFormat(), surface2->getFormat());
+        stateScope.setCompositionMode(GraphicsEngine::CompositionMode_SourceOver);
+
+        GL_ASSERT(glState);
+        glState->bindTexture(texture);
+        glState->setSmoothScale(texture, true);
+
+        stateScope.flush();
+
+        GL_ASSERT(glState);
+        mShader->render();
+        GL_ASSERT(glState);
+    } else {
+        surface2 = surface1;
+    }
+
+    GL_ASSERT(glState);
+
+    {
+        GLuint texture = surface2->getTexture();
+        if(!texture)
+            Log::warn(TRACE_GIBBON_GRAPHICS, "Bind failed %fx%f", surface2->getWidth(), surface2->getHeight());
+
+        OpenGLState::Scope stateScope(glState);
+
+        GraphicsEngine *engine = graphics;
+        if(NRDP_UNLIKELY(GibbonDebug::TestGLEffectBlurSurface)) {
+            surface3 = Effect::requestSurface(scaledRect.width, scaledRect.height, true);
+            assert(surface3);
+            surface3->setDescription(describe() + ":vertical");
+            engine = new GraphicsEngine(surface3);
+            stateScope.disableCap(GL_SCISSOR_TEST);
+            engine->clear(scaledRect);
+        } else {
+            stateScope.enableScissor(!(engine->getState().flags & GraphicsEngine::Flag_NoClip));
+        }
+
+        OpenGLShader::Scope scope(mShader);
+        OpenGLProgram::SharedPtr program = mShader->program();
+
+        Transform projectionMatrix;
+
+        if(engine->isScreen() || NRDP_UNLIKELY(GibbonDebug::TestGLEffectBlurSurface))
+            projectionMatrix.scale(1, -1);
+
+        glUniformMatrix4fv(program->variable(EffectBlurGLES2::Shader::ProjMatrix), 1, GL_FALSE, projectionMatrix.matrix());
+
+        Transform factorMatrix;
+        factorMatrix.translateNormalized(-1, -1);
+        factorMatrix.scale(mData.factor, mData.factor);
+        factorMatrix.translateNormalized(1, 1);
+
+        Transform modelViewMatrix = engine->transform();
+        modelViewMatrix *= factorMatrix;
+        glUniformMatrix4fv(program->variable(EffectBlurGLES2::Shader::MVMatrix), 1, GL_FALSE, modelViewMatrix.matrix());
+
+        Rect dstRect = state->map(scaledRect);
+        dstRect.x += mData.radius;
+        dstRect.y += mData.radius;
+        dstRect.x /= mData.factor;
+        dstRect.y /= mData.factor;
+        dstRect.x -= mData.radius;
+        dstRect.y -= mData.radius;
+
+        if(mData.direction == EffectBlur::Data::Direction_Horizontal) {
+            if(mData.texelWidth == -1)
+                glUniform1f(program->variable(EffectBlurGLES2::Shader::TexelWidth), 1. / (mappedRect.width * 2.));
+            else
+                glUniform1f(program->variable(EffectBlurGLES2::Shader::TexelWidth), 1. / (mData.texelWidth * 2.));
+            glUniform1f(program->variable(EffectBlurGLES2::Shader::TexelHeight), 0);
+        } else {
+            glUniform1f(program->variable(EffectBlurGLES2::Shader::TexelWidth), 0);
+            if(mData.texelHeight == -1)
+                glUniform1f(program->variable(EffectBlurGLES2::Shader::TexelHeight), 1. / (mappedRect.height * 2.));
+            else
+                glUniform1f(program->variable(EffectBlurGLES2::Shader::TexelHeight), 1. / (mData.texelHeight * 2.));
+        }
+        glUniform1f(program->variable(EffectBlurGLES2::Shader::Opacity), state->opacity);
+
+        if(NRDP_LIKELY(!GibbonDebug::TestGLEffectBlurSurface)) {
+            const GLfloat vertices[16] = {
+                engine->mapX(dstRect.left()),  engine->mapY(dstRect.top()),    0.0, 0.0,
+                engine->mapX(dstRect.left()),  engine->mapY(dstRect.bottom()), 0.0, 1.0,
+                engine->mapX(dstRect.right()), engine->mapY(dstRect.bottom()), 1.0, 1.0,
+                engine->mapX(dstRect.right()), engine->mapY(dstRect.top()),    1.0, 0.0
+            };
+            mShader->bindVertexBuffer();
+            glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_DYNAMIC_DRAW);
+        }
+
+        stateScope.setFormat(surface2->getFormat(), engine->getSurface()->getFormat());
+        stateScope.setCompositionMode(graphics->getCompositionMode());
+
+        glState->bindTexture(texture);
+        glState->setSmoothScale(texture, true);
+
+        stateScope.flush();
+
+        GL_ASSERT(glState);
+        mShader->render();
+        GL_ASSERT(glState);
+
+        if(NRDP_UNLIKELY(GibbonDebug::TestGLEffectBlurSurface)) {
+            assert(engine && engine != graphics);
+            delete engine;
+
+            // blit surface3 to the screen
+            const GLfloat texTransform[4] = { 0, 0, 1, 1 };
+            graphics->drawTexture(surface3->getTexture(), texTransform, dstRect, surface3->getFlags());
+        }
+    }
+}
+
+DisplayList::SharedPtr EffectBlurGLES2::GLES2Renderer::render(const DisplayList::SharedPtr &dl, const Rect &area, Flags<RenderFlag>) const
+{
+    if(!mData.radius)
+        return dl;
+
+    const Rect resultRect = getRect(area);
+    if(!Surface::isValidRect(resultRect))
+        return DisplayList::SharedPtr();
+
+    DisplayList::SharedPtr ret(new DisplayList(resultRect.size()));
+    ret->appendCommand(new BlurEffectGLES2Command(mShader, dl, area, resultRect, mData));
+    return ret;
+}
+
+class DesaturateVertex : public OpenGLShader::Part
+{
+public:
+    DesaturateVertex() : Part(0) { }
+    virtual std::string declarations() const override { return std::string(); }
+    virtual std::string body() const override { return std::string(); }
+};
+
+class DesaturateFragment : public OpenGLShader::Part
+{
+public:
+    DesaturateFragment(int id, const EffectDesaturate::Data& data) : Part(id), mData(data), mColorLocation(0)
+    {
+    }
+
+    virtual std::string name() const override { return StringFormatter::sformat("desaturate_%d", mID); }
+    virtual std::string describe() const override { return StringFormatter::sformat("Desaturate(%.2f, %.2f, %.2f)", mData.red, mData.green, mData.blue); }
+
+    virtual std::string declarations() const override
+    {
+        return StringFormatter::sformat("uniform vec3 u_desaturateColor_%d;", mID);
+    }
+
+    virtual std::string body() const override
+    {
+        return StringFormatter::sformat("  {\n"
+                                        "    vec3 desWeights = vec3(0.3, 0.59, 0.11);\n"
+                                        "    vec3 desaturateColor = u_desaturateColor_%d;\n"
+                                        "    float desLuminance = dot(gl_FragColor.rgb, desWeights);\n"
+                                        "    float desR = clamp(desLuminance * desaturateColor.r + gl_FragColor.r * (1.0 - desaturateColor.r), 0.0, 1.0);\n"
+                                        "    float desG = clamp(desLuminance * desaturateColor.g + gl_FragColor.g * (1.0 - desaturateColor.g), 0.0, 1.0);\n"
+                                        "    float desB = clamp(desLuminance * desaturateColor.b + gl_FragColor.b * (1.0 - desaturateColor.b), 0.0, 1.0);\n"
+                                        "    gl_FragColor = vec4(desR, desG, desB, gl_FragColor.a);\n"
+                                        "  }\n", mID);
+    }
+
+    virtual void setup(const std::shared_ptr<OpenGLShader> &shader) override
+    {
+        char buf[64];
+        snprintf(buf, sizeof(buf), "u_desaturateColor_%d", mID);
+        mColorLocation = glGetUniformLocation(shader->program()->program(), buf);
+    }
+
+    virtual void bind(const std::shared_ptr<OpenGLShader> &/*shader*/) override
+    {
+        float c[] = { mData.red, mData.green, mData.blue };
+        glUniform3fv(mColorLocation, 1, c);
+    }
+
+private:
+    EffectDesaturate::Data mData;
+    GLuint mColorLocation;
+};
+
+void EffectDesaturateGLES2::collectParts(int id, OpenGLShader::Parts &verts, OpenGLShader::Parts &frags)
+{
+    verts.push_back(std::shared_ptr<DesaturateVertex>(new DesaturateVertex()));
+    frags.push_back(std::shared_ptr<DesaturateFragment>(new DesaturateFragment(id, mData)));
+}
+
+class TintVertex : public OpenGLShader::Part
+{
+public:
+    TintVertex() : Part(0)
+    {
+    }
+
+    virtual std::string declarations() const override { return std::string(); }
+    virtual std::string body() const override { return std::string(); }
+};
+
+class TintFragment : public OpenGLShader::Part
+{
+public:
+    TintFragment(int id, const EffectTint::Data& data) : Part(id), mData(data), mColorLocation(0)
+    {
+    }
+
+    virtual std::string name() const override { return StringFormatter::sformat("tint_%d", mID); }
+    virtual std::string describe() const override { return StringFormatter::sformat("Tint(%.2f, %.2f, %.2f)", mData.red, mData.green, mData.blue); }
+
+    virtual std::string declarations() const override
+    {
+        return StringFormatter::sformat("uniform vec3 u_tintColor_%d;", mID);
+    }
+
+    virtual std::string body() const override
+    {
+        return StringFormatter::sformat("  gl_FragColor = gl_FragColor * vec4(u_tintColor_%d, 1);\n", mID);
+    }
+
+    virtual void setup(const std::shared_ptr<OpenGLShader> &shader) override
+    {
+        char buf[64];
+        snprintf(buf, sizeof(buf), "u_tintColor_%d", mID);
+        mColorLocation = glGetUniformLocation(shader->program()->program(), buf);
+    }
+
+    virtual void bind(const std::shared_ptr<OpenGLShader> &/*shader*/) override
+    {
+        float c[] = { mData.red, mData.green, mData.blue };
+        glUniform3fv(mColorLocation, 1, c);
+    }
+
+private:
+    EffectTint::Data mData;
+    GLuint mColorLocation;
+};
+
+void EffectTintGLES2::collectParts(int id, OpenGLShader::Parts &verts, OpenGLShader::Parts &frags)
+{
+    verts.push_back(std::shared_ptr<TintVertex>(new TintVertex()));
+    frags.push_back(std::shared_ptr<TintFragment>(new TintFragment(id, mData)));
+}
+
+class ChromaKeyVertex : public OpenGLShader::Part
+{
+public:
+    ChromaKeyVertex() : Part(0) { }
+
+    virtual std::string declarations() const override { return std::string(); }
+    virtual std::string body() const override { return std::string(); }
+};
+
+class ChromaKeyFragment : public OpenGLShader::Part
+{
+public:
+    ChromaKeyFragment(int id, const EffectChromaKey::Data& data) : Part(id), mData(data), mNearLocation(0), mFarLocation(0), mKeyLocation(0)
+    {
+    }
+
+    virtual std::string name() const override { return StringFormatter::sformat("chromakey_%d", mID); }
+    virtual std::string describe() const override
+    {
+        return StringFormatter::sformat("ChromaKey(near: %d, far: %d, key: %s)",
+                                        mData.tolerance.tnear, mData.tolerance.tfar,
+                                        mData.key.toString().c_str());
+    }
+
+    virtual std::string declarations() const override
+    {
+        return StringFormatter::sformat("uniform float u_chr_tol_near_%d;\n"
+                                        "uniform float u_chr_tol_far_%d;\n"
+                                        "uniform vec3 u_chr_key_%d;\n", mID, mID, mID);
+    }
+
+    virtual std::string body() const override
+    {
+        return StringFormatter::sformat("  {\n"
+                                        "    float chrY = 0.2989 * gl_FragColor.r + 0.5866 * gl_FragColor.g + 0.1145 * gl_FragColor.b;\n"
+                                        "    float chrCr = 0.7132 * (gl_FragColor.r - chrY);\n"
+                                        "    float chrCb = 0.5647 * (gl_FragColor.b - chrY);\n"
+                                        "    if(chrY > 0.2) {\n"
+                                        "      vec3 chr_key = u_chr_key_%d;\n"
+                                        "      float chrKeyY = 0.2989 * chr_key.r + 0.5866 * chr_key.g + 0.1145 * chr_key.b;\n"
+                                        "      float chrKeyCr = 0.7132 * (chr_key.r - chrKeyY);\n"
+                                        "      float chrKeyCb = 0.5647 * (chr_key.b - chrKeyY);\n"
+                                        "      float chrResult = smoothstep(u_chr_tol_near_%d, u_chr_tol_near_%d+u_chr_tol_far_%d, distance(vec2(chrCr, chrCb), vec2(chrKeyCr, chrKeyCb)));\n"
+                                        "      gl_FragColor = vec4(gl_FragColor.rgb * chrResult, gl_FragColor.a * chrResult);\n"
+                                        "    }\n"
+                                        "  }\n", mID, mID, mID, mID);
+    }
+
+    virtual void setup(const std::shared_ptr<OpenGLShader> &shader) override
+    {
+        char buf[64];
+        OpenGLProgram::SharedPtr program = shader->program();
+        snprintf(buf, sizeof(buf), "u_chr_tol_near_%d", mID);
+        mNearLocation = glGetUniformLocation(program->program(), buf);
+        snprintf(buf, sizeof(buf), "u_chr_tol_far_%d", mID);
+        mFarLocation = glGetUniformLocation(program->program(), buf);
+        snprintf(buf, sizeof(buf), "u_chr_key_%d", mID);
+        mKeyLocation = glGetUniformLocation(program->program(), buf);
+    }
+
+    virtual void bind(const std::shared_ptr<OpenGLShader> &/*shader*/) override
+    {
+        float c[3];
+        mData.key.normalizedRGB(c);
+        glUniform3fv(mKeyLocation, 1, c);
+
+        glUniform1f(mFarLocation, float(mData.tolerance.tfar) / 255);
+        glUniform1f(mNearLocation, float(mData.tolerance.tnear) / 255);
+    }
+
+private:
+    EffectChromaKey::Data mData;
+    GLuint mNearLocation, mFarLocation, mKeyLocation;
+};
+
+void EffectChromaKeyGLES2::collectParts(int id, OpenGLShader::Parts &verts, OpenGLShader::Parts &frags)
+{
+    verts.push_back(std::shared_ptr<ChromaKeyVertex>(new ChromaKeyVertex()));
+    frags.push_back(std::shared_ptr<ChromaKeyFragment>(new ChromaKeyFragment(id, mData)));
+}
+
+EffectShaderGLES2::GLES2Renderer::~GLES2Renderer()
+{
+}
+
+static bool updateUniformLocation(const OpenGLProgram::SharedPtr &program, EffectShader::Data::Uniform &uniform)
+{
+    uniform.location = glGetUniformLocation(program->program(), uniform.name.c_str());
+    if(uniform.location == -1) {
+        Log::error(TRACE_LOG, "Unable to map uniform: %s", uniform.name.c_str());
+        return false;
+    } else if(uniform.type == EffectShader::Data::Uniform::Type_SURFACE) {
+        const std::string uv_name = uniform.name + "_uv";
+        uniform.Type_SURFACE_data.location = glGetUniformLocation(program->program(), uv_name.c_str());
+    }
+    return true;
+}
+
+EffectShaderGLES2::Renderer::SharedPtr EffectShaderGLES2::getDefaultRenderer()
+{
+    if(!mShader) {
+        const std::string name = "EffectShaderGLES2:" + OpenGLProgram::hash(mData.vertex.shader, mData.fragment.shader);
+        mShader.reset(new OpenGLShader(OpenGLContext::context(), mData.vertex.shader.c_str(), mData.fragment.shader.c_str(), name));
+        OpenGLProgram::SharedPtr program = mShader->program();
+        {
+            Variant data;
+            data["loaded"] = mShader->isValid();
+            if(!program->isValid())
+                data["error"] = program->error();
+            onEffectChanged(data);
+        }
+        if(mShader->isValid()) {
+            mShader->use();
+            for(std::vector<Data::Vertex::Buffer::SharedPtr>::const_iterator it = mData.vertex.buffers.begin(); it != mData.vertex.buffers.end(); ++it) {
+                for(size_t a = 0; a < (*it)->attributes.size(); ++a){
+                    Data::Vertex::Buffer::Attribute &attribute = (*it)->attributes[a];
+                    attribute.location = glGetAttribLocation(program->program(), attribute.name.c_str());
+                }
+            }
+            for(size_t u = 0; u < mData.vertex.uniforms.values.size(); ++u)
+                updateUniformLocation(program, mData.vertex.uniforms.values[u]);
+            for(size_t u = 0; u < mData.fragment.uniforms.values.size(); ++u)
+                updateUniformLocation(program, mData.fragment.uniforms.values[u]);
+        }
+    }
+    return Renderer::SharedPtr(new GLES2Renderer(mShader, mData));
+}
+
+static inline GLenum convertVertexDataType(EffectShader::Data::Vertex::Data::Type type)
+{
+    switch(type) {
+    case EffectShader::Data::Vertex::Data::Type_BYTE:
+    case EffectShader::Data::Vertex::Data::Type_2_BYTES:
+    case EffectShader::Data::Vertex::Data::Type_3_BYTES:
+    case EffectShader::Data::Vertex::Data::Type_4_BYTES:
+        return GL_BYTE;
+    case EffectShader::Data::Vertex::Data::Type_UNSIGNED_BYTE:
+        return GL_UNSIGNED_BYTE;
+    case EffectShader::Data::Vertex::Data::Type_SHORT:
+        return GL_SHORT;
+    case EffectShader::Data::Vertex::Data::Type_UNSIGNED_SHORT:
+        return GL_UNSIGNED_SHORT;
+    case EffectShader::Data::Vertex::Data::Type_INT:
+        return GL_INT;
+    case EffectShader::Data::Vertex::Data::Type_UNSIGNED_INT:
+        return GL_UNSIGNED_INT;
+    case EffectShader::Data::Vertex::Data::Type_FLOAT:
+        return GL_FLOAT;
+    case EffectShader::Data::Vertex::Data::Type_DOUBLE:
+#ifdef GL_DOUBLE
+        return GL_DOUBLE;
+#else
+        assert(false);
+        break;
+#endif
+    }
+    return GL_BYTE;
+}
+
+static inline GLenum convertDrawType(EffectShader::Data::DrawType type)
+{
+    switch(type) {
+    case EffectShader::Data::DrawType_POINTS:
+        return GL_POINTS;
+    case EffectShader::Data::DrawType_LINES:
+        return GL_LINES;
+    case EffectShader::Data::DrawType_LINE_LOOP:
+        return GL_LINE_LOOP;
+    case EffectShader::Data::DrawType_LINE_STRIP:
+        return GL_LINE_STRIP;
+    case EffectShader::Data::DrawType_TRIANGLES:
+        return GL_TRIANGLES;
+    case EffectShader::Data::DrawType_TRIANGLE_STRIP:
+        return GL_TRIANGLE_STRIP;
+    case EffectShader::Data::DrawType_TRIANGLE_FAN:
+        return GL_TRIANGLE_FAN;
+    case EffectShader::Data::DrawType_QUADS:
+#ifdef GL_QUADS
+        return GL_QUADS;
+#else
+        assert(false);
+        break;
+#endif
+    case EffectShader::Data::DrawType_QUAD_STRIP:
+#ifdef GL_QUAD_STRIP
+        return GL_QUAD_STRIP;
+#else
+        assert(false);
+        break;
+#endif
+    case EffectShader::Data::DrawType_POLYGON:
+#ifdef GL_POLYGON
+        return GL_POLYGON;
+#else
+        assert(false);
+        break;
+#endif
+    }
+    return GL_TRIANGLES;
+}
+
+static inline GLenum convertBlendEquation(EffectShader::Data::Blend::Equation equation)
+{
+    if(equation == EffectShader::Data::Blend::Equation_SUBTRACT)
+        return GL_FUNC_SUBTRACT;
+    if(equation == EffectShader::Data::Blend::Equation_REVERSE_SUBTRACT)
+        return GL_FUNC_REVERSE_SUBTRACT;
+
+    // Desktop OpenGL and GLES3 have GL_MIN/MAX defined, but on GLES2 they're extensions
+#ifdef GL_MIN
+    if(equation == EffectShader::Data::Blend::Equation_MIN)
+        return GL_MIN;
+#elif GL_MIN_EXT
+    if(equation == EffectShader::Data::Blend::Equation_MIN)
+        return GL_MIN_EXT;
+#endif
+
+#ifdef GL_MAX
+    if(equation == EffectShader::Data::Blend::Equation_MAX)
+        return GL_MAX;
+#elif GL_MAX_EXT
+    if(equation == EffectShader::Data::Blend::Equation_MAX)
+        return GL_MAX_EXT;
+#endif
+
+    return GL_FUNC_ADD;
+}
+
+static inline GLuint convertFilter(EffectShader::Data::Uniform::SurfaceData::Filter filter)
+{
+    if(filter == EffectShader::Data::Uniform::SurfaceData::Filter_LINEAR)
+        return GL_LINEAR;
+    return GL_NEAREST;
+}
+
+static inline GLuint convertWrap(EffectShader::Data::Uniform::SurfaceData::Wrap wrap)
+{
+    if(wrap == EffectShader::Data::Uniform::SurfaceData::Wrap_REPEAT)
+        return GL_REPEAT;
+    if(wrap == EffectShader::Data::Uniform::SurfaceData::Wrap_MIRRORED_REPEAT)
+        return GL_MIRRORED_REPEAT;
+    return GL_CLAMP_TO_EDGE;
+}
+
+static inline GLenum convertBlendFunction(EffectShader::Data::Blend::Function function)
+{
+    if(function == EffectShader::Data::Blend::Function_ZERO)
+        return GL_ZERO;
+    if(function == EffectShader::Data::Blend::Function_ONE)
+        return GL_ONE;
+    if(function == EffectShader::Data::Blend::Function_SRC_COLOR)
+        return GL_SRC_COLOR;
+    if(function == EffectShader::Data::Blend::Function_ONE_MINUS_SRC_COLOR)
+        return GL_ONE_MINUS_SRC_COLOR;
+    if(function == EffectShader::Data::Blend::Function_SRC_ALPHA)
+        return GL_SRC_ALPHA;
+    if(function == EffectShader::Data::Blend::Function_ONE_MINUS_SRC_ALPHA)
+        return GL_ONE_MINUS_SRC_ALPHA;
+    if(function == EffectShader::Data::Blend::Function_DST_ALPHA)
+        return GL_DST_ALPHA;
+    if(function == EffectShader::Data::Blend::Function_ONE_MINUS_DST_ALPHA)
+        return GL_ONE_MINUS_DST_ALPHA;
+    if(function == EffectShader::Data::Blend::Function_DST_COLOR)
+        return GL_DST_COLOR;
+    if(function == EffectShader::Data::Blend::Function_ONE_MINUS_DST_COLOR)
+        return GL_ONE_MINUS_DST_COLOR;
+    if(function == EffectShader::Data::Blend::Function_CONSTANT_COLOR)
+        return GL_CONSTANT_COLOR;
+    if(function == EffectShader::Data::Blend::Function_ONE_MINUS_CONSTANT_COLOR)
+        return GL_ONE_MINUS_CONSTANT_COLOR;
+    if(function == EffectShader::Data::Blend::Function_CONSTANT_ALPHA)
+        return GL_CONSTANT_ALPHA;
+    if(function == EffectShader::Data::Blend::Function_ONE_MINUS_CONSTANT_ALPHA)
+        return GL_ONE_MINUS_CONSTANT_ALPHA;
+    if(function == EffectShader::Data::Blend::Function_SRC_ALPHA_SATURATE)
+        return GL_SRC_ALPHA_SATURATE;
+    return GL_ZERO;
+}
+
+DisplayList::SharedPtr EffectShaderGLES2::GLES2Renderer::render(const DisplayList::SharedPtr &dl, const Rect &area, Flags<RenderFlag>) const
+{
+    const Rect resultRect = getRect(area);
+    if(!Surface::isValidRect(resultRect) || !mShader->isValid())
+        return DisplayList::SharedPtr();
+
+    DisplayList::SharedPtr ret(new DisplayList(resultRect.size()));
+    ret->appendCommand(new ShaderEffectGLES2Command(mShader, dl, area, resultRect, mData));
+    return ret;
+}
+
+static int sBoundTextures[] = { GL_TEXTURE0, GL_TEXTURE1, GL_TEXTURE2, GL_TEXTURE3, GL_TEXTURE4,
+                                GL_TEXTURE5, GL_TEXTURE6, GL_TEXTURE7, GL_TEXTURE8, GL_TEXTURE9,
+                                GL_TEXTURE10, GL_TEXTURE11, GL_TEXTURE12, GL_TEXTURE13, GL_TEXTURE14,
+                                GL_TEXTURE15, GL_TEXTURE16, GL_TEXTURE17, GL_TEXTURE18, GL_TEXTURE19,
+                                GL_TEXTURE20, GL_TEXTURE21, GL_TEXTURE22, GL_TEXTURE23, GL_TEXTURE24,
+                                GL_TEXTURE25, GL_TEXTURE26, GL_TEXTURE27, GL_TEXTURE28, GL_TEXTURE29,
+                                GL_TEXTURE30, GL_TEXTURE31 };
+
+void ShaderEffectGLES2Command::applyUniform(OpenGLState *glState, const EffectShader::Data::Uniform &uniform,
+                                            GraphicsEngine *graphics, State *state, const Surface::SharedPtr &content, unsigned int &boundTexture) const
+{
+    GL_ASSERT(glState);
+    //Log::error(TRACE_LOG, "%f: ApplyUniform(%d): %s: %s %d", Stopwatch::mono(), uniform.type, uniform.name.c_str(), uniform.data.toJSON().c_str(), uniform.location);
+    if(uniform.location == -1)
+        return;
+    switch(uniform.type) {
+    case EffectShader::Data::Uniform::Type_SURFACE: {
+        Surface::SharedPtr surface;
+        if(uniform.Type_SURFACE_data.source)
+            surface = uniform.Type_SURFACE_data.source->getSurface(false);
+        if(!surface && uniform.Type_SURFACE_data.widget)
+            surface = content;
+        if(surface) {
+            assert(boundTexture < sizeof(sBoundTextures) / sizeof(sBoundTextures[0]));
+            glState->activeTexture(sBoundTextures[boundTexture]);
+            glState->bindTexture(surface->getTexture());
+            glState->setFilter(convertFilter(uniform.Type_SURFACE_data.filterMin), convertFilter(uniform.Type_SURFACE_data.filterMag));
+            glState->setWrap(convertWrap(uniform.Type_SURFACE_data.wrapHorizontal), convertWrap(uniform.Type_SURFACE_data.wrapVertical));
+            glState->activeTexture(GL_TEXTURE0);
+            glUniform1i(uniform.location, boundTexture++);
+            if(uniform.Type_SURFACE_data.location != -1) {
+                const Size size = uniform.Type_SURFACE_data.source->getSize();
+                glUniform2f(uniform.Type_SURFACE_data.location, size.width / surface->getWidth(), size.height / surface->getHeight());
+            }
+        } else if(uniform.Type_SURFACE_data.location != -1) {
+            glUniform2f(uniform.Type_SURFACE_data.location, 0.0f, 0.0f);
+        }
+        break; }
+    case EffectShader::Data::Uniform::Type_OPACITY: {
+        glUniform1f(uniform.location, state->opacity);
+        break; }
+    case EffectShader::Data::Uniform::Type_DESTINATION: {
+        const Rect dstRect = state->map(mResultRect);
+        glUniform4f(uniform.location, dstRect.x, dstRect.y, dstRect.width, dstRect.height);
+        break; }
+    case EffectShader::Data::Uniform::Type_MODELVIEW: {
+        const Rect &targetRect = graphics->targetRect();
+        Rect dstRect = state->map(mResultRect);
+        dstRect.y = targetRect.height - dstRect.y - dstRect.height;
+
+        Transform modelView = graphics->transform();
+        modelView.translateNormalized(gibbon_coordinate_map(dstRect.x, targetRect.width, 0, 2),
+                                      gibbon_coordinate_map(dstRect.y, targetRect.height, 0, 2));
+        modelView.translateNormalized(-1, -1);
+        modelView.scale(gibbon_coordinate_map(dstRect.width,  targetRect.width, 0, 1),
+                        gibbon_coordinate_map(dstRect.height, targetRect.height, 0, 1));
+        modelView.translateNormalized(1, 1);
+        glUniformMatrix4fv(uniform.location, 1, GL_FALSE, modelView.matrix());
+        break; }
+    case EffectShader::Data::Uniform::Type_PROJECTION: {
+        Transform projectionMatrix;
+        if(uniform.data.isArray() && uniform.data.size() == 16) {
+            int i = 0;
+            for(int x = 0; x < 4; ++x) {
+                for(int y = 0; y < 4; ++y)
+                    projectionMatrix.setMatrix(x, y, uniform.data.at(i++).dbl());
+            }
+        }
+        if(!graphics->isScreen())
+            projectionMatrix.scale(1, -1);
+        glUniformMatrix4fv(uniform.location, 1, GL_FALSE, projectionMatrix.matrix());
+        break; }
+    case EffectShader::Data::Uniform::Type_TIME:
+    case EffectShader::Data::Uniform::Type_RANDOM:
+    case EffectShader::Data::Uniform::Type_NOW:
+        glUniform1f(uniform.location, uniform.value<GLfloat>());
+        break;
+    case EffectShader::Data::Uniform::Type_1_FLOAT: {
+        const DataBuffer db = EffectShader::Data::toDataBuffer<GLfloat>(uniform.data);
+        assert(uniform.count == (db.size() / (sizeof(GLfloat)*1)));
+        glUniform1fv(uniform.location, uniform.count, (const GLfloat*)db.constData());
+        break; }
+    case EffectShader::Data::Uniform::Type_2_FLOAT: {
+        const DataBuffer db = EffectShader::Data::toDataBuffer<GLfloat>(uniform.data);
+        assert(uniform.count == (db.size() / (sizeof(GLfloat)*2)));
+        glUniform2fv(uniform.location, uniform.count, (const GLfloat*)db.constData());
+        break; }
+    case EffectShader::Data::Uniform::Type_3_FLOAT: {
+        const DataBuffer db = EffectShader::Data::toDataBuffer<GLfloat>(uniform.data);
+        assert(uniform.count == (db.size() / (sizeof(GLfloat)*3)));
+        glUniform3fv(uniform.location, uniform.count, (const GLfloat*)db.constData());
+        break; }
+    case EffectShader::Data::Uniform::Type_4_FLOAT: {
+        const DataBuffer db = EffectShader::Data::toDataBuffer<GLfloat>(uniform.data);
+        assert(uniform.count == (db.size() / (sizeof(GLfloat)*4)));
+        glUniform4fv(uniform.location, uniform.count, (const GLfloat*)db.constData());
+        break; }
+    case EffectShader::Data::Uniform::Type_1_INT: {
+        const DataBuffer db = EffectShader::Data::toDataBuffer<GLint>(uniform.data);
+        assert(uniform.count == (db.size() / (sizeof(GLint)*1)));
+        glUniform1iv(uniform.location, uniform.count, (const GLint*)db.constData());
+        break; }
+    case EffectShader::Data::Uniform::Type_2_INT: {
+        const DataBuffer db = EffectShader::Data::toDataBuffer<GLint>(uniform.data);
+        assert(uniform.count == (db.size() / (sizeof(GLint)*2)));
+        glUniform2iv(uniform.location, uniform.count, (const GLint*)db.constData());
+        break; }
+    case EffectShader::Data::Uniform::Type_3_INT: {
+        const DataBuffer db = EffectShader::Data::toDataBuffer<GLint>(uniform.data);
+        assert(uniform.count == (db.size() / (sizeof(GLint)*3)));
+        glUniform3iv(uniform.location, uniform.count, (const GLint*)db.constData());
+        break; }
+    case EffectShader::Data::Uniform::Type_4_INT: {
+        const DataBuffer db = EffectShader::Data::toDataBuffer<GLint>(uniform.data);
+        assert(uniform.count == (db.size() / (sizeof(GLint)*4)));
+        glUniform4iv(uniform.location, uniform.count, (const GLint*)db.constData());
+        break; }
+    case EffectShader::Data::Uniform::Type_2x2_MATRIX: {
+        const DataBuffer db = EffectShader::Data::toDataBuffer<GLfloat>(uniform.data);
+        assert(uniform.count == (db.length() / (sizeof(GLfloat)*4)));
+        glUniformMatrix2fv(uniform.location, uniform.count, false, (const GLfloat*)db.constData());
+        break; }
+    case EffectShader::Data::Uniform::Type_3x3_MATRIX: {
+        const DataBuffer db = EffectShader::Data::toDataBuffer<GLfloat>(uniform.data);
+        assert(uniform.count == (db.length() / (sizeof(GLfloat)*9)));
+        glUniformMatrix3fv(uniform.location, uniform.count, false, (const GLfloat*)db.constData());
+        break; }
+    case EffectShader::Data::Uniform::Type_4x4_MATRIX: {
+        const DataBuffer db = EffectShader::Data::toDataBuffer<GLfloat>(uniform.data);
+        assert(uniform.count == (db.length() / (sizeof(GLfloat)*16)));
+        glUniformMatrix4fv(uniform.location, uniform.count, false, (const GLfloat*)db.constData());
+        break; }
+    }
+    GL_ASSERT(glState);
+}
+
+void ShaderEffectGLES2Command::prerender()
+{
+    updateTextures(GraphicsEngine::Flag_DisplayListRender);
+}
+
+void ShaderEffectGLES2Command::updateTextures(Flags<GraphicsEngine::Flag> flags) const
+{
+    mTexturesUpdate = TexturesUpdate_Ready;
+    for(EffectShader::Data::Uniforms::Values::const_iterator it = mData.vertex.uniforms.values.begin(); it != mData.vertex.uniforms.values.end(); ++it) {
+        const EffectShader::Data::Uniform &uniform = *it;
+        if(uniform.type == EffectShader::Data::Uniform::Type_SURFACE && uniform.location != -1) {
+            if(uniform.Type_SURFACE_data.source) {
+                if(Surface::SharedPtr surface = uniform.Type_SURFACE_data.source->getSurface(true)) {
+                    surface->prerender();
+                } else {
+                    mTexturesUpdate = TexturesUpdate_Error;
+                    Log::warn(WARN_EFFECT_SHADER_MISSING_TEXTURE, "Vertex Uniform(%s@%d) texture not ready to be bound", uniform.name.c_str(), uniform.index);
+                }
+            }
+        }
+    }
+    for(EffectShader::Data::Uniforms::Values::const_iterator it = mData.fragment.uniforms.values.begin(); it != mData.fragment.uniforms.values.end(); ++it) {
+        const EffectShader::Data::Uniform &uniform = *it;
+        if(uniform.type == EffectShader::Data::Uniform::Type_SURFACE && uniform.location != -1) {
+            if(uniform.Type_SURFACE_data.source) {
+                if(Surface::SharedPtr surface = uniform.Type_SURFACE_data.source->getSurface(true)) {
+                    surface->prerender();
+                } else if(uniform.Type_SURFACE_data.widget) {
+                    mTexturesUpdate = TexturesUpdate_ReadyNoContent;
+                } else {
+                    mTexturesUpdate = TexturesUpdate_Error;
+                    Log::warn(WARN_EFFECT_SHADER_MISSING_TEXTURE, "Fragment Uniform(%s@%d) texture not ready to be bound", uniform.name.c_str(), uniform.index);
+                }
+            }
+        }
+    }
+
+    mContent.reset();
+    if(mDisplayList->hasRenderCommands()) {
+        const Rect &dlRect = mDisplayList->getRect();
+        if(mDisplayList->getWidth() == dlRect.width && mDisplayList->getHeight() == dlRect.height) {
+            mContent = mDisplayList->flatten();
+        } else {
+            const Surface::SharedPtr flattened = mDisplayList->flatten();
+            mContent = Effect::requestSurface(mResultRect.width, mResultRect.height, true);
+            mContent->setDescription(describe() + ":source");
+
+            GraphicsEngine engine(mContent, GraphicsEngine::ColorBuffer, flags);
+            engine.clear(Rect(0, 0, mResultRect.width, mResultRect.height));
+            const Coordinate x = (mResultRect.width - dlRect.width) / 2;
+            const Coordinate y = (mResultRect.height - dlRect.height) / 2;
+            engine.blit(flattened, dlRect, Rect(x, y, dlRect.size()));
+        }
+    }
+}
+
+void ShaderEffectGLES2Command::execute(GraphicsEngine *graphics, State *state) const
+{
+    const GraphicsEngine::State gfxState = graphics->getState();
+    if(mTexturesUpdate == TexturesUpdate_Pending)
+        updateTextures(graphics->transferFlags());
+    if(mTexturesUpdate == TexturesUpdate_Error)
+        return;
+
+    const Rect dstRect = state->map(mResultRect);
+    {
+        Rect clip = dstRect;
+        if(graphics->hasTransform()) {
+            const Transform modelViewMatrix = graphics->transform();
+            clip = modelViewMatrix.map(clip, graphics->getRect());
+        }
+        if(graphics->hasClip())
+            clip.intersect(graphics->clip());
+        graphics->updateClip(clip);
+    }
+    if(mTexturesUpdate != TexturesUpdate_ReadyNoContent && mContent)
+        graphics->blit(mContent, mContent->getRect(), dstRect);
+    mTexturesUpdate = TexturesUpdate_Pending; //need to go again
+
+    OpenGLShader::Scope scope(mShader);
+    OpenGLContext *context = OpenGLContext::context();
+    OpenGLProgram::SharedPtr program = mShader->program();
+
+    const GLenum drawType = convertDrawType(mData.draw);
+    {
+        OpenGLState *glState = context->state();
+        OpenGLState::Scope stateScope(glState);
+        if(mData.flags & EffectShader::Data::Flag_CheckState)
+            stateScope.setGLCheck(true);
+        GL_ASSERT(glState);
+
+        stateScope.setDestFormat(graphics->getSurface()->getFormat());
+        if(mContent)
+            stateScope.setSourceFormat(mContent->getFormat());
+        else
+            stateScope.setSourceFormat(gibbonApp()->getScreen()->getSurfaceFormat(Screen::SurfaceFormat_Alpha));
+        GL_ASSERT(glState);
+
+        if(!GibbonDebug::TestGraphicsNoClip)
+            stateScope.enableScissor(true);
+
+        stateScope.enableCap(GL_BLEND, graphics->getCompositionMode() != GraphicsEngine::CompositionMode_Source);
+        for(std::map<GLenum, bool>::const_iterator it = mData.capabilities.begin(); it != mData.capabilities.end(); ++it) {
+            const GLenum cap = it->first;
+            const bool enabled = it->second;
+            stateScope.enableCap(cap, enabled);
+            GL_ASSERT(glState);
+        }
+
+        if(!fuzzy_is_zero(mData.lineWidth))
+            glLineWidth(mData.lineWidth);
+
+        GL_ASSERT(glState);
+        EffectShader::Data::Vertex::Buffer::SharedPtr vertexBuffer;
+        for(std::vector<EffectShader::Data::Vertex::Buffer::SharedPtr>::const_iterator it = mData.vertex.buffers.begin(); it != mData.vertex.buffers.end(); ++it) {
+            vertexBuffer = (*it);
+            if(!vertexBuffer->gl) {
+                vertexBuffer->gl.reset(new OpenGLVBO(context));
+                glState->bindBuffer(GL_ARRAY_BUFFER, vertexBuffer->gl->vbo());
+                glBufferData(GL_ARRAY_BUFFER, vertexBuffer->value.size(), vertexBuffer->value.constData(), GL_STATIC_DRAW);
+            } else {
+                glState->bindBuffer(GL_ARRAY_BUFFER, vertexBuffer->gl->vbo());
+            }
+            for(size_t a = 0; a < vertexBuffer->attributes.size(); ++a) {
+                GL_ASSERT(glState);
+                const EffectShader::Data::Vertex::Buffer::Attribute &attribute = vertexBuffer->attributes[a];
+                //Log::error(TRACE_LOG, "%f: ApplyAttribute: %s [%d] %d::%d/%d", Stopwatch::mono(), attribute.name.c_str(), attribute.location, attribute.offset, attribute.count, attribute.stride);
+                if(attribute.location == -1)
+                    continue;
+                glState->enableVAA(attribute.location);
+                glVertexAttribPointer(attribute.location, attribute.count, convertVertexDataType(attribute.type), GL_FALSE,
+                                      attribute.stride, reinterpret_cast<GLvoid*>(static_cast<uintptr_t>(attribute.offset)));
+                GL_ASSERT(glState);
+            }
+        }
+
+        GL_ASSERT(glState);
+        unsigned int boundTexture = 0;
+        for(EffectShader::Data::Uniforms::Values::const_iterator it = mData.vertex.uniforms.values.begin(); it != mData.vertex.uniforms.values.end(); ++it)
+            applyUniform(glState, *it, graphics, state, mContent, boundTexture);
+        for(EffectShader::Data::Uniforms::Values::const_iterator it = mData.fragment.uniforms.values.begin(); it != mData.fragment.uniforms.values.end(); ++it)
+            applyUniform(glState, *it, graphics, state, mContent, boundTexture);
+
+        glState->blendFunc(convertBlendFunction(mData.blend.source_function_rgb), convertBlendFunction(mData.blend.dest_function_rgb),
+                           convertBlendFunction(mData.blend.source_function_alpha), convertBlendFunction(mData.blend.dest_function_alpha));
+        GL_ASSERT(glState);
+
+        glState->blendEquation(convertBlendEquation(mData.blend.equation_rgb), convertBlendEquation(mData.blend.equation_alpha));
+        GL_ASSERT(glState);
+
+        glState->blendColor(mData.blend.color);
+        GL_ASSERT(glState);
+
+        {
+            const GLenum cull = mData.face.cull == EffectShader::Data::Face::Cull_Front ? GL_FRONT : GL_BACK;
+            GLenum front = mData.face.front == EffectShader::Data::Face::Front_Clockwise ? GL_CW : GL_CCW;
+            if(!graphics->isScreen())
+                front = (front == GL_CW ? GL_CCW : GL_CW);
+            glState->face(cull, front);
+            GL_ASSERT(glState);
+        }
+
+        stateScope.flush();
+        GL_ASSERT(glState);
+
+        //bind buffer and draw
+        if(vertexBuffer) {
+            if(mData.vertex.indices) {
+                if(!mData.vertex.indices->gl) {
+                    mData.vertex.indices->gl.reset(new OpenGLVBO(context));
+                    glState->bindBuffer(GL_ELEMENT_ARRAY_BUFFER, mData.vertex.indices->gl->vbo());
+                    glBufferData(GL_ELEMENT_ARRAY_BUFFER, mData.vertex.indices->size, mData.vertex.indices->value.constData(), GL_STATIC_DRAW);
+                } else {
+                    glState->bindBuffer(GL_ELEMENT_ARRAY_BUFFER, mData.vertex.indices->gl->vbo());
+                }
+                glDrawElements(drawType, mData.vertex.indices->indicesCount, convertVertexDataType(mData.vertex.indices->indicesType), 0);
+            } else {
+                glDrawArrays(drawType, vertexBuffer->offset, vertexBuffer->size);
+            }
+        } else {
+            const GLubyte indices[6] = {0, 1, 2, 0, 2, 3};
+            glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
+            glDrawElements(drawType, 6, GL_UNSIGNED_BYTE, 0);
+        }
+        GL_ASSERT(glState);
+
+        //cleanup
+        if(boundTexture) {
+            for(unsigned int i = 0; i < boundTexture; ++i) {
+                glState->activeTexture(sBoundTextures[i]);
+                glState->bindTexture(0);
+            }
+            glState->activeTexture(GL_TEXTURE0);
+            GL_ASSERT(glState);
+        }
+    }
+    graphics->setState(gfxState, true);
+    mContent.reset();
+}
+
+Variant EffectShaderGLES2::getParams(bool all) const
+{
+    Variant result = EffectShader::getParams(all);
+    if(!all && mShader)
+        result["shader"] = mShader->describe();
+    return result;
+}
+
+bool EffectShaderGLES2::setParams(const Variant &params)
+{
+    if(params.contains("fragment") || params.contains("vertex"))
+        mShader.reset();
+    if(params.contains("capabilities")) {
+        const Variant &capabilities = params["capabilities"];
+        for(Variant::StringMapIterator it = capabilities.stringMapBegin(); it != capabilities.stringMapEnd(); ++it) {
+            const std::string capability = it->first;
+            const char *name = capability.c_str();
+            std::string gl_capability = capability.substr(0, 3) == "GL_" ? capability : "GL_" + capability;
+            char *endptr;
+            const llong integer = strtoll(name, &endptr, 0);
+            if(!*endptr) {
+                mData.capabilities[integer] = it->second.value<bool>();
+#define GL_CAP(c) } else if(gl_capability == #c) { mData.capabilities[c] = it->second.value<bool>(); onEffectChanged();
+#           ifdef GL_ALPHA_TEST
+                GL_CAP(GL_ALPHA_TEST);
+#           endif
+#           ifdef GL_AUTO_NORMAL
+                GL_CAP(GL_AUTO_NORMAL);
+#           endif
+#           ifdef GL_BLEND
+                GL_CAP(GL_BLEND);
+#           endif
+#           ifdef GL_CLIP_PLANE0
+                GL_CAP(GL_CLIP_PLANE0);
+#           endif
+#           ifdef GL_CLIP_PLANE1
+                GL_CAP(GL_CLIP_PLANE1);
+#           endif
+#           ifdef GL_CLIP_PLANE2
+                GL_CAP(GL_CLIP_PLANE2);
+#           endif
+#           ifdef GL_CLIP_PLANE3
+                GL_CAP(GL_CLIP_PLANE3);
+#           endif
+#           ifdef GL_CLIP_PLANE4
+                GL_CAP(GL_CLIP_PLANE4);
+#           endif
+#           ifdef GL_CLIP_PLANE5
+                GL_CAP(GL_CLIP_PLANE5);
+#           endif
+#           ifdef GL_COLOR_ARRAY
+                GL_CAP(GL_COLOR_ARRAY);
+#           endif
+#           ifdef GL_COLOR_LOGIC_OP
+                GL_CAP(GL_COLOR_LOGIC_OP);
+#           endif
+#           ifdef GL_COLOR_MATERIAL
+                GL_CAP(GL_COLOR_MATERIAL);
+#           endif
+#           ifdef GL_CULL_FACE
+                GL_CAP(GL_CULL_FACE);
+#           endif
+#           ifdef GL_DEPTH_TEST
+                GL_CAP(GL_DEPTH_TEST);
+#           endif
+#           ifdef GL_DITHER
+                GL_CAP(GL_DITHER);
+#           endif
+#           ifdef GL_EDGE_FLAG_ARRAY
+                GL_CAP(GL_EDGE_FLAG_ARRAY);
+#           endif
+#           ifdef GL_FOG
+                GL_CAP(GL_FOG);
+#           endif
+#           ifdef GL_INDEX_ARRAY
+                GL_CAP(GL_INDEX_ARRAY);
+#           endif
+#           ifdef GL_INDEX_LOGIC_OP
+                GL_CAP(GL_INDEX_LOGIC_OP);
+#           endif
+#           ifdef GL_LIGHT0
+                GL_CAP(GL_LIGHT0);
+#           endif
+#           ifdef GL_LIGHT1
+                GL_CAP(GL_LIGHT1);
+#           endif
+#           ifdef GL_LIGHT2
+                GL_CAP(GL_LIGHT2);
+#           endif
+#           ifdef GL_LIGHT3
+                GL_CAP(GL_LIGHT3);
+#           endif
+#           ifdef GL_LIGHT4
+                GL_CAP(GL_LIGHT4);
+#           endif
+#           ifdef GL_LIGHT5
+                GL_CAP(GL_LIGHT5);
+#           endif
+#           ifdef GL_LIGHT6
+                GL_CAP(GL_LIGHT6);
+#           endif
+#           ifdef GL_LIGHT7
+                GL_CAP(GL_LIGHT7);
+#           endif
+#           ifdef GL_LIGHTING
+                GL_CAP(GL_LIGHTING);
+#           endif
+#           ifdef GL_LINE_SMOOTH
+                GL_CAP(GL_LINE_SMOOTH);
+#           endif
+#           ifdef GL_LINE_STIPPLE
+                GL_CAP(GL_LINE_STIPPLE);
+#           endif
+#           ifdef GL_MAP1_COLOR_4
+                GL_CAP(GL_MAP1_COLOR_4);
+#           endif
+#           ifdef GL_MAP1_INDEX
+                GL_CAP(GL_MAP1_INDEX);
+#           endif
+#           ifdef GL_MAP1_NORMAL
+                GL_CAP(GL_MAP1_NORMAL);
+#           endif
+#           ifdef GL_MAP1_TEXTURE_COORD_1
+                GL_CAP(GL_MAP1_TEXTURE_COORD_1);
+#           endif
+#           ifdef GL_MAP1_TEXTURE_COORD_2
+                GL_CAP(GL_MAP1_TEXTURE_COORD_2);
+#           endif
+#           ifdef GL_MAP1_TEXTURE_COORD_3
+                GL_CAP(GL_MAP1_TEXTURE_COORD_3);
+#           endif
+#           ifdef GL_MAP1_TEXTURE_COORD_4
+                GL_CAP(GL_MAP1_TEXTURE_COORD_4);
+#           endif
+#           ifdef GL_MAP1_VERTEX_3
+                GL_CAP(GL_MAP1_VERTEX_3);
+#           endif
+#           ifdef GL_MAP1_VERTEX_4
+                GL_CAP(GL_MAP1_VERTEX_4);
+#           endif
+#           ifdef GL_MAP2_COLOR_4
+                GL_CAP(GL_MAP2_COLOR_4);
+#           endif
+#           ifdef GL_MAP2_INDEX
+                GL_CAP(GL_MAP2_INDEX);
+#           endif
+#           ifdef GL_MAP2_NORMAL
+                GL_CAP(GL_MAP2_NORMAL);
+#           endif
+#           ifdef GL_MAP2_TEXTURE_COORD_1
+                GL_CAP(GL_MAP2_TEXTURE_COORD_1);
+#           endif
+#           ifdef GL_MAP2_TEXTURE_COORD_2
+                GL_CAP(GL_MAP2_TEXTURE_COORD_2);
+#           endif
+#           ifdef GL_MAP2_TEXTURE_COORD_3
+                GL_CAP(GL_MAP2_TEXTURE_COORD_3);
+#           endif
+#           ifdef GL_MAP2_TEXTURE_COORD_4
+                GL_CAP(GL_MAP2_TEXTURE_COORD_4);
+#           endif
+#           ifdef GL_MAP2_VERTEX_3
+                GL_CAP(GL_MAP2_VERTEX_3);
+#           endif
+#           ifdef GL_MAP2_VERTEX_4
+                GL_CAP(GL_MAP2_VERTEX_4);
+#           endif
+#           ifdef GL_NORMALIZE
+                GL_CAP(GL_NORMALIZE);
+#           endif
+#           ifdef GL_NORMAL_ARRAY
+                GL_CAP(GL_NORMAL_ARRAY);
+#           endif
+#           ifdef GL_POINT_SMOOTH
+                GL_CAP(GL_POINT_SMOOTH);
+#           endif
+#           ifdef GL_POLYGON_OFFSET_FILL
+                GL_CAP(GL_POLYGON_OFFSET_FILL);
+#           endif
+#           ifdef GL_POLYGON_OFFSET_LINE
+                GL_CAP(GL_POLYGON_OFFSET_LINE);
+#           endif
+#           ifdef GL_POLYGON_OFFSET_POINT
+                GL_CAP(GL_POLYGON_OFFSET_POINT);
+#           endif
+#           ifdef GL_POLYGON_SMOOTH
+                GL_CAP(GL_POLYGON_SMOOTH);
+#           endif
+#           ifdef GL_POLYGON_STIPPLE
+                GL_CAP(GL_POLYGON_STIPPLE);
+#           endif
+#           ifdef GL_SCISSOR_TEST
+                GL_CAP(GL_SCISSOR_TEST);
+#           endif
+#           ifdef GL_STENCIL_TEST
+                GL_CAP(GL_STENCIL_TEST);
+#           endif
+#           ifdef GL_TEXTURE_1D
+                GL_CAP(GL_TEXTURE_1D);
+#           endif
+#           ifdef GL_TEXTURE_2D
+                GL_CAP(GL_TEXTURE_2D);
+#           endif
+#           ifdef GL_TEXTURE_COORD_ARRAY
+                GL_CAP(GL_TEXTURE_COORD_ARRAY);
+#           endif
+#           ifdef GL_TEXTURE_GEN_Q
+                GL_CAP(GL_TEXTURE_GEN_Q);
+#           endif
+#           ifdef GL_TEXTURE_GEN_R
+                GL_CAP(GL_TEXTURE_GEN_R);
+#           endif
+#           ifdef GL_TEXTURE_GEN_S
+                GL_CAP(GL_TEXTURE_GEN_S);
+#           endif
+#           ifdef GL_TEXTURE_GEN_T
+                GL_CAP(GL_TEXTURE_GEN_T);
+#           endif
+#           ifdef GL_VERTEX_ARRAY
+                GL_CAP(GL_VERTEX_ARRAY);
+#           endif
+#           ifdef GL_POINT_SPRITE
+                GL_CAP(GL_POINT_SPRITE);
+#           endif
+#           ifdef GL_VERTEX_PROGRAM_POINT_SIZE
+                GL_CAP(GL_VERTEX_PROGRAM_POINT_SIZE);
+#           endif
+#undef GL_CAP
+            } else {
+    Log::error(TRACE_LOG, "Unable to map capability: %s", capability.c_str());
+}
+        }
+    }
+    return EffectShader::setParams(params);
+}
+
+OpenGLShaderManagerRenderer::OpenGLShaderManagerRenderer(const OpenGLShader::Parts &vertex, const OpenGLShader::Parts &fragment)
+{
+    mShader.reset(new TextureShader(OpenGLContext::context(), vertex, fragment, "OpenGLShaderManager"));
+}
+
+DisplayList::SharedPtr OpenGLShaderManagerRenderer::render(const DisplayList::SharedPtr &dl, const Rect &area, Flags<RenderFlag>) const
+{
+    const Rect resultRect = getRect(area);
+    if(!Surface::isValidRect(resultRect))
+        return DisplayList::SharedPtr();
+
+    DisplayList::SharedPtr ret(new DisplayList(resultRect.size()));
+    ret->appendCommand(new OpenGLShaderManagerCommand(mShader, dl, area, resultRect));
+    return ret;
+}
diff --git a/partner/graphics/rpi/EffectsGLES2.h b/partner/graphics/rpi/EffectsGLES2.h
new file mode 100644
index 00000000..f691c662
--- /dev/null
+++ b/partner/graphics/rpi/EffectsGLES2.h
@@ -0,0 +1,208 @@
+/* (c) 2013 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+
+#ifndef __EFFECTSGLES_H__
+#define __EFFECTSGLES_H__
+
+#include <Widget.h>
+#include <Effects.h>
+#include <OpenGLContext.h>
+#include <OpenGLState.h>
+#include <OpenGLShaders.h>
+#include <nrdbase/tr1.h>
+
+namespace netflix {
+namespace gibbon {
+
+void initGLEffectShaders(OpenGLContext*);
+
+class BlurShaderCache;
+
+class EffectParamsGLES2
+{
+public:
+    virtual ~EffectParamsGLES2() { }
+
+    virtual void collectParts(int id, OpenGLShader::Parts &verts, OpenGLShader::Parts &frags) = 0;
+};
+
+class EffectBlurGLES2 : public EffectBlur
+{
+public:
+    EffectBlurGLES2() {}
+    virtual std::string describe() const override { return "GL" + EffectBlur::describe(); }
+
+    class Shader : public OpenGLShader
+    {
+    public:
+        typedef std::shared_ptr<Shader> SharedPtr;
+
+        enum { Position = OpenGLShader::Last+1, TexCoord, TexelWidth, TexelHeight, Opacity, Last = Opacity };
+
+        Shader(const OpenGLProgram::SharedPtr& program, uint32_t weightHash)
+            : OpenGLShader(program), mWeightHash(weightHash)
+        {
+            init();
+        }
+        Shader(OpenGLContext *ctx, const GLchar *vertex, const GLchar *fragment, const std::string &name, uint32_t weightHash)
+            : OpenGLShader(ctx, vertex, fragment, name), mWeightHash(weightHash)
+        {
+            init();
+        }
+
+        ~Shader()
+        {
+            OpenGLContext::deleteBuffer(mVertexBuffer);
+        }
+
+        void bindVertexBuffer()
+        {
+            context()->state()->bindBuffer(GL_ARRAY_BUFFER, mVertexBuffer);
+        }
+
+        virtual void bind() override
+        {
+            OpenGLShader::bind();
+
+            const GLfloat vertices[16] = {
+                -1.0, +1.0,     0.0, 0.0,
+                -1.0, -1.0,     0.0, 1.0,
+                +1.0, -1.0,     1.0, 1.0,
+                +1.0, +1.0,     1.0, 0.0
+            };
+            bindVertexBuffer();
+            glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
+
+            const GLuint pos = program()->variable(EffectBlurGLES2::Shader::Position);
+            glVertexAttribPointer(pos, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(GLfloat), (GLvoid*)(0*sizeof(GLfloat)));
+            context()->state()->enableVAA(pos);
+
+            const GLuint tex = program()->variable(EffectBlurGLES2::Shader::TexCoord);
+            glVertexAttribPointer(tex, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(GLfloat), (GLvoid*)(2*sizeof(GLfloat)));
+            context()->state()->enableVAA(tex);
+        }
+
+        virtual void render() override
+        {
+            glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
+        }
+
+        inline uint32_t weightHash() const { return mWeightHash; }
+
+    protected:
+        void init()
+        {
+            mProgram->reserveVariables(EffectBlurGLES2::Shader::Last);
+            mVertexBuffer = context()->createVBO();
+        }
+
+    private:
+        GLuint mVertexBuffer;
+        uint32_t mWeightHash;
+
+        friend class OpenGLShader;
+    };
+    class GLES2Renderer : public DefaultRenderer {
+    public:
+        GLES2Renderer(const std::shared_ptr<Shader>& s, const EffectBlur::Data& d) : DefaultRenderer(d), mShader(s) {}
+        ~GLES2Renderer();
+        virtual DisplayList::SharedPtr render(const DisplayList::SharedPtr& dl, const Rect& rect, Flags<RenderFlag> renderFlags) const override;
+    protected:
+        std::shared_ptr<Shader> mShader;
+    };
+
+    virtual size_t purge() override
+    {
+        mShader.reset();
+        return EffectBlur::purge();
+    }
+    virtual Renderer::SharedPtr getDefaultRenderer() override;
+
+protected:
+    std::shared_ptr<Shader> mShader;
+};
+
+class EffectDesaturateGLES2 : public EffectDesaturate, public EffectParamsGLES2
+{
+public:
+    EffectDesaturateGLES2() : EffectDesaturate() { }
+    virtual std::string describe() const override { return "GL" + EffectDesaturate::describe(); }
+
+    virtual Renderer::SharedPtr getDefaultRenderer() override { return Renderer::SharedPtr(); }
+
+    virtual void collectParts(int id, OpenGLShader::Parts &verts, OpenGLShader::Parts &frags) override;
+};
+
+class EffectTintGLES2 : public EffectTint, public EffectParamsGLES2
+{
+public:
+    EffectTintGLES2() : EffectTint() { }
+    virtual std::string describe() const override { return "GL" + EffectTint::describe(); }
+
+    virtual Renderer::SharedPtr getDefaultRenderer() override { return Renderer::SharedPtr(); }
+
+    virtual void collectParts(int id, OpenGLShader::Parts &verts, OpenGLShader::Parts &frags) override;
+};
+
+class EffectChromaKeyGLES2 : public EffectChromaKey, public EffectParamsGLES2
+{
+public:
+    EffectChromaKeyGLES2() : EffectChromaKey() { }
+    virtual std::string describe() const override { return "GL" + EffectChromaKey::describe(); }
+
+    virtual Renderer::SharedPtr getDefaultRenderer() override { return Renderer::SharedPtr(); }
+
+    virtual void collectParts(int id, OpenGLShader::Parts &verts, OpenGLShader::Parts &frags) override;
+};
+
+class EffectShaderGLES2 : public EffectShader
+{
+public:
+
+    EffectShaderGLES2() : EffectShader() { }
+    ~EffectShaderGLES2() { }
+    virtual std::string describe() const override { return "GL" + EffectShader::describe(); }
+
+    virtual Variant getParams(bool all) const override;
+    virtual bool setParams(const Variant& params) override;
+
+    class GLES2Renderer : public DefaultRenderer {
+    public:
+        GLES2Renderer(const std::shared_ptr<OpenGLShader> &s, const EffectShaderGLES2::Data &d) : DefaultRenderer(d), mShader(s) { }
+        ~GLES2Renderer();
+        virtual DisplayList::SharedPtr render(const DisplayList::SharedPtr &dl, const Rect &rect, Flags<RenderFlag> renderFlags) const override;
+
+    private:
+        std::shared_ptr<OpenGLShader> mShader;
+    };
+
+    virtual size_t purge() override {
+        mShader.reset();
+        if(mData.vertex.indices)
+            mData.vertex.indices->gl.reset();
+        for(std::vector<Data::Vertex::Buffer::SharedPtr>::const_iterator it = mData.vertex.buffers.begin(); it != mData.vertex.buffers.end(); ++it)
+            (*it)->gl.reset();
+        return EffectShader::purge();
+    }
+    virtual Renderer::SharedPtr getDefaultRenderer() override;
+
+protected:
+    std::shared_ptr<OpenGLShader> mShader;
+};
+
+class OpenGLShaderManagerRenderer : public Effect::Renderer
+{
+public:
+    OpenGLShaderManagerRenderer(const OpenGLShader::Parts &vertex, const OpenGLShader::Parts &fragment);
+
+    virtual std::string describe() const override { return mShader->describe(); }
+
+    virtual DisplayList::SharedPtr render(const DisplayList::SharedPtr &dl, const Rect &, Flags<RenderFlag>) const override;
+    virtual bool getAccelerated() const override { return true; }
+
+private:
+    std::shared_ptr<TextureShader> mShader;
+};
+
+}} // namespace netflix::gibbon
+
+#endif /* __SURFACEEFFECTSGLES_H__ */
diff --git a/partner/graphics/rpi/GraphicsEngineGLES2.cpp b/partner/graphics/rpi/GraphicsEngineGLES2.cpp
new file mode 100644
index 00000000..1ce5ed9a
--- /dev/null
+++ b/partner/graphics/rpi/GraphicsEngineGLES2.cpp
@@ -0,0 +1,621 @@
+/* (c) 2012 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+
+#include <GraphicsEngine.h>
+#include <Screen.h>
+#include "OpenGLContext.h"
+#include "OpenGLState.h"
+#include "OpenGLShaders.h"
+#include "OpenGLFBO.h"
+#include <GlyphCache.h>
+#include <nrd/AppLog.h>
+#include <gibbon/config.h>
+#include <nrdbase/BaseEncoding.h>
+#include <nrdbase/tr1.h>
+#ifdef GIBBON_NVIDIA_CAPTURE
+#include "OpenGLCapture.h"
+#endif
+
+using namespace netflix::gibbon;
+using namespace netflix;
+
+static inline void updateCompositionMode(OpenGLState::Scope &stateScope, GraphicsEngine::CompositionMode mode, bool alpha)
+{
+    if(GibbonDebug::DrawGLFragmentShader) {
+        mode = GraphicsEngine::CompositionMode_SourceOver;
+    } else if(!alpha && mode == GraphicsEngine::CompositionMode_SourceOver) {
+        mode = GraphicsEngine::CompositionMode_Source;
+    }
+    stateScope.setCompositionMode(mode);
+}
+
+void GraphicsEngine::init()
+{
+    mGLContext = 0;
+    mXScale = mYScale = 1.0;
+}
+
+void GraphicsEngine::begin_sys()
+{
+    if(!Animation::isAnimationThread()) {
+        mGLContext = 0;
+        return;
+    }
+    mGLContext = OpenGLContext::context();
+    if(mDisplayList) {
+        mXScale = mYScale = 1.;
+        mTargetRect = Screen::getRect();
+    } else {
+        if(mSurface->isScreen()) {
+            mTargetRect = mSurface->getRect();
+            mXScale = mTargetRect.width / float(mRect.width);
+            mYScale = mTargetRect.height / float(mRect.height);
+        } else {
+            mTargetRect = mRect;
+            mXScale = mYScale = 1.0f;
+            mFbo = OpenGLFBO::take(mSurface, mBuffers);
+            if(!mFbo->isValid()) {
+                Log::error(TRACE_GIBBON_GRAPHICS, "Unable to create fbo for begin_sys: %s", mSurface->describe().c_str());
+                mFbo.reset();
+            }
+        }
+        mGLContext->pushEngine(this);
+    }
+#ifdef GIBBON_NVIDIA_CAPTURE
+    if (mState.flags.test(Flag_Capture)) {
+        if (!OpenGLCapture::isCapturing()) {
+            OpenGLCapture::capture(mSurface, mTargetRect.width, mTargetRect.height);
+        } else {
+            Log::error(TRACE_GIBBON_GRAPHICS, "Can't capture while capturing");
+        }
+    }
+#endif
+}
+
+void GraphicsEngine::end_sys()
+{
+#ifdef GIBBON_NVIDIA_CAPTURE
+    if (mState.flags.test(Flag_Capture)) {
+        mGLContext->state()->bindFramebuffer(0);
+        OpenGLCapture::finalize();
+    }
+#endif
+
+    if(mFbo) {
+        mFbo->unbind();
+        mFbo.reset();
+    }
+
+    if(mGLContext) {
+        if(!mDisplayList) {
+            assert(mGLContext->engine() == this);
+            mGLContext->popEngine();
+        }
+        mGLContext = 0;
+    }
+}
+
+bool GraphicsEngine::isRenderThread()
+{
+    return Animation::isAnimationThread();
+}
+
+static inline Transform makeProjectionTransform(bool screen, float scalex, float scaley)
+{
+    Transform projection;
+    if(!fuzzy_compare(scalex, 1.0f) || !fuzzy_compare(scaley, 1.0f)) {
+        projection.translateNormalized(-1, 1);
+        projection.scale(scalex, scaley);
+        projection.translateNormalized(1, -1);
+    }
+    if(screen)
+        projection.scale(1, -1);
+     return projection;
+}
+
+static inline void makeTextureTransform(const Rect &surfaceRect, const Rect &rect, float textureTransform[4])
+{
+    if(rect != surfaceRect) {
+        textureTransform[0] = gibbon_coordinate_map(rect.x, surfaceRect.width, 0, 1);
+        textureTransform[1] = gibbon_coordinate_map(rect.y, surfaceRect.height, 0, 1);
+        textureTransform[2] = gibbon_coordinate_map(rect.width, surfaceRect.width, 0, 1);
+        textureTransform[3] = gibbon_coordinate_map(rect.height, surfaceRect.height, 0, 1);
+    } else {
+        static GLfloat noTextureTransform[4] = { 0, 0, 1, 1 };
+        memcpy(textureTransform, noTextureTransform, sizeof(noTextureTransform));
+    }
+}
+
+void GraphicsEngine::drawVBO(const std::shared_ptr<VBOShader> &shader, const Surface::SharedPtr &surface, const Color *color,
+                             const Rect &targetRect, Coordinate x, Coordinate y, CompositionMode mode, GraphicsEngine::SmoothScale smooth, bool glyphs)
+{
+    OpenGLShader::Scope scope(shader);
+    OpenGLProgram::SharedPtr program = shader->program();
+
+    const Surface::Format sformat = surface->getFormat();
+    bool hasAlpha = false;
+
+    const Transform projection = mState.projection * makeProjectionTransform(isScreen(), mXScale, mYScale);
+    glUniformMatrix4fv(program->variable(VBOShader::ProjMatrix), 1, GL_FALSE, projection.matrix());
+
+    GLfloat opacity[4] = { 1.0f, 1.0f, 1.0f, mState.opacity };
+    if(!fuzzy_compare(opacity[3], 1.0f)) {
+        hasAlpha = true;
+        if((sformat & Surface::Flag_Premultiplied))
+            opacity[0] = opacity[1] = opacity[2] = mState.opacity;
+    }
+    glUniform4fv(program->variable(VBOShader::Opacity), 1, opacity);
+
+    if(shader->features() & VBOShader::Feature_Colorize) {
+        assert(color);
+        GLfloat c[4];
+        // coverity[deref_parm_in_call]
+        color->normalized(c);
+        if(c[3] < 1) {
+            hasAlpha = true;
+            if(sformat & Surface::Flag_Premultiplied) {
+                c[0] *= c[3];
+                c[1] *= c[3];
+                c[2] *= c[3];
+            }
+        }
+        glUniform4fv(program->variable(VBOShader::Color), 1, c);
+    }
+
+    if(shader->features() & VBOShader::Feature_Bicubic) {
+        const float txs[2] = { static_cast<float>(surface->getWidth() / 2.),
+                               static_cast<float>(surface->getHeight() / 2.) };
+        glUniform2fv(program->variable(VBOShader::TexSize), 1, txs);
+    }
+
+    Transform modelview = mState.transform;
+    modelview.translateNormalized(mapOffsetX(x), mapOffsetY(y));
+    if(targetRect != mTargetRect) {
+        Transform ratio;
+        ratio.translateNormalized(-1, -1);
+        ratio.scale(targetRect.width / mTargetRect.width, targetRect.height / mTargetRect.height);
+        ratio.translateNormalized(1, 1);
+        modelview *= ratio;
+    }
+    modelview.scale(1, -1);
+    glUniformMatrix4fv(program->variable(VBOShader::MVMatrix), 1, GL_FALSE, modelview.matrix());
+
+    OpenGLState *glstate = mGLContext->state();
+    OpenGLState::Scope stateScope(glstate);
+
+    if(shader->features() & (VBOShader::Feature_Mask|VBOShader::Feature_Mask_AlphaOnly)) {
+        hasAlpha = true;
+        glstate->activeTexture(GL_TEXTURE1);
+        glstate->bindTexture(surface->mask()->getTexture());
+        glstate->activeTexture(GL_TEXTURE0);
+    }
+
+    stateScope.enableScissor(hasClip(), glyphs ? OpenGLState::ScissorExclusive : OpenGLState::ScissorInclusive);
+
+    stateScope.setFormat(sformat, mSurface->getFormat());
+    updateCompositionMode(stateScope, mode, (sformat & Surface::Flag_Alpha) || hasAlpha);
+
+    stateScope.flush();
+
+    glstate->bindTexture(surface->getTexture());
+    glstate->setSmoothScale(smooth);
+
+    shader->render();
+}
+
+void GraphicsEngine::setTransform_sys(const Transform &/*transform*/)
+{
+}
+
+void GraphicsEngine::setProjection_sys(const Transform &/*projection*/)
+{
+}
+
+void GraphicsEngine::setOpacity_sys(float /*opacity*/)
+{
+}
+
+void GraphicsEngine::setSmoothScale_sys(SmoothScale /*smooth*/)
+{
+}
+
+void GraphicsEngine::updateClip(const Rect &r)
+{
+    const Coordinate y = isScreen() ? mGLContext->screenHeight() - (r.y * mYScale) - (r.height * mYScale) : r.y;
+    mGLContext->state()->setClip(Rect(mXScale * r.x, y, ceilf(mXScale * r.width), ceilf(mYScale * r.height)));
+}
+
+void GraphicsEngine::setClip_sys(const Rect *r)
+{
+    if(r)
+        updateClip(*r);
+}
+
+void GraphicsEngine::setCompositionMode_sys(GraphicsEngine::CompositionMode /*mode*/)
+{
+}
+
+void GraphicsEngine::drawTexture(GLuint texture, const GLfloat texTransform[4], const Rect &dstRect, Surface::Flags textureFlags,
+                                 const Color *color, const Surface::SharedPtr &mask)
+{
+    OpenGLState *glstate = mGLContext->state();
+    GL_ASSERT(glstate);
+
+    TextureShader::Features textureShaderFeatures;
+    if(color)
+        textureShaderFeatures |= TextureShader::Feature_Colorize;
+    if(mask && mask->isValid()) {
+        if(mask->hasAlpha()) {
+            if((mask->getFlags() & Surface::Flag_AlphaOnly) && GibbonConfiguration::alphaOnlyGreyscale())
+                textureShaderFeatures |= TextureShader::Feature_Mask;
+            else
+                textureShaderFeatures |= TextureShader::Feature_Mask_AlphaOnly;
+        } else {
+            textureShaderFeatures |= TextureShader::Feature_Mask;
+        }
+    }
+    if((textureFlags & Surface::Flag_PQ2020) || (mSurface->getFlags() & Surface::Flag_PQ2020)) {
+        if(!(textureFlags & Surface::Flag_PQ2020))
+            textureShaderFeatures |= TextureShader::Feature_Convert_709TO2020;
+        else if(!(mSurface->getFlags() & Surface::Flag_PQ2020))
+            textureShaderFeatures |= TextureShader::Feature_Convert_2020TO709;
+    }
+
+    const std::shared_ptr<TextureShader> &shader = OpenGLShaders::textureShader(textureShaderFeatures);
+    OpenGLShader::Scope scope(shader);
+    OpenGLProgram::SharedPtr program = shader->program();
+    bool hasAlpha = false;
+
+    glUniform4fv(program->variable(TextureShader::TextureTransform), 1, texTransform);
+
+    GLfloat opacity[4] = { 1.0f, 1.0f, 1.0f, mState.opacity };
+    if(!fuzzy_compare(opacity[3], 1.0f)) {
+        hasAlpha = true;
+        if((textureFlags & Surface::Flag_Premultiplied))
+            opacity[0] = opacity[1] = opacity[2] = mState.opacity;
+    }
+    glUniform4fv(program->variable(TextureShader::Opacity), 1, opacity);
+
+    const Transform projection = mState.projection * makeProjectionTransform(isScreen(), mXScale, mYScale);
+    glUniformMatrix4fv(program->variable(TextureShader::ProjMatrix), 1, GL_FALSE, projection.matrix());
+
+    glUniformMatrix4fv(program->variable(TextureShader::MVMatrix), 1, GL_FALSE, mState.transform.matrix());
+
+    if(shader->features() & (TextureShader::Feature_Mask|TextureShader::Feature_Mask_AlphaOnly)) {
+        hasAlpha = true;
+        glstate->activeTexture(GL_TEXTURE1);
+        glstate->bindTexture(mask->getTexture());
+        glstate->activeTexture(GL_TEXTURE0);
+    }
+
+    OpenGLState::Scope stateScope(glstate);
+    stateScope.enableScissor(hasClip());
+
+    stateScope.setFormat(Surface::flagsFormat(textureFlags), mSurface->getFormat());
+    updateCompositionMode(stateScope, getCompositionMode(), (textureFlags & Surface::Flag_Alpha) || hasAlpha);
+
+    const GLfloat vertices[4] = {
+        mapX(dstRect.left()), mapY(dstRect.top()),
+        mapX(dstRect.right()), mapY(dstRect.bottom())
+    };
+    glUniform4fv(program->variable(TextureShader::Rect), 1, vertices);
+
+    stateScope.flush();
+
+    glstate->bindTexture(texture);
+    glstate->setSmoothScale(mState.smoothScale != SmoothScale_None);
+
+    shader->render();
+    GL_ASSERT(glstate);
+}
+
+void GraphicsEngine::blit_sys(const Surface::SharedPtr &srcSurface, const Rect &srcRect, const Rect &dstRect, const Color *color)
+{
+    assert(srcSurface && srcSurface->isValid());
+    GLfloat texTransform[4];
+    makeTextureTransform(srcSurface->getRect(), srcRect, texTransform);
+    drawTexture(srcSurface->getTexture(), texTransform, dstRect, srcSurface->getFlags(), color, srcSurface->mask());
+}
+
+void GraphicsEngine::prerender_sys()
+{
+    OpenGLContext::lazyCleanup();
+}
+
+void GraphicsEngine::cleanup_sys()
+{
+    OpenGLFBO::cleanup();
+    OpenGLContext::lazyCleanup();
+}
+
+void GraphicsEngine::drawText_sys(const std::shared_ptr<Font::RenderData> &data, const Point &offset, bool outline)
+{
+    drawText_batchBlit(data, offset, outline);
+}
+
+void GraphicsEngine::clear_sys(const Rect &rect, Flags<Buffer> buffers)
+{
+    GLbitfield clear = 0;
+    Rect clip = mState.transform.map(rect);
+    if (hasClip())
+        clip.intersect(mState.clip);
+    else
+        clip.intersect(mTargetRect);
+
+
+    if(buffers & ColorBuffer) {
+        if (clip.isIntegral()) {
+            clear |= GL_COLOR_BUFFER_BIT;
+        } else {
+            drawRect(RectFill, rect, Color(0, 0, 0, 0), CompositionMode_Source);
+        }
+    }
+    if(buffers & DepthBuffer)
+        clear |= GL_DEPTH_BUFFER_BIT;
+    if(buffers & StencilBuffer)
+        clear |= GL_STENCIL_BUFFER_BIT;
+    if (clear) {
+        OpenGLState* glstate = mGLContext->state();
+        OpenGLState::Scope stateScope(glstate);
+
+        updateClip(clip);
+        stateScope.enableScissor();
+        stateScope.flush();
+        glClear(clear);
+        if (hasClip()) {
+            updateClip(mState.clip);
+        } else {
+            stateScope.enableScissor(false);
+            stateScope.flush();
+        }
+    }
+}
+
+void GraphicsEngine::drawRect(RectMode mode, const Rect &rect, const Color &color, CompositionMode compositionMode)
+{
+    assert(mGLContext->engine() == this);
+    OpenGLState *glstate = mGLContext->state();
+    GL_ASSERT(glstate);
+
+    std::shared_ptr<FillShader> shader;
+    if(mode == RectFill) {
+        FillShader::Features fillShaderFeatures;
+        if(mSurface->getFlags() & Surface::Flag_PQ2020)
+            fillShaderFeatures |= FillShader::Feature_Convert_709TO2020;
+        shader = OpenGLShaders::fillShader(fillShaderFeatures);
+    } else {
+        LineShader::Features lineShaderFeatures;
+        if(mSurface->getFlags() & Surface::Flag_PQ2020)
+            lineShaderFeatures |= FillShader::Feature_Convert_709TO2020;
+        shader = std::static_pointer_cast<FillShader>(OpenGLShaders::lineShader(lineShaderFeatures));
+    }
+
+    OpenGLShader::Scope scope(shader);
+    OpenGLProgram::SharedPtr program = shader->program();
+    const Surface::Format format = mSurface->getFormat();
+    bool hasAlpha = false;
+
+    GLfloat c[4];
+    color.normalized(c);
+    if(!fuzzy_compare(mState.opacity, 1.0f)) {
+        hasAlpha = true;
+        c[3] *= mState.opacity;
+    }
+    if(c[3] < 1) {
+        hasAlpha = true;
+        if((format & Surface::Flag_Premultiplied)) {
+            c[0] *= c[3];
+            c[1] *= c[3];
+            c[2] *= c[3];
+        }
+    }
+    glUniform4fv(program->variable(FillShader::Color), 1, c);
+
+    const Transform projection = mState.projection * makeProjectionTransform(isScreen(), mXScale, mYScale);
+    glUniformMatrix4fv(program->variable(FillShader::ProjMatrix), 1, GL_FALSE, projection.matrix());
+
+    glUniformMatrix4fv(program->variable(FillShader::MVMatrix), 1, GL_FALSE, mState.transform.matrix());
+
+    OpenGLState::Scope stateScope(glstate);
+
+    stateScope.setFormat(format, format);
+    updateCompositionMode(stateScope, compositionMode, hasAlpha);
+
+    const GLfloat vertices[4] = {
+        mapX(rect.left()), mapY(rect.top()),
+        mapX(rect.right()), mapY(rect.bottom())
+    };
+    glUniform4fv(program->variable(FillShader::Rect), 1, vertices);
+
+    stateScope.enableScissor(hasClip());
+    stateScope.flush();
+
+    shader->render();
+    GL_ASSERT(glstate);
+}
+
+void GraphicsEngine::fill_sys(const Rect &rect, const Color &color)
+{
+    drawRect(RectFill, rect, color, getCompositionMode());
+}
+
+void GraphicsEngine::drawRect_sys(const Rect &rect, const Color &color)
+{
+    const Rect lineRect(rect.x+1, rect.y+1, rect.width-2, rect.height-2);
+    if(lineRect.width > 0 && lineRect.height > 0)
+        drawRect(RectLine, lineRect, color, getCompositionMode());
+}
+
+void GraphicsEngine::texmap_sys(const Surface::SharedPtr &surface, const std::vector<Point> &srcs,
+                                const std::vector<Point> &dsts, const Color *color)
+{
+    OpenGLState *glstate = mGLContext->state();
+    GL_ASSERT(glstate);
+    assert(surface && surface->isValid());
+
+    OpenGLFloats &floats = mGLContext->floats();
+
+    if(srcs.empty())
+        return;
+    assert(srcs.size() == dsts.size());
+
+    const size_t sz = srcs.size();
+    floats.reserve(sz * 4);
+
+    const GLfloat cw = surface->getWidth(), ch = surface->getHeight();
+    for(size_t j = 0; j < sz; ++j) {
+        const Point &src = srcs[j], &dst = dsts[j];
+        GLfloat *v = floats.take(4);
+        *(v++) = mapX(dst.x);
+        *(v++) = -mapY(dst.y);
+        *(v++) = src.x / cw;
+        *(v++) = src.y / ch;
+    }
+
+    VBOShader::Features vboShaderFeatures;
+    Surface::SharedPtr mask = surface->mask();
+    if(color)
+        vboShaderFeatures |= VBOShader::Feature_Colorize;
+    if(mask && mask->isValid()) {
+        if(mask->hasAlpha()) {
+            if((mask->getFlags() & Surface::Flag_AlphaOnly) && GibbonConfiguration::alphaOnlyGreyscale())
+                vboShaderFeatures |= VBOShader::Feature_Mask;
+            else
+                vboShaderFeatures |= VBOShader::Feature_Mask_AlphaOnly;
+        } else {
+            vboShaderFeatures |= VBOShader::Feature_Mask;
+        }
+    }
+    if((surface->getFlags() & Surface::Flag_PQ2020) || (mSurface->getFlags() & Surface::Flag_PQ2020)) {
+        if(!(surface->getFlags() & Surface::Flag_PQ2020))
+            vboShaderFeatures |= VBOShader::Feature_Convert_709TO2020;
+        else if(!(mSurface->getFlags() & Surface::Flag_PQ2020))
+            vboShaderFeatures |= VBOShader::Feature_Convert_2020TO709;
+    }
+
+    const std::shared_ptr<VBOShader> &shader = OpenGLShaders::vboShader(vboShaderFeatures);
+    shader->updateVBO(floats, sz);
+    // coverity[var_deref_model]
+    drawVBO(shader, surface, color, mTargetRect, 0, 0, getCompositionMode(), mState.smoothScale, false);
+
+    floats.reset();
+    GL_ASSERT(glstate);
+}
+
+void GraphicsEngine::batchBlit_sys(const Surface::SharedPtr &surface, const std::vector<Rect> &srcs,
+                                   const std::vector<Rect> &dsts, const Color *color)
+{
+    OpenGLState *glstate = mGLContext->state();
+    GL_ASSERT(glstate);
+    assert(surface && surface->isValid());
+
+    OpenGLFloats &floats = mGLContext->floats();
+
+    const GLfloat cw = surface->getWidth();
+    const GLfloat ch = surface->getHeight();
+
+    if(srcs.empty())
+        return;
+    assert(srcs.size() == dsts.size());
+
+    enum { MaxSize = 1024 };
+
+    const Rect* srccur = &srcs[0];
+    const Rect* dstcur = &dsts[0];
+    size_t rem = srcs.size();
+    while (rem > 0) {
+        const size_t sz = std::min<size_t>(rem, MaxSize);
+        floats.reserve(sz * 24);
+
+        for (size_t j = 0; j < sz; ++j) {
+            const Rect &src = srccur[j], &dst = dstcur[j];
+
+            const GLfloat tx = mapX(dst.x);
+            const GLfloat ty = -mapY(dst.y + dst.height);
+            const GLfloat sx1 = src.x / cw;
+            const GLfloat sy1 = src.bottom() / ch;
+            const GLfloat sx2 = src.right() / cw;
+            const GLfloat sy2 = src.y / ch;
+            const GLfloat x0 = tx, y0 = ty, x1 = tx + mapOffsetX(dst.width), y1 = ty + mapOffsetY(dst.height);
+
+            GLfloat* v = floats.take(24);
+
+            *(v++) = x0;
+            *(v++) = y0;
+            *(v++) = sx1;
+            *(v++) = sy1;
+
+            *(v++) = x0;
+            *(v++) = y1;
+            *(v++) = sx1;
+            *(v++) = sy2;
+
+            *(v++) = x1;
+            *(v++) = y1;
+            *(v++) = sx2;
+            *(v++) = sy2;
+
+            *(v++) = x0;
+            *(v++) = y0;
+            *(v++) = sx1;
+            *(v++) = sy1;
+
+            *(v++) = x1;
+            *(v++) = y1;
+            *(v++) = sx2;
+            *(v++) = sy2;
+
+            *(v++) = x1;
+            *(v++) = y0;
+            *(v++) = sx2;
+            *(v++) = sy1;
+        }
+
+        VBOShader::Features vboShaderFeatures;
+        Surface::SharedPtr mask = surface->mask();
+        if(surface->getFlags() & Surface::Flag_AlphaOnly)
+            vboShaderFeatures |= VBOShader::Feature_AlphaOnly;
+        if(color)
+            vboShaderFeatures |= VBOShader::Feature_Colorize;
+        if(mState.smoothScale == SmoothScale_Bicubic)
+            vboShaderFeatures |= VBOShader::Feature_Bicubic;
+        if(mask && mask->isValid()) {
+            if(mask->hasAlpha()) {
+                if((mask->getFlags() & Surface::Flag_AlphaOnly) && GibbonConfiguration::alphaOnlyGreyscale())
+                    vboShaderFeatures |= VBOShader::Feature_Mask;
+                else
+                    vboShaderFeatures |= VBOShader::Feature_Mask_AlphaOnly;
+            } else {
+                vboShaderFeatures |= VBOShader::Feature_Mask;
+            }
+        }
+        if((surface->getFlags() & Surface::Flag_PQ2020) || (mSurface->getFlags() & Surface::Flag_PQ2020)) {
+            if(!(surface->getFlags() & Surface::Flag_PQ2020))
+                vboShaderFeatures |= VBOShader::Feature_Convert_709TO2020;
+            else if(!(mSurface->getFlags() & Surface::Flag_PQ2020))
+                vboShaderFeatures |= VBOShader::Feature_Convert_2020TO709;
+        }
+
+        const std::shared_ptr<VBOShader> &shader = OpenGLShaders::vboShader(vboShaderFeatures);
+        shader->updateVBO(floats, sz * 6);
+        // coverity[var_deref_model]
+        drawVBO(shader, surface, color, mTargetRect, 0, 0, getCompositionMode(), mState.smoothScale, surface->getFlags() & Surface::Flag_GlyphCache);
+
+        floats.reset();
+
+        rem -= sz;
+        srccur += sz;
+        dstcur += sz;
+    }
+    GL_ASSERT(glstate);
+}
+
+void GraphicsEngine::flush_sys()
+{
+    glFinish();
+}
+
+void GraphicsEngine::flushState_sys()
+{
+    mGLContext->loadEngineState(this, true);
+}
+
diff --git a/partner/graphics/rpi/OpenGLContext.cpp b/partner/graphics/rpi/OpenGLContext.cpp
new file mode 100644
index 00000000..0466d7fd
--- /dev/null
+++ b/partner/graphics/rpi/OpenGLContext.cpp
@@ -0,0 +1,540 @@
+/* (c) 2012 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+
+#include "OpenGLContext.h"
+#include "OpenGLFBO.h"
+#include "OpenGLState.h"
+#include "OpenGLShaders.h"
+#include "SurfaceCache.h"
+#include <Animation.h>
+#include <GibbonDebug.h>
+#include <GibbonConfiguration.h>
+#include <Screen.h>
+
+#include <nrd/AppLog.h>
+
+#include <nrdbase/ScopedMutex.h>
+#include <nrdbase/Application.h>
+#include <nrdbase/ObjectCount.h>
+#include <nrdbase/VarLengthArray.h>
+#include <nrdbase/ConditionVariable.h>
+#ifdef GIBBON_GRAPHICSENGINE_GLES2_EGL
+# include "OpenGLContextEGL.h"
+#endif
+#include "OpenGLVBO.h"
+
+#include <assert.h>
+
+using namespace netflix;
+using namespace netflix::gibbon;
+
+std::string OpenGLResourceCount::describe(const void *object) const
+{
+    return StringFormatter::sformat("%lld", reinterpret_cast<llong>(object));
+}
+NRDP_DEFINE_OBJECTCOUNT_RECORD(OpenGLResourceCount, OpenGLResourceProgram);
+NRDP_DEFINE_OBJECTCOUNT_RECORD(OpenGLResourceCount, OpenGLResourceTexture);
+NRDP_DEFINE_OBJECTCOUNT_RECORD(OpenGLResourceCount, OpenGLResourceVBO);
+NRDP_DEFINE_OBJECTCOUNT_RECORD(OpenGLResourceCount, OpenGLResourceFBO);
+NRDP_DEFINE_OBJECTCOUNT(OpenGLContext);
+NRDP_DEFINE_OBJECTCOUNT(OpenGLContextLazyCleanup);
+DEFINE_WARNAREA(GRAPHICS_GL_ENGINE_DEPTH, render_warnings|gibbon_warnings, TraceArea::Flag_None);
+
+std::shared_ptr<OpenGLContext> OpenGLContext::sPrimary;
+std::set<std::shared_ptr<OpenGLContext> > OpenGLContext::sContexts;
+Coordinate OpenGLContext::sWidth;
+Coordinate OpenGLContext::sHeight;
+bool OpenGLContext::sShutdown = false;
+ThreadLocalStore<ContextData> OpenGLContext::sContextDatas;
+Mutex OpenGLContext::sLazyCleanupMutex(LEAF_MUTEX, "OpenGL lazy cleanup mutex");
+std::vector<OpenGLContext::LazyCleanup*> OpenGLContext::sLazyCleanup;
+
+namespace netflix {
+namespace gibbon {
+
+static std::set<std::string> sGLExtensions;
+static pthread_once_t sGLExtensionsOnce = PTHREAD_ONCE_INIT;
+static void initGLExtensions_internal()
+{
+    const std::string all = reinterpret_cast<const char*>(glGetString(GL_EXTENSIONS));
+    size_t prev = 0;
+    for(size_t pos = all.find(' '); pos != std::string::npos; pos = all.find(' ', pos + 1)) {
+        sGLExtensions.insert(all.substr(prev, pos - prev));
+        prev = pos + 1;
+    }
+    if(prev < all.size())
+        sGLExtensions.insert(all.substr(prev));
+}
+inline static void initGLExtensions()
+{
+    pthread_once(&sGLExtensionsOnce, initGLExtensions_internal);
+}
+
+static std::map<std::string, int> sGLLimits;
+static pthread_once_t sGLLimitsOnce = PTHREAD_ONCE_INIT;
+static void initGLLimits_internal()
+{
+#define GL_LIMIT(n)                                             \
+    do {                                                        \
+        GLint value;                                            \
+        glGetIntegerv(n, &value);                               \
+        const GLenum e = glGetError();                          \
+        switch(e) {                                             \
+        case GL_NO_ERROR:                                       \
+            sGLLimits[#n] = value;                              \
+            break;                                              \
+        case GL_INVALID_ENUM:                                   \
+            break;                                              \
+        default: netflix::Log::fatal(TRACE_GIBBON_GRAPHICS)     \
+                << ">>> GL ERROR " << StringFormatter::hex(e)   \
+                << " AT " << NRDP_FUNC << "\n"                  \
+                << __FILE__ << ":" << __LINE__;                 \
+            abort();                                            \
+        }                                                       \
+    } while(0)
+#ifdef GL_MAX_LIST_NESTING
+    GL_LIMIT(GL_MAX_LIST_NESTING);
+#endif
+#ifdef GL_MAX_EVAL_ORDER
+    GL_LIMIT(GL_MAX_EVAL_ORDER);
+#endif
+#ifdef GL_MAX_LIGHTS
+    GL_LIMIT(GL_MAX_LIGHTS);
+#endif
+#ifdef GL_MAX_CLIP_PLANES
+    GL_LIMIT(GL_MAX_CLIP_PLANES);
+#endif
+#ifdef GL_MAX_TEXTURE_SIZE
+    GL_LIMIT(GL_MAX_TEXTURE_SIZE);
+#endif
+#ifdef GL_MAX_PIXEL_MAP_TABLE
+    GL_LIMIT(GL_MAX_PIXEL_MAP_TABLE);
+#endif
+#ifdef GL_MAX_ATTRIB_STACK_DEPTH
+    GL_LIMIT(GL_MAX_ATTRIB_STACK_DEPTH);
+#endif
+#ifdef GL_MAX_MODELVIEW_STACK_DEPTH
+    GL_LIMIT(GL_MAX_MODELVIEW_STACK_DEPTH);
+#endif
+#ifdef GL_MAX_NAME_STACK_DEPTH
+    GL_LIMIT(GL_MAX_NAME_STACK_DEPTH);
+#endif
+#ifdef GL_MAX_PROJECTION_STACK_DEPTH
+    GL_LIMIT(GL_MAX_PROJECTION_STACK_DEPTH);
+#endif
+#ifdef GL_MAX_TEXTURE_STACK_DEPTH
+    GL_LIMIT(GL_MAX_TEXTURE_STACK_DEPTH);
+#endif
+#ifdef GL_MAX_CLIENT_ATTRIB_STACK_DEPTH
+    GL_LIMIT(GL_MAX_CLIENT_ATTRIB_STACK_DEPTH);
+#endif
+#ifdef GL_MAX_CUBE_MAP_TEXTURE_SIZE
+    GL_LIMIT(GL_MAX_CUBE_MAP_TEXTURE_SIZE);
+#endif
+#ifdef GL_MAX_TEXTURE_UNITS
+    GL_LIMIT(GL_MAX_TEXTURE_UNITS);
+#endif
+#ifdef GL_MAX_COLOR_MATRIX_STACK_DEPTH
+    GL_LIMIT(GL_MAX_COLOR_MATRIX_STACK_DEPTH);
+#endif
+#ifdef GL_MAX_3D_TEXTURE_SIZE
+    GL_LIMIT(GL_MAX_3D_TEXTURE_SIZE);
+#endif
+#ifdef GL_MAX_ELEMENTS_INDICES
+    GL_LIMIT(GL_MAX_ELEMENTS_INDICES);
+#endif
+#ifdef GL_MAX_ELEMENTS_VERTICES
+    GL_LIMIT(GL_MAX_ELEMENTS_VERTICES);
+#endif
+#ifdef GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS
+    GL_LIMIT(GL_MAX_COMBINED_TEXTURE_IMAGE_UNITS);
+#endif
+#ifdef GL_MAX_TEXTURE_IMAGE_UNITS
+    GL_LIMIT(GL_MAX_TEXTURE_IMAGE_UNITS);
+#endif
+#ifdef GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS
+    GL_LIMIT(GL_MAX_VERTEX_TEXTURE_IMAGE_UNITS);
+#endif
+#undef GL_LIMIT
+}
+inline static void initGLLimits()
+{
+    if(OpenGLContext::hasContext())
+        pthread_once(&sGLLimitsOnce, initGLLimits_internal);
+}
+
+static std::set<int> sGLFormats;
+static pthread_once_t sGLFormatsOnce = PTHREAD_ONCE_INIT;
+static void initGLFormats_internal()
+{
+    GLint count;
+    glGetIntegerv(GL_NUM_COMPRESSED_TEXTURE_FORMATS, &count);
+    if(count) {
+    VarLengthArray<GLint, 10> tmp(count);
+    glGetIntegerv(GL_COMPRESSED_TEXTURE_FORMATS, tmp.data());
+    for(int i = 0; i < count; ++i)
+        sGLFormats.insert(tmp[i]);
+}
+}
+inline static void initGLFormats()
+{
+    if(OpenGLContext::hasContext())
+        pthread_once(&sGLFormatsOnce, initGLFormats_internal);
+}
+
+class ContextData
+{
+public:
+    ContextData() { }
+    ~ContextData()
+    {
+        std::shared_ptr<OpenGLContext> ctx = context.lock();
+        if(ctx)
+            OpenGLContext::sContexts.erase(ctx);
+    }
+
+    std::weak_ptr<OpenGLContext> context;
+};
+}} // netflix::gibbon
+
+OpenGLContext::OpenGLContext(OpenGLContext* share)
+    // coverity[ctor_dtor_leak]
+    : mPrivate(0), mState(new OpenGLState), mShared(share != 0)
+{
+    NRDP_OBJECTCOUNT_REF(OpenGLContext, this);
+    {
+        mWidth = sWidth;
+        mHeight = sHeight;
+        assert(!sShutdown);
+    }
+
+    // coverity[ctor_dtor_leak]
+    if(!init(share))
+        return;
+
+    glDisable(GL_BLEND);
+    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);
+    glPixelStorei(GL_PACK_ALIGNMENT, 1);
+    mState->viewport(0, 0, mWidth, mHeight);
+    glClearColor(0, 0, 0, 0);
+    glActiveTexture(GL_TEXTURE0);
+    glDisable(GL_DEPTH_TEST);
+    GL_ASSERT(mState);
+
+    const Surface::Format alphaFormat = gibbonApp()->getScreen()->getSurfaceFormat(Screen::SurfaceFormat_Alpha);
+    const Surface::Format opaqueFormat = gibbonApp()->getScreen()->getSurfaceFormat(Screen::SurfaceFormat_Opaque);
+    if((alphaFormat & Surface::Flag_BGR) || (opaqueFormat & Surface::Flag_BGR)) {
+        if((alphaFormat & Surface::Flag_BGR) && (alphaFormat & (Surface::Flag_BitDepth32|Surface::Flag_AlphaFirst)) != Surface::Flag_BitDepth32) {
+            Log::error(TRACE_GIBBON_GRAPHICS, "Alpha BGR formats must be BitDepth32 and not AlphaFirst.");
+            gibbonApp()->scheduleQuit();
+        }
+        if((opaqueFormat & Surface::Flag_BGR) && (opaqueFormat & (Surface::Flag_BitDepth32|Surface::Flag_AlphaFirst)) != Surface::Flag_BitDepth32) {
+            Log::error(TRACE_GIBBON_GRAPHICS, "Opaque BGR formats must be BitDepth32 and not AlphaFirst.");
+            gibbonApp()->scheduleQuit();
+        }
+        if(!supportsExtension("GL_EXT_texture_format_BGRA8888") && !supportsExtension("GL_EXT_bgra")) {
+            Log::error(TRACE_GIBBON_GRAPHICS, "BGRA8888 extension not supported");
+            gibbonApp()->scheduleQuit();
+        }
+    }
+
+    if(!mShared)
+        OpenGLShaders::init(this);
+}
+
+OpenGLContext::~OpenGLContext()
+{
+    // coverity[ctor_dtor_leak]
+    assert(!mPrivate);
+    assert(!mState);
+    NRDP_OBJECTCOUNT_DEREF(OpenGLContext, this);
+}
+
+bool OpenGLContext::init(OpenGLContext* share)
+{
+    if(init_sys(share)) {
+        initGLLimits();
+        initGLFormats();
+        initGLExtensions();
+        return true;
+    }
+    return false;
+}
+
+void OpenGLContext::cleanup()
+{
+    OpenGLShaders::cleanup();
+    mVBO.reset();
+    cleanup_sys();
+    delete mState;
+    mState = 0;
+    if(sPrimary.get() == this)
+        sPrimary.reset();
+}
+
+void OpenGLContext::shutdown()
+{
+    std::set<std::shared_ptr<OpenGLContext> > contexts;
+    {
+        sShutdown = true;
+        std::swap(contexts, sContexts);
+        sPrimary.reset();
+    }
+    for(std::set<std::shared_ptr<OpenGLContext> >::const_iterator it = contexts.begin(); it != contexts.end(); ++it)
+        (*it)->cleanup();
+}
+
+void OpenGLContext::setScreenSize(Coordinate width, Coordinate height)
+{
+    sWidth = width;
+    sHeight = height;
+    sShutdown = false;
+}
+
+OpenGLContext *OpenGLContext::primary()
+{
+    return sPrimary.get();
+}
+
+OpenGLContext *OpenGLContext::context()
+{
+    ContextData* data = sContextDatas.get();
+    if(!data) {
+        assert(GraphicsEngine::isRenderThread() || GibbonConfiguration::uploadInDecodeThreads());
+        data = new ContextData;
+        sContextDatas.set(data);
+    }
+    std::shared_ptr<OpenGLContext> ctx = data->context.lock();
+    if(!ctx) {
+        if(!sPrimary) {
+            ctx.reset(new OpenGLContext);
+            data->context = ctx;
+            sPrimary = ctx;
+            sContexts.insert(ctx);
+        } else {
+            ctx.reset(new OpenGLContext(sPrimary.get()));
+            data->context = ctx;
+            sContexts.insert(ctx);
+        }
+    }
+    assert(ctx);
+    return ctx.get();
+}
+
+bool OpenGLContext::hasContext()
+{
+    if(sShutdown)
+        return false;
+    return (sContextDatas.get() != 0);
+}
+
+GLuint OpenGLContext::createTexture()
+{
+    GL_ASSERT(mState);
+    GLuint texture = 0;
+    {
+        static Mutex textureMutex(ZERO_MUTEX, "GL texture mutex");
+        ScopedMutex locker(&textureMutex);
+        glGenTextures(1, &texture);
+        NRDP_OBJECTCOUNT_REF(OpenGLResourceTexture, texture);
+        mState->bindTexture(texture);
+        mState->resetTexture(texture);
+    }
+    GL_ASSERT(mState);
+    return texture;
+}
+
+GLuint OpenGLContext::createTexture(GLenum internalFormat, GLenum format, Coordinate width, Coordinate height)
+{
+    GLuint texture = createTexture();
+    glTexImage2D(GL_TEXTURE_2D, 0, internalFormat, width, height, 0, format, GL_UNSIGNED_BYTE, 0);
+    NTRACE(TRACE_GIBBON_GRAPHICS, "Created texture[%d] %fx%f (%d:%d)", texture, width, height, format, internalFormat);
+    GL_ASSERT(mState);
+    return texture;
+}
+
+bool OpenGLContext::readPixels(const Surface::SharedPtr &surface, DataBuffer &pixels)
+{
+    OpenGLFBO::SharedPtr oldFbo;
+    {
+        if(!mEngines.empty())
+            oldFbo = mEngines.back()->fbo();
+    }
+    OpenGLFBO::SharedPtr fbo;
+    if(surface->isScreen()) {
+#ifdef GIBBON_GRAPHICSENGINE_GLES2_OSMESA
+        pixels = framebuffer();
+        return true;
+#endif
+        mState->bindFramebuffer(0);
+#ifndef GIBBON_GRAPHICSENGINE_GLES2_EGL
+        glReadBuffer(mState->screenReadBuffer());
+#endif
+    } else {
+        fbo.reset(new OpenGLFBO(surface, GraphicsEngine::ColorBuffer));
+        if(!fbo->isValid()) {
+            Log::error(TRACE_GIBBON_GRAPHICS, "Unable to create fbo for readPixels: %s", surface->describe().c_str());
+            return false;
+        }
+    }
+    glReadPixels(0, 0, surface->getWidth(), surface->getHeight(), surface->textureFormat(), GL_UNSIGNED_BYTE, pixels.data());
+    const GLuint fboid = oldFbo ? oldFbo->fbo() : 0;
+    mState->bindFramebuffer(fboid);
+    GL_ASSERT(mState);
+    return true;
+}
+
+std::shared_ptr<OpenGLVBO> OpenGLContext::vbo()
+{
+    if(!mVBO) {
+        const GLfloat vertices[16] = {
+            -1.0, +1.0,     0.0, 0.0,
+            -1.0, -1.0,     0.0, 1.0,
+            +1.0, -1.0,     1.0, 1.0,
+            +1.0, +1.0,     1.0, 0.0
+        };
+        mVBO.reset(new OpenGLVBO(this));
+        mState->bindBuffer(GL_ARRAY_BUFFER, mVBO->vbo());
+        glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
+        GL_ASSERT(mState);
+    }
+    return mVBO;
+}
+
+GLuint OpenGLContext::createVBO()
+{
+    GL_ASSERT(mState);
+    GLuint vbo;
+    glGenBuffers(1, &vbo);
+    NRDP_OBJECTCOUNT_REF(OpenGLResourceVBO, vbo);
+    GL_ASSERT(mState);
+    return vbo;
+}
+
+GLuint OpenGLContext::createVBO(GLfloat *floats, int count)
+{
+    GLuint vbo = createVBO();
+    mState->bindBuffer(GL_ARRAY_BUFFER, vbo);
+    glBufferData(GL_ARRAY_BUFFER, count * sizeof(GLfloat), floats, GL_STATIC_DRAW);
+    GL_ASSERT(mState);
+    return vbo;
+}
+
+void OpenGLContext::addLazyCleanup(LazyCleanup *cleanup)
+{
+    ScopedMutex locker(&sLazyCleanupMutex);
+    sLazyCleanup.push_back(cleanup);
+}
+
+void OpenGLContext::deleteBuffer(GLuint &vbo)
+{
+    if(Animation::isAnimationThread()) {
+        OpenGLContext::ensureContext();
+        OpenGLContext::context()->state()->deleteBuffer(vbo);
+    } else {
+        OpenGLContext::addLazyCleanup(new BufferLazyCleanup(vbo));
+    }
+    vbo = 0;
+}
+
+void OpenGLContext::deleteTexture(GLuint &texture)
+{
+    if(GibbonConfiguration::uploadInDecodeThreads() || Animation::isAnimationThread()) {
+        OpenGLContext::ensureContext();
+        OpenGLContext::context()->state()->deleteTexture(texture);
+    } else {
+        OpenGLContext::addLazyCleanup(new TextureLazyCleanup(texture));
+    }
+    texture = 0;
+}
+
+void OpenGLContext::deleteProgram(GLuint &program)
+{
+    if(Animation::isAnimationThread()) {
+        OpenGLContext::ensureContext();
+        OpenGLContext::context()->state()->deleteProgram(program);
+    } else {
+        OpenGLContext::addLazyCleanup(new ProgramLazyCleanup(program));
+    }
+    program = 0;
+}
+
+void OpenGLContext::lazyCleanup()
+{
+    if(!OpenGLContext::hasContext())
+        return;
+
+    OpenGLState *glstate = OpenGLContext::context()->state();
+    GL_ASSERT(glstate);
+
+    std::vector<LazyCleanup*> cleanup;
+    {
+        ScopedMutex locker(&sLazyCleanupMutex);
+        std::swap(sLazyCleanup, cleanup);
+    }
+    if(!cleanup.empty()) {
+        for(size_t i = 0; i < cleanup.size(); ++i) {
+            cleanup[i]->execute();
+            delete cleanup[i];
+        }
+    }
+
+    GL_ASSERT(glstate);
+}
+
+std::vector<std::string> OpenGLContext::extensions()
+{
+    initGLExtensions();
+    std::vector<std::string> result;
+    for(std::set<std::string>::const_iterator it = sGLExtensions.begin(); it != sGLExtensions.end(); ++it)
+        result.push_back((*it));
+    return result;
+}
+
+bool OpenGLContext::supportsExtension(const std::string& ext)
+{
+    initGLExtensions();
+    return (std::find(sGLExtensions.begin(), sGLExtensions.end(), ext) != sGLExtensions.end());
+}
+
+std::map<std::string, int> OpenGLContext::limits()
+{
+    initGLLimits();
+    return sGLLimits;
+}
+
+std::vector<int> OpenGLContext::formats()
+{
+    initGLFormats();
+    std::vector<int> formats;
+    for(std::set<int>::const_iterator it = sGLFormats.begin(); it != sGLFormats.end(); ++it)
+        formats.push_back((*it));
+    return formats;
+}
+
+bool OpenGLContext::supportsFormat(int format)
+{
+    initGLFormats();
+    return (std::find(sGLFormats.begin(), sGLFormats.end(), format) != sGLFormats.end());
+}
+
+void OpenGLContext::loadEngineState(GraphicsEngine* engine, bool force)
+{
+    const GraphicsEngine::State& state = engine->getState();
+    engine->updateClip(state.clip);
+    const OpenGLFBO::SharedPtr &fbo = engine->fbo();
+    const GLuint fboid = fbo ? fbo->fbo() : 0;
+    mState->bindFramebuffer(fboid);
+    const Rect& viewport = engine->targetRect();
+    mState->viewport(viewport.x, viewport.y, viewport.width, viewport.height, force);
+    mState->reset();
+    if(force)
+        mState->flush();
+}
+
+std::string OpenGLContext::version() const
+{
+    if(const char* ver = reinterpret_cast<const char*>(glGetString(GL_VERSION)))
+        return std::string(ver);
+    return std::string();
+}
+
diff --git a/partner/graphics/rpi/OpenGLContext.h b/partner/graphics/rpi/OpenGLContext.h
new file mode 100644
index 00000000..60da013c
--- /dev/null
+++ b/partner/graphics/rpi/OpenGLContext.h
@@ -0,0 +1,216 @@
+/* (c) 2012 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+
+#ifndef OPENGLCONTEXT_H
+#define OPENGLCONTEXT_H
+
+#include "OpenGLContextCommon.h"
+#include "GraphicsEngine.h"
+#include "OpenGLFloats.h"
+#include "OpenGLState.h"
+#include <Surface.h>
+#include <GibbonDebug.h>
+#include <Color.h>
+#include <Rect.h>
+#include <Transform.h>
+#include <nrd/AppLog.h>
+#include <nrdbase/tr1.h>
+#include <nrdbase/Mutex.h>
+#include <nrdbase/LinkedList.h>
+#include <nrdbase/ThreadLocalStore.h>
+#include <nrdbase/Variant.h>
+#include <vector>
+
+NRDP_DECLARE_OBJECTCOUNT(OpenGLContextLazyCleanup);
+DECLARE_WARNAREA(GRAPHICS_GL_ENGINE_DEPTH);
+
+namespace netflix {
+namespace gibbon {
+
+class OpenGLContextPrivate;
+class OpenGLProgram;
+class ContextData;
+class OpenGLVBO;
+
+struct GLVertex
+{
+    float x, y, z;    // position
+    float s, t;       // texture
+    float r, g, b, a; // color
+};
+
+class OpenGLContext
+{
+public:
+    ~OpenGLContext();
+
+    static void setScreenSize(Coordinate width, Coordinate height);
+    static bool hasContext();
+    static OpenGLContext *context();
+    static OpenGLContext *primary();
+    static void ensureContext() { (void)context(); }
+    static void shutdown();
+    static void createWindow();
+
+    bool isValid() const { return mPrivate != 0; }
+
+    std::string version() const;
+
+    void loadEngineState(GraphicsEngine* engine, bool force);
+    void pushEngine(GraphicsEngine* engine);
+    void popEngine();
+    GraphicsEngine* engine();
+
+    void flip();
+
+    OpenGLState *state() { return mState; }
+    const OpenGLState *state() const { return mState; }
+
+    Coordinate screenWidth() const { return mWidth; }
+    Coordinate screenHeight() const { return mHeight; }
+
+    GLuint createTexture();
+    GLuint createTexture(GLenum internalFormat, GLenum format, Coordinate width, Coordinate height);
+    bool readPixels(const Surface::SharedPtr &surface, DataBuffer &pixels);
+
+    GLuint createVBO();
+    GLuint createVBO(GLfloat *floats, GLsizei count);
+    std::shared_ptr<OpenGLVBO> vbo();
+
+    OpenGLFloats &floats() { return mFloats; }
+
+    std::shared_ptr<OpenGLDisplay> display();
+
+    void focus() { focus_sys(); }
+
+    static void deleteBuffer(GLuint &vbo);
+    static void deleteTexture(GLuint &texture);
+    static void deleteProgram(GLuint &program);
+
+    class LazyCleanup
+    {
+    public:
+        inline LazyCleanup() { NRDP_OBJECTCOUNT_REF(OpenGLContextLazyCleanup, this); }
+        virtual ~LazyCleanup() { NRDP_OBJECTCOUNT_DEREF(OpenGLContextLazyCleanup, this);}
+        virtual void execute() { }
+    };
+    static void lazyCleanup();
+    static void addLazyCleanup(OpenGLContext::LazyCleanup *cleanup);
+
+    inline GLint getIntegerv(GLenum e) const {
+        GLint result;
+        glGetIntegerv(e, &result);
+        if(glGetError() != GL_NO_ERROR)
+            result = 0;
+        return result;
+    }
+
+    static std::map<std::string, int> limits();
+    static std::vector<std::string> extensions();
+    static bool supportsExtension(const std::string &ext);
+    static std::vector<int> formats();
+    static bool supportsFormat(int format);
+    static void* procAddr(const std::string &proc);
+    static bool supportsPlatformExtension(const std::string &ext);
+    static GLint getMaxTextureSize();
+
+#if defined(GIBBON_GRAPHICSENGINE_GLES2_OSX)
+    void* osxWindowHandle();
+#endif
+
+#if defined(GIBBON_GRAPHICSENGINE_GLES2_OSMESA)
+    DataBuffer framebuffer() const;
+#endif
+
+    class TextureLazyCleanup : public LazyCleanup
+    {
+    public:
+        inline TextureLazyCleanup(GLuint texture) : mTexture(texture) { }
+        virtual void execute() override { OpenGLContext::deleteTexture(mTexture); }
+    private:
+        GLuint mTexture;
+    };
+    class ProgramLazyCleanup : public LazyCleanup
+    {
+    public:
+        inline ProgramLazyCleanup(GLuint program) : mProgram(program) { }
+        virtual void execute() override { OpenGLContext::deleteProgram(mProgram); }
+    private:
+        GLuint mProgram;
+    };
+    class BufferLazyCleanup : public LazyCleanup
+    {
+    public:
+        inline BufferLazyCleanup(GLuint vbo) : mVBO(vbo) { }
+        virtual void execute() override { OpenGLContext::deleteBuffer(mVBO); }
+    private:
+        GLuint mVBO;
+    };
+
+#ifdef GIBBON_GRAPHICSENGINE_GLES2_GLX
+    static void setCurrentTime(unsigned long time);
+    static unsigned long currentTime();
+#endif
+
+    void graphicsInfo(Variant& variant) { graphicsInfo_sys(variant); }
+
+private:
+    bool init(OpenGLContext *share);
+    void cleanup();
+
+    bool init_sys(OpenGLContext *share);
+    void cleanup_sys();
+
+    void focus_sys();
+
+    void graphicsInfo_sys(Variant &variant);
+
+    const GraphicsEngine::State &engineState() const { assert(!mEngines.empty()); return mEngines.back()->getState(); }
+
+private:
+    OpenGLContext(OpenGLContext *share = 0);
+
+    std::vector<GraphicsEngine*> mEngines;
+
+    std::shared_ptr<OpenGLVBO> mVBO;
+    OpenGLContextPrivate *mPrivate;
+    OpenGLState* mState;
+    Coordinate mWidth, mHeight;
+    OpenGLFloats mFloats;
+    bool mShared;
+
+    static std::set<std::shared_ptr<OpenGLContext> > sContexts;
+    static std::shared_ptr<OpenGLContext> sPrimary;
+    static Coordinate sWidth, sHeight;
+    static Mutex sLazyCleanupMutex;
+    static std::vector<LazyCleanup*> sLazyCleanup;
+    static bool sShutdown;
+    static ThreadLocalStore<ContextData> sContextDatas;
+
+    friend class ContextData;
+};
+
+inline void OpenGLContext::pushEngine(GraphicsEngine* engine)
+{
+    mEngines.push_back(engine);
+    if(CHECK_WARNAREA(GRAPHICS_GL_ENGINE_DEPTH) && mEngines.size() > 1)
+        Log::warn(WARN_GRAPHICS_GL_ENGINE_DEPTH, "GraphicsEngine Depth: %zu",mEngines.size());
+    loadEngineState(engine, false);
+}
+
+inline void OpenGLContext::popEngine()
+{
+    assert(!mEngines.empty());
+    mEngines.pop_back();
+    if (!mEngines.empty())
+        loadEngineState(mEngines.back(), false);
+}
+
+inline GraphicsEngine* OpenGLContext::engine()
+{
+    assert(!mEngines.empty());
+    return mEngines.back();
+}
+
+}} // netflix::gibbon
+
+#endif
diff --git a/partner/graphics/rpi/OpenGLContextCommon.h b/partner/graphics/rpi/OpenGLContextCommon.h
new file mode 100644
index 00000000..e5fa16be
--- /dev/null
+++ b/partner/graphics/rpi/OpenGLContextCommon.h
@@ -0,0 +1,17 @@
+/* (c) 2011 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+
+#ifndef OPENGLCONTEXTCOMMON_H
+#define OPENGLCONTEXTCOMMON_H
+
+namespace netflix {
+namespace gibbon {
+
+struct OpenGLDisplay
+{
+    OpenGLDisplay() { }
+    virtual ~OpenGLDisplay() { }
+};
+
+}} // namespace netflix::gibbon
+
+#endif
diff --git a/partner/graphics/rpi/OpenGLContextEGL.cpp b/partner/graphics/rpi/OpenGLContextEGL.cpp
new file mode 100644
index 00000000..3b815a93
--- /dev/null
+++ b/partner/graphics/rpi/OpenGLContextEGL.cpp
@@ -0,0 +1,370 @@
+/*
+ * (c) 1997-2015 Netflix, Inc.  All content herein is protected by
+ * U.S. copyright and other applicable intellectual property laws and
+ * may not be copied without the express permission of Netflix, Inc.,
+ * which reserves all rights.  Reuse of any of this content for any
+ * purpose without the permission of Netflix, Inc. is strictly
+ * prohibited.
+ */
+#include "OpenGLContext.h"
+#include "OpenGLState.h"
+#include "OpenGLContextEGL.h"
+#include <Screen.h>
+#include <gibbon/config.h>
+#include <nrd/AppLog.h>
+#include <string.h>
+
+#include <bcm_host.h>
+
+static inline EGLDisplay gibbonEGLCreateDisplay()
+{
+    return eglGetDisplay(EGL_DEFAULT_DISPLAY);
+}
+static inline void gibbonEGLDestroyDisplay(EGLDisplay display)
+{
+    eglTerminate(display);
+}
+
+using namespace netflix;
+using namespace netflix::gibbon;
+
+#ifndef GIBBON_EGL_NO_SWAP
+static inline void gibbonEGLSwap(EGLDisplay display, EGLSurface surface)
+{
+    // This is called every time Netflix thinks a frame is presented, useful to distinguish deadlocks from video driver crashes.
+    //fprintf(stderr, "EGLSWAPBUFFERS\n");
+    eglSwapBuffers(display, surface);
+}
+#else
+extern void gibbonEGLSwap(EGLDisplay display, EGLSurface surface);
+#endif
+
+bool OpenGLContext::init_sys(OpenGLContext* share)
+{
+    bcm_host_init();
+
+    EGLint contextAttributes[] = { EGL_CONTEXT_CLIENT_VERSION, 2, EGL_NONE };
+
+    mPrivate = new OpenGLContextPrivate;
+    memset(mPrivate, '\0', sizeof(OpenGLContextPrivate));
+    if (!share) {
+        mPrivate->type = OpenGLContextPrivate::WindowContext;
+
+        EGLint numConfigs = 0;
+        EGLint majorVersion;
+        EGLint minorVersion;
+
+        EGLDisplay dpy = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+        assert(dpy != EGL_NO_DISPLAY);
+
+        mPrivate->display.reset(new OpenGLDisplayEGL(dpy));
+
+        //mPrivate->display = eglGetDisplay(EGL_DEFAULT_DISPLAY);
+        //assert(mPrivate->display != EGL_NO_DISPLAY);
+
+        EGLint result;
+        NRDP_UNUSED(result);
+
+        result = eglInitialize(dpy, &majorVersion, &minorVersion);
+        assert(result != EGL_FALSE);
+
+        Log::info(TRACE_GIBBON_GRAPHICS) << "EGL INITIALIZED " << majorVersion << "." << minorVersion;
+
+        result = eglGetConfigs(dpy, 0, 0, &numConfigs);
+        assert(result != EGL_FALSE);
+        assert(numConfigs > 0);
+
+        Log::info(TRACE_GIBBON_GRAPHICS) << "EGL CONFIGS ARE " << numConfigs;
+
+        const int targetSamples = Screen::getConfiguration().targetSamples;
+        int trySamples = targetSamples;
+
+        const EGLint configAttributes[] = {
+            EGL_RED_SIZE,        1,
+            EGL_GREEN_SIZE,      1,
+            EGL_BLUE_SIZE,       1,
+            EGL_ALPHA_SIZE,      1,
+            EGL_DEPTH_SIZE,      0,
+            EGL_STENCIL_SIZE,    0,
+            EGL_BUFFER_SIZE,     EGL_DONT_CARE,
+
+            EGL_RENDERABLE_TYPE, EGL_OPENGL_ES2_BIT,
+            EGL_SURFACE_TYPE,    EGL_WINDOW_BIT,
+
+            EGL_SAMPLE_BUFFERS,  trySamples ? 1 : EGL_DONT_CARE,
+            EGL_SAMPLES,         trySamples ? trySamples : EGL_DONT_CARE,
+
+            EGL_NONE
+        };
+
+        for (;;) {
+            int chooseConfigs = numConfigs;
+            result = eglChooseConfig(dpy, configAttributes, &mPrivate->display->config, 1, &chooseConfigs);
+            if (result == EGL_TRUE && chooseConfigs) {
+                numConfigs = chooseConfigs;
+                break;
+            }
+
+            if (!trySamples)
+                break;
+            trySamples /= 2;
+        }
+
+        assert(result != EGL_FALSE);
+        assert(numConfigs > 0);
+
+        EGLint bufferSize, redSize, greenSize, blueSize, alphaSize, depthSize, stencilSize;
+
+        eglGetConfigAttrib(dpy, mPrivate->display->config, EGL_BUFFER_SIZE, &bufferSize);
+        eglGetConfigAttrib(dpy, mPrivate->display->config, EGL_RED_SIZE, &redSize);
+        eglGetConfigAttrib(dpy, mPrivate->display->config, EGL_GREEN_SIZE, &greenSize);
+        eglGetConfigAttrib(dpy, mPrivate->display->config, EGL_BLUE_SIZE, &blueSize);
+        eglGetConfigAttrib(dpy, mPrivate->display->config, EGL_ALPHA_SIZE, &alphaSize);
+        eglGetConfigAttrib(dpy, mPrivate->display->config, EGL_DEPTH_SIZE, &depthSize);
+        eglGetConfigAttrib(dpy, mPrivate->display->config, EGL_STENCIL_SIZE, &stencilSize);
+
+        Log::info(TRACE_GIBBON_GRAPHICS) << "EGL CONFIG HAS"
+                                         << " U=" << bufferSize
+                                         << " R=" << redSize
+                                         << " G=" << greenSize
+                                         << " B=" << blueSize
+                                         << " A=" << alphaSize
+                                         << " D=" << depthSize
+                                         << " S=" << stencilSize;
+
+         // open the screen
+        int32_t success = 0;
+        uint32_t _width,  _height;
+        success = graphics_get_display_size(0 /* LCD */, &_width, &_height);
+        assert(success >=0);
+
+        VC_RECT_T dst_rect;
+        VC_RECT_T src_rect;
+
+        dst_rect.x = 0;
+        dst_rect.y = 0;
+        dst_rect.width = _width;
+        dst_rect.height = _height;
+
+        src_rect.x = 0;
+        src_rect.y = 0;
+        src_rect.width = _width << 16;
+        src_rect.height = _height << 16;
+
+        DISPMANX_DISPLAY_HANDLE_T dispman_display;
+        dispman_display = vc_dispmanx_display_open(0 /*LCD**/);
+
+        DISPMANX_UPDATE_HANDLE_T dispman_update;
+        dispman_update = vc_dispmanx_update_start(0);
+
+        DISPMANX_ELEMENT_HANDLE_T dispman_element;
+            dispman_element = vc_dispmanx_element_add(dispman_update, dispman_display,
+            5/*layer*/, &dst_rect, 0/*src*/,
+            &src_rect, DISPMANX_PROTECTION_NONE, 0 /*alpha*/,
+            0/*clamp*/, (DISPMANX_TRANSFORM_T) 0/*transform*/);
+
+        static EGL_DISPMANX_WINDOW_T nativewindow;
+        nativewindow.element = dispman_element;
+        nativewindow.width = _width;
+        nativewindow.height = _height;
+        vc_dispmanx_update_submit_sync( dispman_update );
+
+        mPrivate->surface = eglCreateWindowSurface(dpy, mPrivate->display->config, &nativewindow, 0);
+
+        assert(EGL_NO_SURFACE != mPrivate->surface);
+
+        EGLint width, height;
+        eglQuerySurface(dpy, mPrivate->surface, EGL_WIDTH, &width);
+        eglQuerySurface(dpy, mPrivate->surface, EGL_HEIGHT, &height);
+        
+
+        Log::info(TRACE_GIBBON_GRAPHICS) << "EGL SURFACE IS " << width << "x" << height;
+
+        mWidth = width;
+        mHeight = height;
+
+        mPrivate->context = eglCreateContext(mPrivate->display->dpy, mPrivate->display->config, EGL_NO_CONTEXT, contextAttributes);
+        assert(EGL_NO_CONTEXT != mPrivate->context);
+
+        result = eglMakeCurrent(mPrivate->display->dpy, mPrivate->surface, mPrivate->surface, mPrivate->context);
+        assert(EGL_FALSE != result);
+
+        result = eglSwapInterval(mPrivate->display->dpy, 1);
+        assert(EGL_FALSE != result);
+
+        Log::info(TRACE_GIBBON_GRAPHICS) << "EGL VENDOR     : " << eglQueryString(dpy, EGL_VENDOR);
+        Log::info(TRACE_GIBBON_GRAPHICS) << "EGL VERSION    : " << eglQueryString(dpy, EGL_VERSION);
+        std::string ext(reinterpret_cast< const char * >(eglQueryString(dpy, EGL_EXTENSIONS)));
+        std::replace(ext.begin(), ext.end(), ' ', '\n' );
+        Log::info(TRACE_GIBBON_GRAPHICS) << "EGL EXTENSIONS : " << "\n" << ext;
+    } else {
+        mPrivate->type = OpenGLContextPrivate::PbContext;
+        mPrivate->display = share->mPrivate->display;
+        mPrivate->display->config = share->mPrivate->display->config;
+        mWidth = share->mWidth;
+        mHeight = share->mHeight;
+
+        static EGLint pbAttribs[] = {
+            EGL_WIDTH, 1,
+            EGL_HEIGHT, 1,
+            EGL_NONE
+        };
+
+        EGLint result;
+        NRDP_UNUSED(result);
+
+        mPrivate->surface = eglCreatePbufferSurface(mPrivate->display->dpy, mPrivate->display->config, pbAttribs);
+        assert(EGL_NO_SURFACE != mPrivate->surface);
+        mPrivate->context = eglCreateContext(mPrivate->display->dpy, mPrivate->display->config, share->mPrivate->context, contextAttributes);
+        assert(EGL_NO_CONTEXT != mPrivate->context);
+
+        result = eglMakeCurrent(mPrivate->display->dpy, mPrivate->surface, mPrivate->surface, mPrivate->context);
+        assert(EGL_FALSE != result);
+
+        result = eglSwapInterval(mPrivate->display->dpy, 1);
+        assert(EGL_FALSE != result);
+    }
+
+    return true;
+}
+
+OpenGLDisplayEGL::~OpenGLDisplayEGL()
+{
+    gibbonEGLDestroyDisplay(dpy);
+}
+
+void OpenGLContext::createWindow()
+{
+}
+
+void OpenGLContext::focus_sys()
+{
+}
+
+void OpenGLContext::cleanup_sys()
+{
+    eglMakeCurrent(mPrivate->display->dpy, EGL_NO_SURFACE, EGL_NO_SURFACE, EGL_NO_CONTEXT);
+
+// TODO?
+/*
+    if(mPrivate->videoImage) {
+        eglDestroyImageKHR(mPrivate->display, mPrivate->videoImage);
+        glDeleteTextures(1 , &mPrivate->videoTexture );
+        mPrivate->videoImage = 0;
+    }
+*/
+    eglDestroySurface(mPrivate->display->dpy, mPrivate->surface);
+    eglDestroyContext(mPrivate->display->dpy, mPrivate->context);
+    if (mPrivate->type == OpenGLContextPrivate::WindowContext)
+        eglTerminate(mPrivate->display->dpy);
+
+    delete mPrivate;
+    mPrivate = 0;
+}
+
+void OpenGLContext::flip()
+{
+    gibbonEGLSwap(mPrivate->display->dpy, mPrivate->surface);
+}
+
+std::shared_ptr<OpenGLDisplay> OpenGLContext::display()
+{
+    return mPrivate->display;
+}
+
+// TODO?
+/*
+void *OpenGLContext::createEGLVideoImage(unsigned width, unsigned height)
+{
+    GL_CHECK;
+    OpenGLContext::ensureContext();
+    if(mPrivate->videoImage) {
+        eglDestroyImageKHR(mPrivate->display, mPrivate->videoImage);
+        glDeleteTextures(1, &mPrivate->videoTexture);
+    }
+    glGenTextures(1, &mPrivate->videoTexture);
+    glBindTexture(GL_TEXTURE_2D, mPrivate->videoTexture);
+    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+    GL_CHECK;
+    mPrivate->videoImage = eglCreateImageKHR(mPrivate->display, mPrivate->context, EGL_GL_TEXTURE_2D_KHR, (EGLClientBuffer)mPrivate->videoTexture, 0);
+    GL_CHECK;
+    glFinish();
+    return mPrivate->videoImage;
+}
+*/
+
+// TODO?
+/*
+bool OpenGLContext::renderVideo()
+{
+    if(int texture = mPrivate->videoTexture) {
+        GraphicsEngine* graphics = engine();
+        Rect clip;
+        const bool clipped = graphics->getState().hasClip;
+        if(clipped) {
+            clip = graphics->getState().clip;
+            mState->disableCap(GL_SCISSOR_TEST);
+            graphics->clearClip();
+        }
+
+        Transform transform;
+        transform.scale(1, -1, 1);
+        static GLfloat texTransform[4] = { 0, 0, 1, 1 };
+        graphics->blit(texture, transform, texTransform);
+
+        if(clipped) {
+            mState->enableCap(GL_SCISSOR_TEST);
+            graphics->setClip(clip);
+        }
+        return true;
+    }
+    return false;
+}
+*/
+
+void* OpenGLContext::procAddr(const std::string& proc)
+{
+    return reinterpret_cast<void*>(eglGetProcAddress(proc.c_str()));
+}
+
+static pthread_once_t sPlatformExtensionOnce = PTHREAD_ONCE_INIT;
+static std::set<std::string> sPlatformExtensions;
+
+static void initPlatformExtensions()
+{
+    const std::shared_ptr<OpenGLDisplayEGL> display = std::static_pointer_cast<OpenGLDisplayEGL>(OpenGLContext::context()->display());
+    const std::string all = reinterpret_cast<const char*>(eglQueryString(display->dpy, EGL_EXTENSIONS));
+    size_t prev = 0;
+    for (size_t pos = all.find(' '); pos != std::string::npos; pos = all.find(' ', pos + 1)) {
+        sPlatformExtensions.insert(all.substr(prev, pos - prev));
+        prev = pos + 1;
+    }
+    if (prev < all.size()) {
+        sPlatformExtensions.insert(all.substr(prev));
+    }
+}
+
+bool OpenGLContext::supportsPlatformExtension(const std::string& ext)
+{
+    pthread_once(&sPlatformExtensionOnce, initPlatformExtensions);
+    return (std::find(sPlatformExtensions.begin(), sPlatformExtensions.end(), ext) != sPlatformExtensions.end());
+}
+
+void OpenGLContext::graphicsInfo_sys(Variant& variant)
+{
+    pthread_once(&sPlatformExtensionOnce, initPlatformExtensions);
+
+    Variant extlist;
+    std::set<std::string>::const_iterator ext = sPlatformExtensions.begin();
+    const std::set<std::string>::const_iterator end = sPlatformExtensions.end();
+    while (ext != end) {
+        extlist.push_back(*ext);
+        ++ext;
+    }
+    variant["egl"]["extensions"] = extlist;
+}
+
diff --git a/partner/graphics/rpi/OpenGLContextEGL.h b/partner/graphics/rpi/OpenGLContextEGL.h
new file mode 100644
index 00000000..ed491419
--- /dev/null
+++ b/partner/graphics/rpi/OpenGLContextEGL.h
@@ -0,0 +1,39 @@
+/* (c) 2011 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+
+#ifndef OPENGLCONTEXTEGL_H
+#define OPENGLCONTEXTEGL_H
+
+#include "OpenGLContextCommon.h"
+#include <GLES2/gl2.h>
+#include <EGL/egl.h>
+#include <EGL/eglext.h>
+
+namespace netflix {
+namespace gibbon {
+
+struct OpenGLDisplayEGL : public OpenGLDisplay
+{
+    OpenGLDisplayEGL(EGLDisplay d) : dpy(d) { }
+    virtual ~OpenGLDisplayEGL();
+
+    EGLDisplay dpy;
+    EGLConfig config;
+};
+
+ class OpenGLContextPrivate
+{
+public:
+    enum {
+        WindowContext,
+        PbContext
+    } type;
+
+    std::shared_ptr<OpenGLDisplayEGL> display;
+    EGLContext context;
+    EGLSurface surface;
+    GLuint videoTexture;
+};
+
+}}
+
+#endif
diff --git a/partner/graphics/rpi/OpenGLContextGLX.cpp b/partner/graphics/rpi/OpenGLContextGLX.cpp
new file mode 100644
index 00000000..3e1ca740
--- /dev/null
+++ b/partner/graphics/rpi/OpenGLContextGLX.cpp
@@ -0,0 +1,491 @@
+/* (c) 2014 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+
+#include "OpenGLContext.h"
+#include "Screen.h"
+#include <GibbonConfiguration.h>
+#include <nrd/NrdConfiguration.h>
+#include <nrd/AppLog.h>
+#include <nrdbase/Mutex.h>
+#include <nrdbase/config.h>
+#include <nrdbase/Compiler.h>
+#include <nrdbase/ScopedMutex.h>
+#include "OpenGLContextGLX.h"
+#include <X11/Xatom.h>
+
+#include <string.h>
+#include <string>
+
+#ifndef GLX_CONTEXT_MAJOR_VERSION_ARB
+#define GLX_CONTEXT_MAJOR_VERSION_ARB 0x2091
+#endif
+#ifndef GLX_CONTEXT_MINOR_VERSION_ARB
+#define GLX_CONTEXT_MINOR_VERSION_ARB 0x2092
+#endif
+
+extern "C" void gibbon_shutdown();
+
+static std::set<std::string> sPlatformExtensions;
+
+static void initPlatformExtensions(Display *dpy)
+{
+    const std::string all = glXQueryExtensionsString(dpy, DefaultScreen(dpy));
+    size_t prev = 0;
+    for (size_t pos = all.find(' '); pos != std::string::npos; pos = all.find(' ', pos + 1)) {
+        sPlatformExtensions.insert(all.substr(prev, pos - prev));
+        prev = pos + 1;
+    }
+    if (prev < all.size()) {
+        sPlatformExtensions.insert(all.substr(prev));
+    }
+}
+
+using namespace netflix;
+using namespace netflix::gibbon;
+
+static Mutex sGLXDpyMutex(GIBBON_GL_PRIVATE_MUTEX, "GLX dpy mutex");
+static std::string x11ErrorStr;
+
+static Mutex sCurrentTimeMutex(ZERO_MUTEX, "OpenGLContextGLX::CurrentTime");
+static unsigned long sCurrentTime = CurrentTime;
+
+static int x11ErrorHandler(Display* /*dpy*/, XErrorEvent* ev)
+{
+    x11ErrorStr = StringFormatter::sformat("0x%x\n  Request: 0x%x\n  Minor: 0x%x",
+                                           ev->error_code, ev->request_code, ev->minor_code);
+#ifdef NRDP_HAS_SIGNAL_HANDLERS
+    gibbon_shutdown();
+#endif
+    return 0;
+}
+
+static int x11IOErrorHandler(Display* /*dpy*/)
+{
+    Log::error(TRACE_GIBBON_GRAPHICS, "X11 IO error, exiting");
+    _exit(10);
+    return 0;
+}
+
+void OpenGLContext::graphicsInfo_sys(Variant& variant)
+{
+    Variant extlist;
+    std::set<std::string>::const_iterator ext = sPlatformExtensions.begin();
+    const std::set<std::string>::const_iterator end = sPlatformExtensions.end();
+    while (ext != end) {
+        extlist.push_back(*ext);
+        ++ext;
+    }
+    variant["glx"]["extensions"] = extlist;
+}
+
+void OpenGLContext::setCurrentTime(unsigned long time)
+{
+    ScopedMutex locker(&sCurrentTimeMutex);
+    sCurrentTime = time;
+}
+
+unsigned long OpenGLContext::currentTime()
+{
+    ScopedMutex locker(&sCurrentTimeMutex);
+    return sCurrentTime;
+}
+
+void OpenGLContext::createWindow()
+{
+}
+
+static GLXContext createContext(Display* dpy, GLXFBConfig fbc, bool direct, GLXContext share = 0)
+{
+    GLXContext ctx = 0;
+    if (OpenGLContext::supportsPlatformExtension("GLX_ARB_create_context")) {
+        typedef GLXContext (*glXCreateContextAttribsARBProc)(Display*, GLXFBConfig, GLXContext, Bool, const int*);
+        glXCreateContextAttribsARBProc glXCreateContextAttribsARB = (glXCreateContextAttribsARBProc)OpenGLContext::procAddr("glXCreateContextAttribsARB");
+        const int context_attribs[] = {
+            GLX_CONTEXT_MAJOR_VERSION_ARB, 2,
+            GLX_CONTEXT_MINOR_VERSION_ARB, 1,
+            GLX_CONTEXT_PROFILE_MASK_ARB, GLX_CONTEXT_COMPATIBILITY_PROFILE_BIT_ARB,
+            None
+        };
+        ctx = glXCreateContextAttribsARB(dpy, fbc, share, direct ? True : False, context_attribs);
+    }
+    if (!ctx) {
+        ctx = glXCreateNewContext(dpy, fbc, GLX_RGBA_TYPE, share, direct ? True : False);
+    }
+    return ctx;
+}
+
+enum RenderingType { UnknownRenderingType, DirectRendering, IndirectRendering };
+
+static bool isDirect(Display* dpy, GLXFBConfig fbc, XVisualInfo* vi, RenderingType* type)
+{
+    XSetWindowAttributes swa;
+    swa.colormap = XCreateColormap(dpy, RootWindow(dpy, vi->screen), vi->visual, AllocNone);
+    swa.background_pixmap = None;
+    swa.border_pixel = 0;
+    swa.event_mask = (StructureNotifyMask | ExposureMask | KeyPressMask | KeyReleaseMask |
+                      PointerMotionMask | ButtonPressMask | ButtonReleaseMask);
+
+    Window win = XCreateWindow(dpy, RootWindow(dpy, vi->screen), 0, 0, 100, 100, 0, vi->depth,
+                               InputOutput, vi->visual, CWBorderPixel|CWColormap|CWEventMask, &swa);
+    if (!win) {
+        Log::error(TRACE_GIBBON_GRAPHICS, "Unable to create X window");
+        return false;
+    }
+
+    GLXContext ctx = createContext(dpy, fbc, true);
+    if (glXMakeCurrent(dpy, win, ctx)) {
+        RenderingType t = IndirectRendering;
+        if (glXIsDirect(dpy, ctx))
+            t = DirectRendering;
+        // cleanup
+
+        glXDestroyContext(dpy, ctx);
+        XDestroyWindow(dpy, win);
+        XFreeColormap(dpy, swa.colormap);
+
+        *type = t;
+        return true;
+    }
+
+    glXDestroyContext(dpy, ctx);
+    XDestroyWindow(dpy, win);
+    XFreeColormap(dpy, swa.colormap);
+
+    Log::error(TRACE_GIBBON_GRAPHICS, "Couldn't make context current");
+    return false;
+}
+
+static GLXFBConfig chooseFBConfig(Display* dpy, RenderingType type, bool force)
+{
+    static int visualAttribs[] = {
+        GLX_X_RENDERABLE, True,
+        GLX_DRAWABLE_TYPE, GLX_WINDOW_BIT,
+        GLX_RENDER_TYPE, GLX_RGBA_BIT,
+        GLX_X_VISUAL_TYPE, GLX_TRUE_COLOR,
+        GLX_RED_SIZE, 8,
+        GLX_GREEN_SIZE, 8,
+        GLX_BLUE_SIZE, 8,
+        GLX_ALPHA_SIZE, 8,
+        GLX_DEPTH_SIZE, 24,
+        GLX_STENCIL_SIZE, 8,
+        GLX_DOUBLEBUFFER, True,
+        None
+    };
+
+    int fbCount;
+    GLXFBConfig* fbc = glXChooseFBConfig(dpy, DefaultScreen(dpy), visualAttribs, &fbCount);
+    if (!fbc) {
+        Log::error(TRACE_GIBBON_GRAPHICS, "Couldn't get framebuffer config");
+        return 0;
+    }
+
+    RenderingType rt = UnknownRenderingType;
+    const int targetSamples = netflix::gibbon::Screen::getConfiguration().targetSamples;
+    // Pick the FB config/visual with the most samples (up to and including targetSamples) per pixel
+    int best_fbc = -1, worst_fbc = -1, best_num_samp = -1, worst_num_samp = 999;
+    for (int i = 0; i < fbCount; ++i) {
+        XVisualInfo *vi = glXGetVisualFromFBConfig(dpy, fbc[i]);
+        if (vi) {
+            if (!force && !isDirect(dpy, fbc[i], vi, &rt))
+                return 0;
+            // if our request type doesn't match the fbc type then don't consider the fbc
+            if (type != rt)
+                continue;
+
+            int samp_buf, samples;
+            glXGetFBConfigAttrib(dpy, fbc[i], GLX_SAMPLE_BUFFERS, &samp_buf);
+            glXGetFBConfigAttrib(dpy, fbc[i], GLX_SAMPLES, &samples);
+
+            if (best_fbc < 0 || ((samp_buf && samples > best_num_samp) && (samples <= targetSamples))) {
+                best_fbc = i;
+                best_num_samp = samples;
+            }
+            if (worst_fbc < 0 || !samp_buf || samples < worst_num_samp) {
+                worst_fbc = i;
+                worst_num_samp = samples;
+            }
+        }
+        XFree(vi);
+    }
+
+    NTRACE(TRACE_GIBBON_GRAPHICS, "Chose fbc %x with %d samples", best_fbc, best_num_samp);
+    GLXFBConfig bestFbc = best_fbc == -1 ? 0 : fbc[best_fbc];
+
+    XFree(fbc);
+
+    return bestFbc;
+}
+
+bool OpenGLContext::init_sys(OpenGLContext* share)
+{
+    if(!getenv("SVGA_VGPU10"))
+        setenv("SVGA_VGPU10", "0", 1);
+
+    const GibbonConfiguration::UseDirectContext useDirectContext = GibbonConfiguration::useDirectContext();
+    const bool forceContext = GibbonConfiguration::forceContext();
+
+    ScopedMutex locker(&sGLXDpyMutex);
+
+    mPrivate = new OpenGLContextPrivate;
+    if (!share) {
+        mWidth = GibbonConfiguration::screenWidth();
+        mHeight = GibbonConfiguration::screenHeight();
+
+#ifndef NRDP_REFERENCE
+        XInitThreads();
+#endif
+
+        XSetErrorHandler(x11ErrorHandler);
+        XSetIOErrorHandler(x11IOErrorHandler);
+
+        // create an X display and everything
+        Display* dpy = XOpenDisplay(0);
+        if (!dpy) {
+            Log::error(TRACE_GIBBON_GRAPHICS, "Couldn't create X display");
+            return false;
+        }
+        initPlatformExtensions(dpy);
+        mPrivate->dpy.reset(new OpenGLDisplayGLX(dpy));
+        mPrivate->type = OpenGLContextPrivate::WindowContext;
+
+        int glxMajor, glxMinor;
+        // FBConfigs were added in GLX version 1.3
+        if (!glXQueryVersion(dpy, &glxMajor, &glxMinor) ||
+            ((glxMajor == 1) && (glxMinor < 3)) || (glxMajor < 1)) {
+            Log::error(TRACE_GIBBON_GRAPHICS, "Need GLX 1.3 or higher");
+            return false;
+        }
+
+        bool isDirect = true;
+        GLXFBConfig fbc = 0;
+        switch (useDirectContext) {
+        case GibbonConfiguration::UseDirectContext_Auto:
+        case GibbonConfiguration::UseDirectContext_Yes:
+            fbc = chooseFBConfig(dpy, DirectRendering, forceContext);
+            if (!fbc) {
+                Log::error(TRACE_GIBBON_GRAPHICS, "Couldn't get direct fbc (force %s)", forceContext ? "true" : "false");
+            }
+            break;
+        default:
+            break;
+        }
+        if (!fbc) {
+            switch (useDirectContext) {
+            case GibbonConfiguration::UseDirectContext_Auto:
+                Log::error(TRACE_GIBBON_GRAPHICS, "Falling back to indirect");
+                NRDP_FALL_THROUGH;
+            case GibbonConfiguration::UseDirectContext_No:
+                fbc = chooseFBConfig(dpy, IndirectRendering, forceContext);
+                isDirect = false;
+                break;
+            default:
+                break;
+            }
+        }
+        if (!fbc) {
+            Log::error(TRACE_GIBBON_GRAPHICS, "Couldn't get framebuffer config (force %s)", forceContext ? "true" : "false");
+            return false;
+        }
+        mPrivate->fbc = fbc;
+
+        XVisualInfo *vi = glXGetVisualFromFBConfig(dpy, fbc);
+
+        if (!vi) {
+            Log::error(TRACE_GIBBON_GRAPHICS, "Couldn't get visual from frame buffer config");
+            return false;
+        }
+
+        mPrivate->screen = vi->screen;
+
+        XSetWindowAttributes swa;
+        swa.colormap = mPrivate->cmap = XCreateColormap(dpy, RootWindow(dpy, vi->screen), vi->visual, AllocNone);
+        swa.background_pixmap = None;
+        swa.border_pixel = 0;
+        swa.event_mask = (StructureNotifyMask | ExposureMask | KeyPressMask | KeyReleaseMask |
+                          PointerMotionMask | ButtonPressMask | ButtonReleaseMask);
+
+        mPrivate->win = XCreateWindow(dpy, RootWindow(dpy, vi->screen), 0, 0, mWidth, mHeight, 0, vi->depth,
+                                      InputOutput, vi->visual, CWBorderPixel|CWColormap|CWEventMask, &swa);
+        if (!mPrivate->win) {
+            XFree(vi);
+            Log::error(TRACE_GIBBON_GRAPHICS, "Unable to create X11 window");
+            return false;
+        }
+
+        if(supportsPlatformExtension("EXT_swap_control")) {
+            if(void *f = OpenGLContext::procAddr("glXSwapIntervalEXT")) {
+                typedef int (*glXSwapIntervalEXT_f)(Display *, GLXDrawable, unsigned int);
+                ((glXSwapIntervalEXT_f)f)(dpy, mPrivate->win, 1);
+            }
+        } else if(supportsPlatformExtension("MESA_swap_control")) {
+            if(void *f = OpenGLContext::procAddr("glXSwapIntervalMESA")) {
+                typedef int (*glXSwapIntervalMESA_f)(unsigned int);
+                ((glXSwapIntervalMESA_f)f)(1);
+            }
+        } else if(supportsPlatformExtension("SGI_swap_control")) {
+            if(void *f = OpenGLContext::procAddr("glXSwapIntervalSGI")) {
+                typedef int (*glXSwapIntervalSGIA_f)(unsigned int);
+                ((glXSwapIntervalSGIA_f)f)(1);
+            }
+        }
+
+        XFree(vi);
+
+        {
+            XStoreName(dpy, mPrivate->win, "Gibbon GLX");
+            XClassHint* hint = XAllocClassHint();
+            std::string clazz = GibbonConfiguration::windowClass();
+            std::string name = GibbonConfiguration::windowName();
+            hint->res_name = &name[0];
+            hint->res_class = &clazz[0];
+            XSetClassHint(dpy, mPrivate->win, hint);
+            XFree(hint);
+        }
+        {
+            XSizeHints hints;
+            hints.flags = PSize | PMinSize | PMaxSize;
+            hints.width = hints.max_width = hints.min_width = mWidth;
+            hints.height = hints.max_height = hints.min_height = mHeight;
+            XSetWMNormalHints(dpy, mPrivate->win, &hints);
+        }
+
+        const Atom _net_wm_state = XInternAtom(dpy, "_NET_WM_STATE", True);
+        const Atom _net_wm_state_below = XInternAtom(dpy, "_NET_WM_STATE_BELOW", True);
+
+        if (!GibbonConfiguration::takeFocus()) {
+            XWMHints hints;
+            hints.flags = InputHint | StateHint;
+            hints.input = False;
+            hints.initial_state = NormalState;
+            XSetWMHints(dpy, mPrivate->win, &hints);
+
+            Atom wm_take_focus = XInternAtom(dpy, "WM_TAKE_FOCUS", True);
+            if (!XSetWMProtocols(dpy, mPrivate->win, &wm_take_focus, 1)) {
+                Log::error(TRACE_GIBBON_GRAPHICS, "GLX: Can't set WM_TAKE_FOCUS");
+            }
+
+            XChangeProperty(dpy, mPrivate->win, _net_wm_state, XA_ATOM, 32, PropModeReplace,
+                            reinterpret_cast<const unsigned char*>(&_net_wm_state_below), 1);
+        }
+
+        if (GibbonConfiguration::showWindow()) {
+            XMapWindow(dpy, mPrivate->win);
+        }
+
+        if (!GibbonConfiguration::takeFocus()) {
+            XEvent event;
+            event.xclient.type = ClientMessage;
+            event.xclient.message_type = _net_wm_state;
+            event.xclient.display = dpy;
+            event.xclient.window = mPrivate->win;
+            event.xclient.format = 32;
+            event.xclient.data.l[0] = 0; // turn off
+            event.xclient.data.l[1] = _net_wm_state_below;
+            event.xclient.data.l[2] = 0l;
+            event.xclient.data.l[3] = 0l;
+            event.xclient.data.l[4] = 0l;
+            const Window root = XRootWindow(dpy, mPrivate->screen);
+            XSendEvent(dpy, root, False, SubstructureRedirectMask | SubstructureNotifyMask, &event);
+        }
+
+        mPrivate->ctx = createContext(dpy, fbc, isDirect);
+        mPrivate->isDirect = isDirect;
+        glXMakeCurrent(dpy, mPrivate->win, mPrivate->ctx);
+
+        if (!x11ErrorStr.empty()) {
+            delete mPrivate;
+            mPrivate = 0;
+            Log::error(TRACE_GIBBON_GRAPHICS, "X11 error: %s", x11ErrorStr.c_str());
+            return false;
+        }
+
+        NTRACE(TRACE_GIBBON_GRAPHICS, "GLX initialization complete");
+    } else {
+        mPrivate->type = OpenGLContextPrivate::PbContext;
+        const GLXContext shareCtx = share->mPrivate->ctx;
+        mPrivate->dpy = share->mPrivate->dpy;
+        Display* dpy = mPrivate->dpy->dpy;
+        mPrivate->fbc = share->mPrivate->fbc;
+        mPrivate->isDirect = share->mPrivate->isDirect;
+        mWidth = share->mWidth;
+        mHeight = share->mHeight;
+        static int pbAttribs[] = {
+            GLX_PBUFFER_WIDTH, static_cast<int>(mWidth),
+            GLX_PBUFFER_HEIGHT, static_cast<int>(mHeight),
+            GLX_LARGEST_PBUFFER, False,
+            GLX_PRESERVED_CONTENTS, False,
+            None
+        };
+        mPrivate->pb = glXCreatePbuffer(dpy, mPrivate->fbc, pbAttribs);
+        if (!mPrivate->pb) {
+            Log::error(TRACE_GIBBON_GRAPHICS, "Unable to create pixel buffer");
+            return false;
+        }
+        mPrivate->ctx = createContext(dpy, mPrivate->fbc, mPrivate->isDirect, shareCtx);
+        glXMakeCurrent(dpy, mPrivate->pb, mPrivate->ctx);
+    }
+    return true;
+}
+
+OpenGLDisplayGLX::~OpenGLDisplayGLX()
+{
+    XCloseDisplay(dpy);
+}
+
+void OpenGLContext::cleanup_sys()
+{
+    ScopedMutex locker(&sGLXDpyMutex);
+
+    Display* dpy = mPrivate->dpy->dpy;
+    if (dpy && mPrivate->ctx) {
+        glXMakeCurrent(dpy, None, 0);
+        switch (mPrivate->type) {
+        case OpenGLContextPrivate::WindowContext:
+            //glReleaseShaderCompiler();
+            glXDestroyContext(dpy, mPrivate->ctx);
+            XDestroyWindow(dpy, mPrivate->win);
+            XFreeColormap(dpy, mPrivate->cmap);
+            break;
+        case OpenGLContextPrivate::PbContext:
+            glXDestroyPbuffer(dpy, mPrivate->pb);
+            glXDestroyContext(dpy, mPrivate->ctx);
+            break;
+        }
+    }
+
+    delete mPrivate;
+    mPrivate = 0;
+}
+
+void OpenGLContext::focus_sys()
+{
+    assert(mPrivate->type == OpenGLContextPrivate::WindowContext);
+    unsigned long time = CurrentTime;
+    {
+        ScopedMutex locker(&sCurrentTimeMutex);
+        std::swap(time, sCurrentTime);
+    }
+    XSetInputFocus(mPrivate->dpy->dpy, mPrivate->win, RevertToPointerRoot, time);
+}
+
+void OpenGLContext::flip()
+{
+    // ### is this right?
+    assert(mPrivate->type == OpenGLContextPrivate::WindowContext);
+    glXSwapBuffers(mPrivate->dpy->dpy, mPrivate->win);
+}
+
+std::shared_ptr<OpenGLDisplay> OpenGLContext::display()
+{
+    ScopedMutex locker(&sGLXDpyMutex);
+    return mPrivate->dpy;
+}
+
+void* OpenGLContext::procAddr(const std::string& proc)
+{
+    return reinterpret_cast<void*>(glXGetProcAddress(reinterpret_cast<const GLubyte*>(proc.c_str())));
+}
+
+bool OpenGLContext::supportsPlatformExtension(const std::string& ext)
+{
+    return (sPlatformExtensions.find(ext) != sPlatformExtensions.end());
+}
diff --git a/partner/graphics/rpi/OpenGLContextGLX.h b/partner/graphics/rpi/OpenGLContextGLX.h
new file mode 100644
index 00000000..cdb0fd2d
--- /dev/null
+++ b/partner/graphics/rpi/OpenGLContextGLX.h
@@ -0,0 +1,54 @@
+/* (c) 2011 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+
+#ifndef OPENGLCONTEXTGLX_H
+#define OPENGLCONTEXTGLX_H
+
+#include "OpenGLContextCommon.h"
+#include <nrdbase/tr1.h>
+#include <X11/Xlib.h>
+#include <GL/gl.h>
+#include <GL/glx.h>
+#include <GL/glext.h>
+
+namespace netflix {
+namespace gibbon {
+
+struct OpenGLDisplayGLX : public OpenGLDisplay
+{
+    OpenGLDisplayGLX(Display* d) : dpy(d) { }
+    virtual ~OpenGLDisplayGLX();
+
+    Display* dpy;
+};
+
+class OpenGLContextPrivate
+{
+public:
+    OpenGLContextPrivate()
+        : cmap(0), screen(0), type(WindowContext), win(0), ctx(0), fbc(0), isDirect(false)
+    {
+        NRDP_STATIC_ASSERT(sizeof(pb) == sizeof(win));
+    }
+
+    std::shared_ptr<OpenGLDisplayGLX> dpy;
+    Colormap cmap;
+    int screen;
+
+    enum {
+        WindowContext,
+        PbContext
+    } type;
+
+    union {
+        Window win;
+        GLXPbuffer pb;
+    };
+
+    GLXContext ctx;
+    GLXFBConfig fbc;
+    bool isDirect;
+};
+
+}}
+
+#endif
diff --git a/partner/graphics/rpi/OpenGLContextOSMESA.cpp b/partner/graphics/rpi/OpenGLContextOSMESA.cpp
new file mode 100644
index 00000000..bcabba05
--- /dev/null
+++ b/partner/graphics/rpi/OpenGLContextOSMESA.cpp
@@ -0,0 +1,108 @@
+/* (c) 2017 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+#include "OpenGLContext.h"
+#include "OpenGLState.h"
+
+#include <GL/osmesa.h>
+
+using namespace netflix;
+using namespace netflix::gibbon;
+
+namespace netflix {
+namespace gibbon {
+
+class OpenGLContextPrivate
+{
+public:
+    unsigned char *buffer;
+    size_t buffer_len;
+    OSMesaContext ctx;
+};
+
+} }
+
+void OpenGLContext::createWindow()
+{
+}
+
+bool OpenGLContext::init_sys(OpenGLContext *share)
+{
+    NRDP_UNUSED(share);
+    assert(!share);
+
+    mPrivate = new OpenGLContextPrivate;
+
+    mWidth = GibbonConfiguration::screenWidth();
+    mHeight = GibbonConfiguration::screenHeight();
+    mPrivate->ctx = OSMesaCreateContextExt(OSMESA_RGBA, 16, 0, 0, NULL);
+    if(!mPrivate->ctx)
+        return false;
+
+    mPrivate->buffer_len = mWidth * mHeight * 4 * sizeof(GLubyte);
+    mPrivate->buffer = (unsigned char *)malloc(mPrivate->buffer_len);
+    if(!OSMesaMakeCurrent(mPrivate->ctx, mPrivate->buffer, GL_UNSIGNED_BYTE, mWidth, mHeight))
+        return false;
+    return true;
+}
+
+void OpenGLContext::cleanup_sys()
+{
+    free(mPrivate->buffer);
+    OSMesaDestroyContext(mPrivate->ctx);
+    delete mPrivate;
+    mPrivate = 0;
+}
+
+DataBuffer OpenGLContext::framebuffer() const
+{
+    return DataBuffer::fromRawData(mPrivate->buffer, mPrivate->buffer_len);
+}
+
+void OpenGLContext::focus_sys()
+{
+}
+
+void OpenGLContext::flip()
+{
+    glFlush();
+}
+
+void* OpenGLContext::procAddr(const std::string &proc)
+{
+    return reinterpret_cast<void*>(OSMesaGetProcAddress(proc.c_str()));
+}
+
+static pthread_once_t sPlatformExtensionOnce = PTHREAD_ONCE_INIT;
+static std::set<std::string> sPlatformExtensions;
+
+static void initPlatformExtensions()
+{
+    const std::string all = reinterpret_cast<const char*>(glGetString(GL_EXTENSIONS));
+    size_t prev = 0;
+    for (size_t pos = all.find(' '); pos != std::string::npos; pos = all.find(' ', pos + 1)) {
+        sPlatformExtensions.insert(all.substr(prev, pos - prev));
+        prev = pos + 1;
+    }
+    if (prev < all.size()) {
+        sPlatformExtensions.insert(all.substr(prev));
+    }
+}
+
+bool OpenGLContext::supportsPlatformExtension(const std::string &ext)
+{
+    pthread_once(&sPlatformExtensionOnce, initPlatformExtensions);
+    return (std::find(sPlatformExtensions.begin(), sPlatformExtensions.end(), ext) != sPlatformExtensions.end());
+}
+
+void OpenGLContext::graphicsInfo_sys(Variant &variant)
+{
+    pthread_once(&sPlatformExtensionOnce, initPlatformExtensions);
+
+    Variant extlist;
+    std::set<std::string>::const_iterator ext = sPlatformExtensions.begin();
+    const std::set<std::string>::const_iterator end = sPlatformExtensions.end();
+    while (ext != end) {
+        extlist.push_back(*ext);
+        ++ext;
+    }
+    variant["osmesa"]["extensions"] = extlist;
+}
diff --git a/partner/graphics/rpi/OpenGLContextOSX.h b/partner/graphics/rpi/OpenGLContextOSX.h
new file mode 100644
index 00000000..4dcdb8b2
--- /dev/null
+++ b/partner/graphics/rpi/OpenGLContextOSX.h
@@ -0,0 +1,22 @@
+/* (c) 2011 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+
+#ifndef OPENGLCONTEXTGLX_H
+#define OPENGLCONTEXTGLX_H
+
+#include <OpenGL/gl.h>
+#import <Cocoa/Cocoa.h>
+
+namespace netflix {
+namespace gibbon {
+
+class OpenGLContextPrivate
+{
+public:
+    NSWindow* win;
+    NSOpenGLContext* ctx;
+    NSOpenGLPixelFormat* fmt;
+};
+
+}}
+
+#endif
diff --git a/partner/graphics/rpi/OpenGLContextOSX.mm b/partner/graphics/rpi/OpenGLContextOSX.mm
new file mode 100644
index 00000000..f515efcb
--- /dev/null
+++ b/partner/graphics/rpi/OpenGLContextOSX.mm
@@ -0,0 +1,557 @@
+/* (c) 2014 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+
+#include "OpenGLContext.h"
+#include <nrd/AppLog.h>
+#include <string.h>
+#import "OpenGLContextOSX.h"
+#import <Carbon/Carbon.h>
+#define unichar unichar2
+typedef int ptrdiff_t2;
+#define ptrdiff_t ptrdiff_t2
+#include <GibbonEvent.h>
+#undef unichar
+#undef ptrdiff_t
+
+#include <GibbonNSApplicationDelegate.h>
+
+using namespace netflix;
+using namespace netflix::gibbon;
+
+#define TITLEBAR_HEIGHT 22
+
+class ScopedPool
+{
+public:
+    ScopedPool() { mPool = [[NSAutoreleasePool alloc] init]; }
+    ~ScopedPool() { [mPool drain]; }
+
+private:
+    NSAutoreleasePool* mPool;
+};
+
+static inline NSRect makeRect(const NSPoint& point)
+{
+    return NSMakeRect(point.x, point.y, 0, 0);
+}
+
+static int quadrantBetweenPoints(const NSPoint& p1, const NSPoint& p2)
+{
+    NSPoint p = { p2.x - p1.x, p2.y - p1.y };
+
+    if (p.x >= 0 && p.y >= 0) return 1;
+    else if (p.x < 0 && p.y > 0) return 2;
+    else if (p.x < 0 && p.y < 0) return 3;
+    else if (p.x > 0 && p.y < 0) return 4;
+
+    return 0;
+}
+
+static inline void cornerToPoint(NSBezierPath* path, const NSPoint& p2, CGFloat/* radius*/)
+{
+    const double percentage = 0.44772;
+    const NSPoint p1 = [path currentPoint];
+    NSPoint cp1 = p1, cp2 = p2;
+
+    switch (quadrantBetweenPoints(p1, p2))
+    {
+    case 1:
+        cp1.x += (p2.x - p1.x) * percentage;
+        cp2.y -= (p2.y - p1.y) * percentage;
+        break;
+    case 2:
+        cp1.y += (p2.y - p1.y) * percentage;
+        cp2.x -= (p2.x - p1.x) * percentage;
+        break;
+    case 3:
+        cp1.x -= (p1.x - p2.x) * percentage;
+        cp2.y += (p1.y - p2.y) * percentage;
+        break;
+    case 4:
+        cp1.y -= (p1.y - p2.y) * percentage;
+        cp2.x -= (p2.x - p1.x) * percentage;
+        break;
+    default:
+        break;
+    }
+
+    [path curveToPoint:p2 controlPoint1:cp1 controlPoint2:cp2];
+}
+
+@interface GibbonView : NSOpenGLView {
+@public
+}
+@end
+
+@implementation GibbonView
+- (BOOL)acceptsFirstResponder {
+    return YES;
+}
+@end
+
+@interface GibbonFrame : NSView {
+    bool enabled;
+    NSBezierPath *outline;
+    NSButton *closeButton;
+    NSButton *minimizeButton;
+    NSTrackingArea *buttonArea;
+};
+@end
+
+@implementation GibbonFrame
+- (id)initWithFrame:(NSRect)frame
+{
+    self = [super initWithFrame:frame];
+    if (self) {
+        self->enabled = false;
+        self->closeButton = [NSWindow standardWindowButton:NSWindowCloseButton
+                                              forStyleMask:NSTexturedBackgroundWindowMask];
+        self->minimizeButton = [NSWindow standardWindowButton:NSWindowMiniaturizeButton
+                                                 forStyleMask:NSTexturedBackgroundWindowMask];
+
+        const NSRect bounds = [self bounds];
+
+        NSRect frame = [self->closeButton frame];
+        frame.origin.x = 8;
+        frame.origin.y = bounds.size.height - TITLEBAR_HEIGHT + 3;
+
+        [self->closeButton setFrame:frame];
+
+        frame = [self->minimizeButton frame];
+        frame.origin.x = 8+21;
+        frame.origin.y = bounds.size.height - TITLEBAR_HEIGHT + 3;
+        [self->minimizeButton setFrame:frame];
+
+        [self addSubview:self->closeButton];
+        [self addSubview:self->minimizeButton];
+
+        NSRect buttonBounds = [self->closeButton frame];
+        buttonBounds.size.width = [self->minimizeButton frame].origin.x + [self->minimizeButton frame].size.width;
+        self->buttonArea = [[NSTrackingArea alloc] initWithRect:buttonBounds
+                                                        options:(NSTrackingMouseEnteredAndExited | NSTrackingActiveInKeyWindow)
+                                                          owner:self
+                                                       userInfo:nil];
+        [self addTrackingArea:self->buttonArea];
+
+        [self updateOutline];
+    }
+    return self;
+}
+
+- (BOOL)_mouseInGroup:(id)sender
+{
+    (void)sender;
+    return [self mouse:[self convertPoint:[[self window] mouseLocationOutsideOfEventStream]
+                                 fromView:nil]
+                inRect:[self->buttonArea rect]];
+}
+
+- (void)mouseEntered:(NSEvent*)theEvent
+{
+    NSTrackingArea* area = 0;
+
+    @try {
+        area = [theEvent trackingArea];
+
+        if (area == self->buttonArea)
+        {
+            [self->closeButton setNeedsDisplay:YES];
+            [self->minimizeButton setNeedsDisplay:YES];
+        }
+    }
+    @catch (NSException* e) {
+        // not a tracking area event
+    }
+}
+
+- (void)mouseExited:(NSEvent*)theEvent
+{
+    NSTrackingArea* area = 0;
+
+    @try {
+        area = [theEvent trackingArea];
+
+        if (area == self->buttonArea)
+        {
+            [self->closeButton setNeedsDisplay:YES];
+            [self->minimizeButton setNeedsDisplay:YES];
+        }
+    }
+    @catch (NSException* e) {
+        // not a tracking area event
+    }
+}
+
+- (void)updateFrame:(BOOL)ena
+{
+    self->enabled = ena;
+    [self setNeedsDisplay:YES];
+    [self->closeButton setNeedsDisplay:YES];
+    [self->minimizeButton setNeedsDisplay:YES];
+}
+
+- (void)updateOutline
+{
+    const NSRect frame = [self bounds];
+    const int radius = 6;
+
+    NSBezierPath *background = [NSBezierPath bezierPath];
+
+    const size_t startHeight = frame.size.height - TITLEBAR_HEIGHT - 1;
+
+    [background moveToPoint:NSMakePoint(0, startHeight)];
+    [background lineToPoint:NSMakePoint(frame.size.width, startHeight)];
+
+    [background lineToPoint:NSMakePoint(frame.size.width, frame.size.height-radius)];
+    cornerToPoint(background, NSMakePoint(frame.size.width - radius, frame.size.height), radius);
+
+    [background lineToPoint:NSMakePoint(radius, frame.size.height)];
+    cornerToPoint(background, NSMakePoint(0, frame.size.height-radius), radius);
+
+    [background lineToPoint:NSMakePoint(0, startHeight)];
+    [background closePath];
+
+    self->outline = background;
+    [self->outline retain];
+}
+
+- (void)drawRect:(NSRect)rect
+{
+    ScopedPool pool;
+
+    (void)rect;
+    NSRect titlebarRect = NSMakeRect(0, 0, self.bounds.size.width, TITLEBAR_HEIGHT);
+    titlebarRect.origin.y = self.bounds.size.height - titlebarRect.size.height - 1;
+
+    NSGradient* gradient;
+    NSColor* titleColor;
+    if (self->enabled) {
+        gradient = [[NSGradient alloc] initWithStartingColor:[NSColor colorWithDeviceRed:0.55 green:0.55 blue:0.55 alpha:1]
+                                                 endingColor:[NSColor colorWithDeviceRed:0.35 green:0.35 blue:0.35 alpha:1]];
+        titleColor = [NSColor whiteColor];
+    } else {
+        gradient = [[NSGradient alloc] initWithStartingColor:[NSColor colorWithDeviceRed:0.75 green:0.75 blue:0.75 alpha:1]
+                                                 endingColor:[NSColor colorWithDeviceRed:0.55 green:0.55 blue:0.55 alpha:1]];
+        titleColor = [NSColor disabledControlTextColor];
+    }
+
+    [gradient drawInBezierPath:self->outline angle:270];
+    [gradient release];
+
+    [[NSColor colorWithDeviceRed:0.5 green:0.5 blue:0.5 alpha:1.0] setStroke];
+
+    [self->outline stroke];
+
+    NSString* title = [[self window] title];
+
+    NSFont* titleFont = [NSFont titleBarFontOfSize:0];
+    NSMutableParagraphStyle* paraStyle = [[[NSMutableParagraphStyle alloc] init] autorelease];
+    [paraStyle setParagraphStyle:[NSParagraphStyle defaultParagraphStyle]];
+    [paraStyle setAlignment:NSCenterTextAlignment];
+    [paraStyle setLineBreakMode:NSLineBreakByTruncatingTail];
+    NSMutableDictionary* titleAttrs = [NSMutableDictionary dictionaryWithObjectsAndKeys:titleFont, NSFontAttributeName,
+                                                           titleColor, NSForegroundColorAttributeName,
+                                                           [[paraStyle copy] autorelease], NSParagraphStyleAttributeName,
+                                                           nil];
+
+    [title drawInRect:titlebarRect withAttributes:titleAttrs];
+}
+
+- (BOOL)acceptsFirstMouse:(NSEvent *)theEvent
+{
+    (void)theEvent;
+    return YES;
+}
+
+- (void)mouseDown:(NSEvent *)event
+{
+    NSWindow *window = [self window];
+    NSPoint inWindow = [event locationInWindow];
+    inWindow.y = [self bounds].size.height - inWindow.y;
+    if (inWindow.y > TITLEBAR_HEIGHT)
+        return;
+    NSPoint originalMouseLocation = [window convertRectToScreen:makeRect([event locationInWindow])].origin;
+    NSRect originalFrame = [window frame];
+
+    for (;;) {
+        NSEvent *newEvent = [window nextEventMatchingMask:(NSLeftMouseDraggedMask | NSLeftMouseUpMask)];
+
+        if ([newEvent type] == NSLeftMouseUp)
+            break;
+
+        NSPoint newMouseLocation = [window convertRectToScreen:makeRect([newEvent locationInWindow])].origin;
+        NSPoint delta = NSMakePoint(
+            newMouseLocation.x - originalMouseLocation.x,
+            newMouseLocation.y - originalMouseLocation.y);
+
+        NSRect newFrame = originalFrame;
+
+        newFrame.origin.x += delta.x;
+        newFrame.origin.y += delta.y;
+        [window setFrame:newFrame display:YES animate:NO];
+    }
+}
+@end
+
+@interface GibbonWindow : NSWindow {
+@public
+    NSView* childContentView;
+    NSWindow* glWindow;
+}
+@end
+
+@implementation GibbonWindow
+- (id) initWithContentRect:(NSRect)contentRect
+                 styleMask:(NSUInteger)windowStyle
+                   backing:(NSBackingStoreType)bufferingType
+                     defer:(BOOL)deferCreation
+{
+    (void)windowStyle;
+    self = [super initWithContentRect:contentRect
+                            styleMask:NSBorderlessWindowMask
+                              backing:bufferingType
+                                defer:deferCreation];
+    if (self) {
+        [self setOpaque:NO];
+        [self setBackgroundColor:[NSColor clearColor]];
+        self->childContentView = 0;
+        self->glWindow = 0;
+    }
+    return self;
+}
+
+- (void)setContentView:(NSView *)aView
+{
+    if ([childContentView isEqualTo:aView])
+        return;
+
+    NSRect bounds = [self frame];
+    bounds.origin = NSZeroPoint;
+
+    GibbonFrame* frame = [super contentView];
+    if (!frame) {
+        GibbonFrame* frame = [[[GibbonFrame alloc] initWithFrame:bounds] autorelease];
+        [super setContentView:frame];
+    }
+    if (!glWindow) {
+        glWindow = [[NSWindow alloc] initWithContentRect:[self contentRectForFrameRect:bounds]
+                                               styleMask:NSBorderlessWindowMask // (NSResizableWindowMask | NSClosableWindowMask | NSTitledWindowMask | NSMiniaturizableWindowMask)
+                                                 backing:NSBackingStoreBuffered defer:NO];
+        [self addChildWindow:glWindow ordered:NSWindowAbove];
+    }
+
+    if (childContentView)
+        [childContentView removeFromSuperview];
+    childContentView = aView;
+    // [childContentView setFrame:[self contentRectForFrameRect:bounds]];
+    // [childContentView setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
+    // [frame addSubview:childContentView];
+    [glWindow setContentView:childContentView];
+}
+
+- (NSRect)contentRectForFrameRect:(NSRect)windowFrame
+{
+    windowFrame.origin = [super contentRectForFrameRect:windowFrame].origin;
+    windowFrame.size.height -= TITLEBAR_HEIGHT;
+    return windowFrame;
+}
+
+- (void)updateFrame:(BOOL)enabled
+{
+    GibbonFrame* frame = [super contentView];
+    if (frame)
+        [frame updateFrame:enabled];
+}
+
++ (NSRect)frameRectForContentRect:(NSRect)windowContentRect
+                        styleMask:(NSUInteger)windowStyle
+{
+    (void)windowStyle;
+    windowContentRect.origin = [NSWindow frameRectForContentRect:windowContentRect styleMask:windowStyle].origin;
+    windowContentRect.size.height += TITLEBAR_HEIGHT;
+    return windowContentRect;
+}
+
+- (BOOL) canBecomeKeyWindow { return YES; }
+- (BOOL) canBecomeMainWindow { return YES; }
+@end
+
+@interface GibbonWindowDelegate : NSObject<NSWindowDelegate> {
+}
+@end
+
+@implementation GibbonWindowDelegate
+- (void)windowDidBecomeKey:(NSNotification *)notification
+{
+    GibbonWindow* win = notification.object;
+    if (win)
+        [win updateFrame:YES];
+    [[NSRunningApplication currentApplication] activateWithOptions:(NSApplicationActivateAllWindows | NSApplicationActivateIgnoringOtherApps)];
+}
+
+- (void)windowDidResignKey:(NSNotification *)notification
+{
+    GibbonWindow* win = notification.object;
+    if (win)
+        [win updateFrame:NO];
+}
+
+- (BOOL)windowShouldClose:(NSNotification *)notification
+{
+    (void)notification;
+    if (NrdApplication* na = nrdApp()) {
+        na->scheduleQuit();
+        return NO;
+    }
+    return YES;
+}
+@end
+
+static GibbonWindow* sWindow;
+static GibbonView* sView;
+static NSOpenGLContext* sContext;
+static NSOpenGLPixelFormat* sFormat;
+
+void OpenGLContext::createWindow()
+{
+    ScopedPool pool;
+    NSApplication* app = [NSApplication sharedApplication];
+
+    GibbonNSApplicationDelegate* delegate = [[[GibbonNSApplicationDelegate alloc] init] retain];
+    [app setDelegate:delegate];
+
+    [app setActivationPolicy:NSApplicationActivationPolicyRegular];
+    [app finishLaunching];
+
+    const unsigned int width = GibbonConfiguration::screenWidth();
+    const unsigned int height = GibbonConfiguration::screenHeight();
+
+    NSRect rect = NSMakeRect(0, 0, width, height);
+    sWindow = [[GibbonWindow alloc] initWithContentRect:rect
+                                              styleMask:NSBorderlessWindowMask // (NSResizableWindowMask | NSClosableWindowMask | NSTitledWindowMask | NSMiniaturizableWindowMask)
+                                                backing:NSBackingStoreBuffered defer:NO];
+    [sWindow setDelegate:[[GibbonWindowDelegate alloc] init]];
+    [sWindow setAcceptsMouseMovedEvents:YES];
+    [sWindow setTitle:@"Gibbon GL"];
+    [sWindow retain];
+
+    // NSView* contentView = [window contentView];
+    // [contentView setAutoresizesSubviews:YES];
+
+    const NSOpenGLPixelFormatAttribute targetSamples = GibbonConfiguration::multisampleBuffers();
+    NSOpenGLPixelFormatAttribute pixelFormatAttributes[] = {
+        //NSOpenGLPFAOpenGLProfile, NSOpenGLProfileVersion3_2Core,
+        NSOpenGLPFAOpenGLProfile, NSOpenGLProfileVersionLegacy ,
+        NSOpenGLPFAColorSize    , 24                           ,
+        NSOpenGLPFAAlphaSize    , 8                            ,
+        NSOpenGLPFASampleBuffers, NSOpenGLPixelFormatAttribute(targetSamples ? 1 : 0),
+        NSOpenGLPFASamples      , targetSamples                ,
+        NSOpenGLPFADepthSize    , 24                           ,
+        NSOpenGLPFASampleAlpha  ,
+        NSOpenGLPFAMultisample  ,
+        NSOpenGLPFADoubleBuffer ,
+        NSOpenGLPFAAccelerated  ,
+        NSOpenGLPFANoRecovery   ,
+        0 };
+    sFormat = [[[NSOpenGLPixelFormat alloc] initWithAttributes:pixelFormatAttributes] retain];
+    sView = [[[GibbonView alloc] initWithFrame:rect] retain];
+
+    [sView setPixelFormat:sFormat];
+
+    [sWindow setContentView:sView];
+    //[contentView addSubview:glview];
+
+#if 1
+    if (GibbonConfiguration::useCurrentSpace()) {
+        [sWindow setCollectionBehavior:NSWindowCollectionBehaviorMoveToActiveSpace];
+        [app activateIgnoringOtherApps:NO];
+    }
+    if (GibbonConfiguration::takeFocus()) {
+        [app activateIgnoringOtherApps:YES];
+    }
+#endif
+
+    [sWindow makeKeyAndOrderFront:sWindow];
+}
+
+bool OpenGLContext::init_sys(OpenGLContext* share)
+{
+    ScopedPool pool;
+    sContext = [[NSOpenGLContext alloc] initWithFormat:sFormat shareContext:nil];
+    [sView setOpenGLContext:sContext];
+
+    mPrivate = new OpenGLContextPrivate;
+    memset(mPrivate, '\0', sizeof(OpenGLContextPrivate));
+    if (!share) {
+        assert(sWindow);
+        // assert(!sContext);
+        mPrivate->win = sWindow;
+        //mPrivate->ctx = [sContext retain];
+        mPrivate->fmt = [sFormat retain];
+        mPrivate->ctx = sContext;
+
+        [mPrivate->ctx makeCurrentContext];
+    } else {
+        // create a new shared context
+        mPrivate->win = 0;
+        mPrivate->ctx = [[[NSOpenGLContext alloc] initWithFormat:share->mPrivate->fmt shareContext:share->mPrivate->ctx] autorelease];
+        mPrivate->fmt = share->mPrivate->fmt;
+        [mPrivate->ctx retain];
+        [mPrivate->fmt retain];
+        [mPrivate->ctx makeCurrentContext];
+    }
+    return true;
+}
+
+void OpenGLContext::cleanup_sys()
+{
+    [mPrivate->ctx release];
+    [mPrivate->fmt release];
+    delete mPrivate;
+    mPrivate = 0;
+}
+
+void OpenGLContext::focus_sys()
+{
+}
+
+void OpenGLContext::graphicsInfo_sys(Variant& /*variant*/)
+{
+}
+
+void OpenGLContext::flip()
+{
+    [mPrivate->ctx flushBuffer];
+}
+
+std::shared_ptr<OpenGLDisplay> OpenGLContext::display()
+{
+    return std::shared_ptr<OpenGLDisplay>();
+}
+
+void* OpenGLContext::procAddr(const std::string& proc)
+{
+    static CFBundleRef openGLBundle = 0;
+    if (!openGLBundle) {
+        openGLBundle = CFBundleGetBundleWithIdentifier(CFSTR("com.apple.opengl"));
+    }
+
+    void* function = 0;
+
+    CFStringRef functionName = CFStringCreateWithCString(kCFAllocatorDefault, proc.c_str(), kCFStringEncodingASCII);
+    if (functionName) {
+        function = CFBundleGetFunctionPointerForName(openGLBundle, functionName);
+        CFRelease(functionName);
+    }
+
+    return function;
+}
+
+bool OpenGLContext::supportsPlatformExtension(const std::string& /*ext*/)
+{
+    return false;
+}
+
+void* OpenGLContext::osxWindowHandle()
+{
+    return mPrivate->win;
+}
diff --git a/partner/graphics/rpi/OpenGLFBO.cpp b/partner/graphics/rpi/OpenGLFBO.cpp
new file mode 100644
index 00000000..8c329c6b
--- /dev/null
+++ b/partner/graphics/rpi/OpenGLFBO.cpp
@@ -0,0 +1,243 @@
+/* (c) 2014 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+
+#include "OpenGLFBO.h"
+#include "OpenGLContext.h"
+#include "OpenGLState.h"
+#include <nrd/AppLog.h>
+
+using namespace netflix;
+using namespace netflix::gibbon;
+
+static bool sFboInited = false;
+OpenGLFBO::Cache OpenGLFBO::sFbos;
+
+NRDP_DEFINE_OBJECTCOUNT(OpenGLFBO);
+
+OpenGLFBO::OpenGLFBO(const Surface::SharedPtr &surface, Flags<GraphicsEngine::Buffer> buffers) : mValid(true), mBuffers(buffers), mClearFields(0)
+{
+    assert(surface->isValid());
+    NRDP_OBJECTCOUNT_REF(OpenGLFBO, this);
+    init(surface->getTexture(), surface->getSize());
+}
+
+OpenGLFBO::OpenGLFBO(GLuint texture, const Size &size, Flags<GraphicsEngine::Buffer> buffers) : mValid(true), mBuffers(buffers), mClearFields(0)
+{
+    NRDP_OBJECTCOUNT_REF(OpenGLFBO, this);
+    init(texture, size);
+}
+
+OpenGLFBO::~OpenGLFBO()
+{
+    NRDP_OBJECTCOUNT_DEREF(OpenGLFBO, this);
+    if(!mValid)
+        return;
+
+    if(!mRb.empty())
+        glDeleteRenderbuffers(mRb.size(), &mRb[0]);
+    glDeleteFramebuffers(1, &mFbo);
+    NRDP_OBJECTCOUNT_DEREF(OpenGLResourceFBO, mFbo);
+}
+
+static inline bool matches(const OpenGLFBO::SharedPtr &fbo, const Size &size, Flags<GraphicsEngine::Buffer> buffers)
+{
+    if(fbo.use_count() == 1 && fbo->buffers() == buffers && fbo->width() == size.width && fbo->height() == size.height)
+        return true;
+    return false;
+}
+
+OpenGLFBO::SharedPtr OpenGLFBO::take(GLuint texture, const Size &size, Flags<GraphicsEngine::Buffer> buffers)
+{
+    assert(Animation::isAnimationThread());
+    Cache::iterator it = sFbos.begin();
+    while (it != sFbos.end()) {
+        if(matches(*it, size, buffers)) {
+            (*it)->setTexture(texture);
+            return *it;
+        }
+        ++it;
+    }
+    SharedPtr ptr(new OpenGLFBO(texture, size, buffers));
+    if(sFbos.maximumSize() && ptr->mValid && !sFbos.insert(ptr.get(), ptr).second) {
+        Log::error(TRACE_GIBBON_GRAPHICS, "FBO cache over budget (%s, 0x%x)",
+                   ptr->size().toString().c_str(), buffers.cast<uint32_t>());
+    }
+    return ptr;
+}
+
+void OpenGLFBO::setTexture(GLuint tex)
+{
+    assert(mValid);
+    OpenGLState *state = OpenGLContext::context()->state();
+    state->bindFramebuffer(mFbo);
+    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, tex, 0);
+    if(tex)
+        clearBuffers(state);
+    else
+        state->bindFramebuffer(0);
+}
+
+GLenum OpenGLFBO::generate(GLuint tex, Coordinate width, Coordinate height, unsigned int flags)
+{
+    assert(tex);
+    if(!tex)
+        return GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT;
+
+    OpenGLState *state = OpenGLContext::context()->state();
+    state->unbindTexture(tex);
+    glGenFramebuffers(1, &mFbo);
+    NRDP_OBJECTCOUNT_REF(OpenGLResourceFBO, mFbo);
+    state->bindFramebuffer(mFbo);
+    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, tex, 0);
+
+    mClearFields = 0;
+
+    if(flags & DepthStencil) {
+        mRb.resize(1);
+        glGenRenderbuffers(mRb.size(), &mRb[0]);
+        glBindRenderbuffer(GL_RENDERBUFFER, mRb[0]);
+#if defined(GL_DEPTH24_STENCIL8_OES)
+        if(OpenGLContext::supportsExtension("GL_OES_packed_depth_stencil"))
+            glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8_OES, width, height);
+#elif defined(GL_DEPTH24_STENCIL8)
+        if(OpenGLContext::supportsExtension("GL_EXT_packed_depth_stencil"))
+            glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, width, height);
+#endif
+        glBindRenderbuffer(GL_RENDERBUFFER, 0);
+        glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, mRb[0]);
+        glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, mRb[0]);
+
+        mClearFields |= GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT;
+    } else {
+        if(flags & Depth) {
+            assert(mRb.empty());
+            mRb.resize(1);
+            GLuint& rb = mRb.back();
+            glGenRenderbuffers(1, &rb);
+
+            GLenum format = 0;
+            if(GibbonConfiguration::fboDepth() == 16) {
+                format = GL_DEPTH_COMPONENT16;
+            } else if(GibbonConfiguration::fboDepth() == 24) {
+#ifdef GL_DEPTH_COMPONENT24
+                format = GL_DEPTH_COMPONENT24;
+#endif
+#ifdef GL_OES_depth24
+                if(!format && OpenGLContext::supportsExtension("GL_OES_depth24"))
+                    format = GL_DEPTH_COMPONENT24_OES;
+#endif
+            } else if(GibbonConfiguration::fboDepth() == 32) {
+#ifdef GL_DEPTH_COMPONENT32
+                format = GL_DEPTH_COMPONENT32;
+#endif
+#ifdef GL_OES_depth32
+                if(!format && OpenGLContext::supportsExtension("GL_OES_depth232"))
+                    format = GL_DEPTH_COMPONENT32_OES;
+#endif
+            }
+            if(!format) {
+                Log::error(TRACE_GIBBON_GRAPHICS, "Unable to understand FBO depth: %lld", GibbonConfiguration::fboDepth());
+                format = GL_DEPTH_COMPONENT16;
+            }
+
+            glBindRenderbuffer(GL_RENDERBUFFER, rb);
+            glRenderbufferStorage(GL_RENDERBUFFER, format, width, height);
+            glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_ATTACHMENT, GL_RENDERBUFFER, rb);
+
+            mClearFields |= GL_DEPTH_BUFFER_BIT;
+        }
+        if(flags & Stencil) {
+            mRb.resize(mRb.size() + 1);
+            GLuint& rb = mRb.back();
+            glGenRenderbuffers(1, &rb);
+            glBindRenderbuffer(GL_RENDERBUFFER, rb);
+            glRenderbufferStorage(GL_RENDERBUFFER, GL_STENCIL_INDEX8, width, height);
+            glBindRenderbuffer(GL_RENDERBUFFER, 0);
+            glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rb);
+
+            mClearFields |= GL_STENCIL_BUFFER_BIT;
+        }
+    }
+
+    const GLenum fbstatus = glCheckFramebufferStatus(GL_FRAMEBUFFER);
+    if(fbstatus != GL_FRAMEBUFFER_COMPLETE) {
+        // flush any error if we got one
+        glGetError();
+
+        state->bindFramebuffer(0);
+        NRDP_OBJECTCOUNT_DEREF(OpenGLResourceFBO, mFbo);
+        glDeleteFramebuffers(1, &mFbo);
+        if(!mRb.empty())
+            glDeleteRenderbuffers(mRb.size(), &mRb[0]);
+        mFbo = 0;
+        mRb.clear();
+    } else {
+        clearBuffers(state);
+    }
+    return fbstatus;
+}
+
+inline unsigned int OpenGLFBO::tryFlags(unsigned int* flags)
+{
+    unsigned int* f = flags;
+    if((mBuffers & (GraphicsEngine::DepthBuffer|GraphicsEngine::StencilBuffer)) == (GraphicsEngine::DepthBuffer|GraphicsEngine::StencilBuffer)) {
+#if defined(GL_DEPTH24_STENCIL8_OES)
+        if(OpenGLContext::supportsExtension("GL_OES_packed_depth_stencil"))
+            *(f++) = DepthStencil;
+#elif defined(GL_DEPTH24_STENCIL8)
+        if(OpenGLContext::supportsExtension("GL_EXT_packed_depth_stencil"))
+            *(f++) = DepthStencil;
+#endif
+        *(f++) = Depth | Stencil;
+    } else if((mBuffers & GraphicsEngine::DepthBuffer) == GraphicsEngine::DepthBuffer) {
+        *(f++) = Depth;
+    } else if((mBuffers & GraphicsEngine::StencilBuffer) == GraphicsEngine::StencilBuffer) {
+        *(f++) = Stencil;
+    } else {
+        *(f++) = 0;
+    }
+    return f - flags;
+}
+
+void OpenGLFBO::init(GLuint tex, const Size &size)
+{
+    if(NRDP_UNLIKELY(!sFboInited)) {
+        sFboInited = true;
+        sFbos.setMaximumSize(GibbonConfiguration::fboCacheSize());
+    }
+    mSize = size;
+
+    OpenGLState *state = OpenGLContext::context()->state();
+
+    unsigned int flags[2];
+    const unsigned int ret = tryFlags(flags);
+
+    GL_ASSERT(state);
+    GLenum status = GL_FRAMEBUFFER_COMPLETE;
+    for(unsigned int idx = 0; idx < ret; ++idx) {
+        status = generate(tex, mSize.width, mSize.height, flags[idx]);
+        if(status == GL_FRAMEBUFFER_COMPLETE)
+            break;
+    }
+    if(status != GL_FRAMEBUFFER_COMPLETE) {
+        mValid = false;
+        std::string message;
+        switch (status) {
+        case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT:
+            message = "Incomplete attachment";
+            break;
+        case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:
+            message = "Missing attachment";
+            break;
+        case GL_FRAMEBUFFER_UNSUPPORTED:
+            message = "Unsupported framebuffer";
+            break;
+        default:
+            message = StringFormatter::sformat("Unknown status: 0x%x", status);
+            break;
+        }
+        Log::error(TRACE_GIBBON_GRAPHICS, "Couldn't create FBO: %s (tex %u, rect %s)",
+                   message.c_str(), tex, mSize.toString().c_str());
+    }
+    GL_ASSERT(state);
+}
+
diff --git a/partner/graphics/rpi/OpenGLFBO.h b/partner/graphics/rpi/OpenGLFBO.h
new file mode 100644
index 00000000..f619c51e
--- /dev/null
+++ b/partner/graphics/rpi/OpenGLFBO.h
@@ -0,0 +1,109 @@
+/* (c) 2014 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+
+#ifndef OPENGLFBO_H
+#define OPENGLFBO_H
+
+#include <vector>
+#include <Surface.h>
+#include <GibbonConfiguration.h>
+#include <GraphicsEngine.h>
+#include <OpenGLState.h>
+#include <nrdbase/tr1.h>
+#include <nrdbase/LRU.h>
+#include <assert.h>
+
+namespace netflix {
+namespace gibbon {
+
+class OpenGLFBO : public std::enable_shared_from_this<OpenGLFBO>
+{
+public:
+    typedef std::shared_ptr<OpenGLFBO> SharedPtr;
+    typedef std::weak_ptr<OpenGLFBO> WeakPtr;
+
+    OpenGLFBO(GLuint texture, const Size &size, Flags<GraphicsEngine::Buffer> buffers);
+    OpenGLFBO(const Surface::SharedPtr &surface, Flags<GraphicsEngine::Buffer> buffers);
+    ~OpenGLFBO();
+
+    bool isValid() const { return mValid; }
+    Coordinate width() const { return mSize.width; }
+    Coordinate height() const { return mSize.height; }
+    Size size() const { return mSize; }
+    GLuint fbo() const { return mFbo; }
+    Flags<GraphicsEngine::Buffer> buffers() const { return mBuffers; }
+    size_t renderBufferCount() const { return mRb.size(); }
+    inline void unbind() { setTexture(0); }
+
+    static SharedPtr take(GLuint texture, const Size &size, Flags<GraphicsEngine::Buffer> buffers);
+    static SharedPtr take(const Surface::SharedPtr &surface, Flags<GraphicsEngine::Buffer> buffers) {
+        return take(surface->getTexture(), surface->getSize(), buffers);
+    }
+    static void cleanup();
+
+private:
+    void init(GLuint tex, const Size &size);
+    void setTexture(GLuint tex);
+
+    enum GenerateFlags {
+        DepthStencil = 0x1,
+        Depth        = 0x2,
+        Stencil      = 0x4
+    };
+    GLenum generate(GLuint tex, Coordinate width, Coordinate height, unsigned int flags);
+
+private:
+    friend class OpenGLContext;
+
+    unsigned int tryFlags(unsigned int* flags);
+    void clearBuffers(OpenGLState* state);
+
+    GLuint mFbo;
+    std::vector<GLuint> mRb;
+    Size mSize;
+    bool mValid;
+    Flags<GraphicsEngine::Buffer> mBuffers;
+    GLbitfield mClearFields;
+
+    struct PurgeAllow
+    {
+        bool operator()(const SharedPtr &ptr)
+        {
+            return ptr.use_count() == 1;
+        }
+    };
+
+    struct Cost
+    {
+        size_t operator()(const SharedPtr& fbo)
+        {
+            const Size &sz = fbo->size();
+            return sz.width * sz.height * (fbo->renderBufferCount() ? 8 : 4);
+        }
+    };
+
+    typedef LRU<OpenGLFBO*, SharedPtr, Cost, PurgeAllow> Cache;
+
+    static Cache sFbos;
+};
+
+inline void OpenGLFBO::cleanup()
+{
+    assert(sFbos.currentSize() <= static_cast<size_t>(GibbonConfiguration::fboCacheSize()));
+    sFbos.clear();
+}
+
+inline void OpenGLFBO::clearBuffers(OpenGLState *state)
+{
+    if (!mClearFields)
+        return;
+    const bool hasClip = state->capEnabled(GL_SCISSOR_TEST);
+    if (hasClip)
+        glDisable(GL_SCISSOR_TEST);
+    glClear(mClearFields);
+    if (hasClip)
+        glEnable(GL_SCISSOR_TEST);
+}
+
+}} // namespace netflix::gibbon
+
+#endif
diff --git a/partner/graphics/rpi/OpenGLFloats.h b/partner/graphics/rpi/OpenGLFloats.h
new file mode 100644
index 00000000..d6615407
--- /dev/null
+++ b/partner/graphics/rpi/OpenGLFloats.h
@@ -0,0 +1,38 @@
+/* (c) 2014 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+#ifndef OPENGLFLOATS_H
+#define OPENGLFLOATS_H
+
+#include <Surface.h>
+#include <stdlib.h>
+
+struct OpenGLFloats
+{
+public:
+    inline OpenGLFloats() : b(0), idx(0), size(0) { reserve(5000); }
+    inline ~OpenGLFloats() { free(b); }
+
+    inline GLfloat* base() const { return b; }
+    inline void reset() { idx = base(); }
+
+    void reserve(size_t sz)
+    {
+        if (size >= sz)
+            return;
+        idx = b = static_cast<GLfloat*>(realloc(b, sz * sizeof(GLfloat)));
+        size = sz;
+    }
+
+    GLfloat* take(size_t sz)
+    {
+        GLfloat* cur = idx;
+        idx += sz;
+        return cur;
+    }
+
+private:
+    GLfloat* b;
+    GLfloat* idx;
+    size_t size;
+};
+
+#endif
diff --git a/partner/graphics/rpi/OpenGLShaders.cpp b/partner/graphics/rpi/OpenGLShaders.cpp
new file mode 100644
index 00000000..d834fc66
--- /dev/null
+++ b/partner/graphics/rpi/OpenGLShaders.cpp
@@ -0,0 +1,241 @@
+/* (c) 2016 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+
+#include "OpenGLShaders.h"
+
+#include <nrdbase/Dumper.h>
+
+using namespace netflix;
+using namespace netflix::gibbon;
+
+NRDP_DEFINE_OBJECTCOUNT_RECORD(OpenGLShaderObjectCount, OpenGLShaders);
+std::string OpenGLShaderObjectCount::describe(const void *object) const
+{
+    return static_cast<const OpenGLProgram*>(object)->name();
+}
+
+std::weak_ptr<OpenGLShader> OpenGLShader::sCurrentShader;
+OpenGLShaders::ProgramCache OpenGLShaders::sProgramCache;
+std::map<LineShader::Features, std::shared_ptr<LineShader> > OpenGLShaders::sLineShaders;
+std::map<FillShader::Features, std::shared_ptr<FillShader> > OpenGLShaders::sFillShaders;
+std::map<VBOShader::Features, std::shared_ptr<VBOShader> > OpenGLShaders::sVBOShaders;
+std::map<TextureShader::Features, std::shared_ptr<TextureShader> > OpenGLShaders::sTextureShaders;
+
+namespace netflix {
+namespace gibbon {
+
+class OpenGLShadersDumper : public Dumper
+{
+public:
+    OpenGLShadersDumper() {}
+
+    void setProgram(const std::shared_ptr<OpenGLProgram> &program) { mProgram = program; }
+    std::shared_ptr<OpenGLProgram> program() const { return mProgram; }
+
+protected:
+    virtual std::vector<std::string> consoleEntry(const unsigned int idx, const std::string &section, const Variant &value) override;
+    std::shared_ptr<OpenGLProgram> mProgram;
+};
+
+}}
+
+OpenGLShader::OpenGLShader(OpenGLContext *ctx, const GLchar *vertex, const GLchar *fragment, const std::string &_name) : mContext(ctx), mName(_name)
+{
+    if(mName.empty())
+        mName = OpenGLProgram::hash(vertex, fragment);
+    const std::string nameStr = name();
+    mProgram = OpenGLShaders::findProgramByName(nameStr);
+    if(!mProgram) {
+        mProgram.reset(new OpenGLProgram(ctx, vertex, fragment, nameStr));
+        OpenGLShaders::cacheProgram(nameStr, mProgram);
+    }
+}
+
+void OpenGLShader::generate()
+{
+    const std::string nameStr = name();
+    mProgram = OpenGLShaders::findProgramByName(nameStr);
+    if(!mProgram) {
+        std::string vstr = vertexDeclarations();
+        vstr += "void main() {\n";
+        vstr += vertexBody();
+        vstr += "  gl_Position = (u_projectionMatrix * u_mvMatrix) * gl_Position;\n"
+                "}\n";
+
+        std::string fstr =
+            "#ifdef GL_ES\n"
+            "precision highp float;\n"
+            "#endif\n";
+        fstr += fragmentDeclarations();
+        fstr += ("void main() {\n" +
+                 fragmentBody() +
+                 "}\n");
+
+        mProgram.reset(new OpenGLProgram(context(), vstr.c_str(), fstr.c_str(), nameStr));
+
+        if(GibbonDebug::DebugGLState) {
+            Log::error(TRACE_LOG, "Generated Program[%s]: %p(%s) [%s]", nameStr.c_str(), mProgram.get(),
+                       mProgram->isValid() ? "valid" : mProgram->error().c_str(), describe().c_str());
+            Log::error(TRACE_LOG, "  Vertex: %s", vstr.c_str());
+            Log::error(TRACE_LOG, "  Fragment: %s", fstr.c_str());
+        }
+
+        OpenGLShaders::cacheProgram(nameStr, mProgram);
+
+        mProgram->use();
+        define();
+        GL_ASSERT(context()->state());
+    }
+    setup();
+    GL_ASSERT(context()->state());
+}
+
+std::shared_ptr<LineShader> LineShader::create(OpenGLContext *context, Features features)
+{
+    OpenGLShader::Parts vertexes, fragments;
+    if(features & LineShader::Feature_Convert_709TO2020)
+        fragments.push_back(std::shared_ptr<OpenGLShader::Part>(new RGBConvertPart(RGBConvertPart::Conversion_BT709ToPQ2020)));
+    return std::shared_ptr<LineShader>(new LineShader(context, vertexes, fragments, features));
+}
+
+std::shared_ptr<FillShader> FillShader::create(OpenGLContext *context, Features features)
+{
+    OpenGLShader::Parts vertexes, fragments;
+    if(features & FillShader::Feature_Convert_709TO2020)
+        fragments.push_back(std::shared_ptr<OpenGLShader::Part>(new RGBConvertPart(RGBConvertPart::Conversion_BT709ToPQ2020)));
+    return std::shared_ptr<FillShader>(new FillShader(context, vertexes, fragments, features));
+}
+
+std::shared_ptr<TextureShader> TextureShader::create(OpenGLContext *context, Features features)
+{
+    OpenGLShader::Parts vertexes, fragments;
+    {
+        RGBConvertPart::Conversion conversion = RGBConvertPart::Conversion_None;
+        if(features & TextureShader::Feature_Convert_709TO2020)
+            conversion = RGBConvertPart::Conversion_BT709ToPQ2020;
+        else if(features & TextureShader::Feature_Convert_2020TO709)
+            conversion = RGBConvertPart::Conversion_PQ2020ToBT709;
+        fragments.push_back(std::shared_ptr<OpenGLShader::Part>(new RGBConvertPart(conversion)));
+    }
+    fragments.push_back(std::shared_ptr<OpenGLShader::Part>(new TextureShader::RGBPart));
+    if(features & (TextureShader::Feature_Mask_AlphaOnly|TextureShader::Feature_Mask)) {
+        if(features & TextureShader::Feature_Mask_AlphaOnly)
+            fragments.push_back(std::shared_ptr<OpenGLShader::Part>(new TextureShader::MaskPart(TextureShader::MaskPart::Mode_Alpha)));
+        else
+            fragments.push_back(std::shared_ptr<OpenGLShader::Part>(new TextureShader::MaskPart(TextureShader::MaskPart::Mode_RGB)));
+    }
+    if(features & TextureShader::Feature_Colorize)
+        fragments.push_back(std::shared_ptr<OpenGLShader::Part>(new TextureShader::ColorizePart));
+    return std::shared_ptr<TextureShader>(new TextureShader(context, vertexes, fragments, features));
+}
+
+std::shared_ptr<VBOShader> VBOShader::create(OpenGLContext *context, Features features)
+{
+    OpenGLShader::Parts vertexes, fragments;
+    {
+        RGBConvertPart::Conversion conversion = RGBConvertPart::Conversion_None;
+        if(features & VBOShader::Feature_Convert_709TO2020)
+            conversion = RGBConvertPart::Conversion_BT709ToPQ2020;
+        else if(features & VBOShader::Feature_Convert_2020TO709)
+            conversion = RGBConvertPart::Conversion_PQ2020ToBT709;
+        fragments.push_back(std::shared_ptr<OpenGLShader::Part>(new RGBConvertPart(conversion)));
+    }
+    if(features & VBOShader::Feature_AlphaOnly)
+        fragments.push_back(std::shared_ptr<OpenGLShader::Part>(new VBOShader::AlphaOnlyPart));
+    else if(features & VBOShader::Feature_Bicubic)
+        fragments.push_back(std::shared_ptr<OpenGLShader::Part>(new VBOShader::RGBBicubicPart));
+    else
+        fragments.push_back(std::shared_ptr<OpenGLShader::Part>(new VBOShader::RGBPart));
+    if(features & (VBOShader::Feature_Mask_AlphaOnly|VBOShader::Feature_Mask)) {
+        if(features & VBOShader::Feature_Mask_AlphaOnly)
+            fragments.push_back(std::shared_ptr<OpenGLShader::Part>(new VBOShader::MaskPart(VBOShader::MaskPart::Mode_Alpha)));
+        else
+            fragments.push_back(std::shared_ptr<OpenGLShader::Part>(new VBOShader::MaskPart(VBOShader::MaskPart::Mode_RGB)));
+    }
+    if(features & VBOShader::Feature_Colorize)
+        fragments.push_back(std::shared_ptr<OpenGLShader::Part>(new VBOShader::ColorizePart));
+    return std::shared_ptr<VBOShader>(new VBOShader(context, vertexes, fragments, features));
+}
+
+void OpenGLShaders::init(OpenGLContext *)
+{
+    sProgramCache.setMaximumSize(GibbonConfiguration::shaderCacheCapacity());
+    sProgramCache.setFlag(ProgramCache::Burstable);
+ }
+
+void OpenGLShaders::cleanup()
+{
+    sFillShaders.clear();
+    sLineShaders.clear();
+    sTextureShaders.clear();
+    sVBOShaders.clear();
+
+    std::vector<OpenGLProgram::WeakPtr> programs;
+    for(ProgramCache::const_iterator it = sProgramCache.begin(); it != sProgramCache.end(); ++it)
+        programs.push_back(*it);
+    sProgramCache.clear();
+    for(std::vector<OpenGLProgram::WeakPtr>::const_iterator it = programs.begin(); it != programs.end(); ++it) {
+        if(OpenGLProgram::SharedPtr p = it->lock()) {
+            Log::info(TRACE_GIBBON_GRAPHICS, "OpenGLProgram:%s: left alive!", p->name().c_str());
+        }
+    }
+}
+
+std::vector<std::string> OpenGLShadersDumper::consoleEntry(const unsigned int /*idx*/, const std::string& /*section*/, const Variant& value)
+{
+    std::vector<std::string> ret;
+    const GLuint program = value["program"].integer();
+    if(program)
+        ret.push_back(StringFormatter::sformat(" [%lld] [%p] program:%lld %s",
+                                               value["idx"].integer(),
+                                               value["ptr"].pointer(),
+                                               value["program"].integer(),
+                                               value["name"].string().c_str()));
+    else
+        ret.push_back(StringFormatter::sformat(" [%lld] [%p] %s [%s]",
+                                               value["idx"].integer(),
+                                               value["ptr"].pointer(),
+                                               value["name"].string().c_str(),
+                                               value["error"].string().c_str()));
+    return ret;
+}
+
+std::shared_ptr<OpenGLShadersDumper> OpenGLShaders::dumper(const DumpInfo &dump)
+{
+    std::shared_ptr<OpenGLShadersDumper> dumper(new OpenGLShadersDumper);
+    dumper->keys() << "idx" << "ptr" << "name" << "program" << "error";
+
+    Dumper &d = *dumper;
+    if(!(dump.flags & DumpInfo::NoValues)) {
+        int index = 0, matched = 0;
+        for(ProgramCache::const_iterator it = sProgramCache.begin(); it != sProgramCache.end(); ++it) {
+            const std::shared_ptr<OpenGLProgram> &p = *it;
+            enum { Matched, MatchedDump, NotMatched } match = NotMatched;
+            if(index == dump.idx || p.get() == dump.ptr) {
+                match = MatchedDump;
+            } else if((!dump.ptr && dump.idx == -1 && !dump.match.length()) || (dump.match.length() && contains(p->name(), dump.match))) {
+                match = Matched;
+            }
+            if(match != NotMatched) {
+                dumper->values() << index << p.get() << p->name() << p->program() << p->error();
+                if(match == MatchedDump)
+                    dumper->setProgram(p);
+                ++matched;
+            }
+            ++index;
+        }
+        d["matched"] = matched;
+    }
+    return dumper;
+}
+
+void OpenGLShaders::dump(const DumpInfo &dump)
+{
+    std::shared_ptr<OpenGLShadersDumper> d = dumper(dump);
+    const std::vector<std::string>& data = d->toConsole();
+    for(std::vector<std::string>::const_iterator it = data.begin(); it != data.end(); ++it)
+        Log::warn(TRACE_GIBBON_GRAPHICS, "%s", it->c_str());
+    if(std::shared_ptr<OpenGLProgram> program = d->program()) {
+        Log::warn(TRACE_GIBBON_GRAPHICS, "************************ Vertex **********************\n%s\n", program->vertexShader().toString().c_str());
+        Log::warn(TRACE_GIBBON_GRAPHICS, "************************ Fragment **********************\n%s\n", program->fragmentShader().toString().c_str());
+    }
+}
diff --git a/partner/graphics/rpi/OpenGLShaders.h b/partner/graphics/rpi/OpenGLShaders.h
new file mode 100644
index 00000000..84322105
--- /dev/null
+++ b/partner/graphics/rpi/OpenGLShaders.h
@@ -0,0 +1,1292 @@
+/* (c) 2014 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+
+#ifndef OPENGLSHADERS_H
+#define OPENGLSHADERS_H
+
+#include <nrd/AppLog.h>
+#include <nrdbase/StringUtils.h>
+#include <nrdbase/BaseEncoding.h>
+#include <nrdbase/LRU.h>
+
+#ifdef GIBBON_GRAPHICSENGINE_GLES2_EGL
+# include <GLES2/gl2.h>
+# include <EGL/egl.h>
+# include <EGL/eglext.h>
+#endif
+
+#ifdef GIBBON_GRAPHICSENGINE_GLES2_IOS
+# include <OpenGLES/ES2/gl.h>
+#endif
+
+#ifdef GIBBON_GRAPHICSENGINE_GLES2_OSX
+# include <OpenGL/gl.h>
+#endif
+
+#ifdef GIBBON_GRAPHICSENGINE_GLES2_GLX
+# ifndef GL_GLEXT_PROTOTYPES
+#  define GL_GLEXT_PROTOTYPES 1
+# endif
+# include <GL/gl.h>
+# include <GL/glext.h>
+#endif
+
+#include <OpenGLContext.h>
+#include <OpenGLState.h>
+#include <OpenGLVBO.h>
+
+#include <openssl/md5.h>
+
+struct OpenGLShaderObjectCount : public netflix::ObjectCount::Record
+{
+public:
+    OpenGLShaderObjectCount(const std::string &n) : netflix::ObjectCount::Record(n) {}
+    virtual std::string describe(const void *object) const override;
+};
+NRDP_DECLARE_OBJECTCOUNT_RECORD(OpenGLShaderObjectCount, OpenGLShaders);
+
+struct OpenGLShaderProgramObjectCount : public netflix::ObjectCount::Record
+{
+public:
+    OpenGLShaderProgramObjectCount(const std::string &n) : netflix::ObjectCount::Record(n) {}
+    virtual std::string describe(const void *object) const override;
+};
+NRDP_DECLARE_OBJECTCOUNT_RECORD(OpenGLShaderProgramObjectCount, OpenGLShaderPrograms);
+
+namespace netflix {
+namespace gibbon {
+
+class OpenGLShader;
+class OpenGLContext;
+class OpenGLShadersDumper;
+
+class OpenGLProgram : public std::enable_shared_from_this<OpenGLProgram>
+{
+public:
+    typedef std::shared_ptr<OpenGLProgram> SharedPtr;
+    typedef std::weak_ptr<OpenGLProgram> WeakPtr;
+
+    virtual ~OpenGLProgram()
+    {
+        NRDP_OBJECTCOUNT_DEREF(OpenGLShaders, this);
+        invalidate();
+    }
+
+    inline operator GLuint() { return program(); }
+    inline GLuint program() const {
+        //assert(isValid());
+        return mProgram;
+    }
+
+    inline std::string describe() const {
+        StringBuilder result;
+        result << "Program(" << this << "):" << name();
+        if(isValid())
+            result << "[" << program() << "]";
+        else
+            result << error();
+        result << "VERTEX: " << mVertexShader;
+        result << "FRAGMENT: " << mFragmentShader;
+        return result.str();
+    }
+
+    inline void invalidate() {
+        if (mProgram)
+            OpenGLContext::deleteProgram(mProgram);
+    }
+    inline bool isValid() const { return mProgram != 0; }
+    inline std::string error() const { return mError; }
+
+    inline void reserveVariables(size_t pos)
+    {
+        mVariables.reserve(pos + 1);
+    }
+    inline GLint defineVariable(size_t pos, GLint location)
+    {
+        if(mVariables.size() <= pos)
+            mVariables.resize(pos + 1, -1);
+        mVariables[pos] = location;
+        return location;
+    }
+    inline GLint defineUniform(size_t pos, const char *name) { return defineVariable(pos, uniformLocation(name)); }
+    inline GLint defineAttribute(size_t pos, const char *name) { return defineVariable(pos, glGetAttribLocation(program(), name)); }
+
+    inline void defineUnused(size_t pos) { defineVariable(pos, 0); }
+    inline bool hasVariable(size_t pos) { return variable(pos) != -1; }
+    inline GLint variable(size_t pos) const { assert(pos < mVariables.size()); return mVariables[pos]; }
+    inline GLint uniformLocation(const std::string &name) {
+        std::map<std::string, GLint>::const_iterator found = mUniforms.find(name);
+        if(found == mUniforms.end()) {
+            const GLint location = glGetUniformLocation(program(), name.c_str());
+            mUniforms[name] = location;
+            return location;
+        }
+        return found->second;
+    }
+
+    inline void use() {
+        assert(isValid());
+        mContext->state()->useProgram(mProgram);
+    }
+
+    inline std::string name() const { return mName; }
+    inline OpenGLContext *context() const { return mContext; }
+
+    inline const DataBuffer vertexShader() const { return mVertexShader; }
+    inline const DataBuffer fragmentShader() const { return mFragmentShader; }
+
+    static inline std::string hash(const GLchar *vertex, const GLchar *fragment)
+    {
+        std::string result;
+
+        MD5_CTX ctx;
+        if(!MD5_Init(&ctx))
+            return result;
+        MD5_Update(&ctx, vertex, strlen(vertex));
+        MD5_Update(&ctx, fragment, strlen(fragment));
+
+        unsigned char digest[MD5_DIGEST_LENGTH];
+        if(MD5_Final(digest, &ctx)) {
+            result = Base64::encode<std::string>(digest, MD5_DIGEST_LENGTH);
+        }
+        return result;
+    }
+    static inline std::string hash(const std::string& vertex, const std::string& fragment)
+    {
+        return hash(vertex.c_str(), fragment.c_str());
+    }
+
+private:
+    OpenGLProgram(OpenGLContext *ctx, const GLchar *vertex, const GLchar *fragment, const std::string &name) : mContext(ctx), mName(name)
+    {
+        NRDP_OBJECTCOUNT_REF(OpenGLShaders, this);
+        mVertexShader = vertex;
+        NRDP_OBJECTCOUNT_DESCRIBE(mVertexShader, "VertexShader:"+name);
+        mFragmentShader = fragment;
+        NRDP_OBJECTCOUNT_DESCRIBE(mFragmentShader, "FragmentShader:"+name);
+        if(GibbonDebug::DrawGLFragmentShader) {
+            static int color = 0;
+            color = (color+1) % colornames::cssColorCount;
+            const std::string colorName = Color::colorName(color);
+            mName += ":" + colorName;
+            Color c(colorName);
+
+            bool debugged = false;
+            std::string debug_fragment = fragment;
+            for(size_t off = 0; !debugged && off < mFragmentShader.size(); ++off) {
+                static std::string main_str("main");
+                off = mFragmentShader.indexOf(main_str, off);
+                if(off == std::string::npos)
+                    break;
+                off += main_str.length();
+                enum {
+                    State_OpenParen,
+                    State_CloseParen,
+                    State_OpenMainBody,
+                    State_CloseMainBody
+                } state = State_OpenParen;
+                for(int curly_count = 0; !debugged && off < mFragmentShader.size(); ++off) {
+                    if(isspace(mFragmentShader[off]))
+                        continue;
+                    if(state == State_OpenParen) {
+                        if(mFragmentShader[off] != '(')
+                            break;
+                        state = State_CloseParen;
+                    } else if(state == State_CloseParen) {
+                        if(mFragmentShader[off] == ')')
+                            state = State_OpenMainBody;
+                    } else if(state == State_OpenMainBody) {
+                        if(mFragmentShader[off] == '{')
+                            state = State_CloseMainBody;
+                    } else if(state == State_CloseMainBody) {
+                        if(mFragmentShader[off] == '{') {
+                            ++curly_count;
+                        } else if(mFragmentShader[off] == '}') {
+                            if(!curly_count) {
+                                debugged = true;
+                                mFragmentShader.insert(off, StringFormatter::sformat("  gl_FragColor.rgb = vec3(%.1f, %.1f, %.1f);\n",
+                                                                                     float(c.r)/255, float(c.g)/255, float(c.b)/255));
+                            }
+                            --curly_count;
+                        }
+                    }
+                }
+            }
+            if(!debugged)
+                Log::error(TRACE_LOG, "Could not debug shader! %s", mFragmentShader.constData());
+        }
+        mProgram = link(ctx, mVertexShader.constData<const GLchar>(), mFragmentShader.constData<const GLchar>(), mName, mError);
+    }
+
+    static inline GLint compile(OpenGLContext *, GLuint type, const GLchar *source, const std::string &name, std::string &error, bool *ok)
+    {
+        GLuint shader;
+        GL_CHECK_CREATE(shader, glCreateShader(type));
+        glShaderSource(shader, 1, &source, 0);
+        glCompileShader(shader);
+        {
+            GLint compiled;
+            glGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);
+
+            std::string gl_infoLog;
+            GLint gl_infoLogLength = 0;
+            glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &gl_infoLogLength);
+            if(gl_infoLogLength > 0) {
+                gl_infoLog.resize(gl_infoLogLength, ' ');
+                glGetShaderInfoLog(shader, gl_infoLogLength + 1, &gl_infoLogLength, &gl_infoLog[0]);
+                gl_infoLog.resize(strlen(gl_infoLog.c_str()));
+                if(!gl_infoLog.empty()) {
+                    Log::error(TRACE_GIBBON_GRAPHICS, "**********************\n%s\n**************************\n", source);
+                    Log::error(TRACE_GIBBON_GRAPHICS, "ShaderCompile(0x%x):%s: %s", compiled, name.c_str(), gl_infoLog.c_str());
+                }
+            }
+            if(!compiled) {
+                error = gl_infoLog;
+                *ok = false;
+                return 0;
+            }
+        }
+        *ok = true;
+        error = std::string();
+        return shader;
+    }
+
+    static inline GLuint link(OpenGLContext *ctx, const GLchar *vertex, const GLchar *fragment, const std::string &name, std::string &error)
+    {
+        bool ok;
+        const GLuint v = compile(ctx, GL_VERTEX_SHADER, vertex, name, error, &ok);
+        if(!ok)
+            return 0;
+        const GLuint f = compile(ctx, GL_FRAGMENT_SHADER, fragment, name, error, &ok);
+        if(!ok)
+            return 0;
+        GLuint program;
+        GL_CHECK_CREATE(program, glCreateProgram());
+        NRDP_OBJECTCOUNT_REF(OpenGLResourceProgram, program);
+        glAttachShader(program, v);
+        glAttachShader(program, f);
+
+        glLinkProgram(program);
+        {
+            GLint linked;
+            glGetProgramiv(program, GL_LINK_STATUS, &linked);
+
+            std::string gl_infoLog;
+            GLint gl_infoLogLength = 0;
+            glGetProgramiv(program, GL_INFO_LOG_LENGTH, &gl_infoLogLength);
+            if(gl_infoLogLength > 0) {
+                gl_infoLog.resize(gl_infoLogLength, ' ');
+                glGetProgramInfoLog(program, gl_infoLogLength + 1, &gl_infoLogLength, &gl_infoLog[0]);
+                gl_infoLog.resize(strlen(gl_infoLog.c_str()));
+                if(!gl_infoLog.empty())
+                    Log::error(TRACE_GIBBON_GRAPHICS, "ShaderLink(0x%x):%s: %s", linked, name.c_str(), gl_infoLog.c_str());
+            }
+            if(!linked) {
+                error = gl_infoLog;
+                ok = false;
+            }
+        }
+        glDeleteShader(v);
+        glDeleteShader(f);
+
+        if(!ok) {
+            glDeleteProgram(program);
+            return 0;
+        }
+        return program;
+    }
+
+protected:
+    OpenGLContext *mContext;
+
+private:
+    DataBuffer mFragmentShader, mVertexShader;
+    std::map<std::string, GLint> mUniforms;
+    std::vector<GLint> mVariables;
+    std::string mError;
+    std::string mName;
+    GLuint mProgram;
+
+    friend class OpenGLShader;
+};
+
+class OpenGLShader : public std::enable_shared_from_this<OpenGLShader>
+{
+public:
+    enum Uniforms { ProjMatrix, MVMatrix, Last = MVMatrix };
+
+    class Part
+    {
+    public:
+        Part(int id) : mID(id) { }
+        virtual ~Part() { }
+
+        virtual std::string name() const { return std::string(); }
+        virtual std::string describe() const { return name(); }
+
+        virtual void setup(const std::shared_ptr<OpenGLShader> &) { }
+        virtual std::string declarations() const { return std::string(); }
+        virtual std::string body() const { return std::string(); }
+
+        virtual void define(const std::shared_ptr<OpenGLShader> &) { }
+        virtual void bind(const std::shared_ptr<OpenGLShader> &) { }
+
+    protected:
+        int mID;
+    };
+    typedef std::vector<std::shared_ptr<Part> > Parts;
+
+    OpenGLShader(OpenGLContext *ctx, const std::string &name) : mContext(ctx), mName(name) { }
+    OpenGLShader(OpenGLContext *ctx, const Parts &vertex, const Parts &fragment, const std::string &name)
+        : mContext(ctx), mVertex(vertex), mFragment(fragment), mName(name) { }
+    OpenGLShader(OpenGLContext *ctx, const GLchar *vertex, const GLchar *fragment, const std::string &name);
+    OpenGLShader(const OpenGLProgram::SharedPtr& program)
+        : mProgram(program), mContext(program->context()), mName(program->name()) { }
+
+    virtual ~OpenGLShader() { invalidate(); }
+
+    virtual std::string name() const {
+        StringBuilder result;
+        result << mName;
+        for(Parts::const_iterator vit = mVertex.begin(); vit != mVertex.end(); ++vit)
+            result << ":" << (*vit)->name();
+        for(Parts::const_iterator fit = mFragment.begin(); fit != mFragment.end(); ++fit)
+            result << ":" << (*fit)->name();
+        return result.str();
+    }
+    virtual std::string describe() const
+    {
+        StringBuilder result;
+        result << "Shader(" << mProgram.get() << "):" << name();
+        if(mProgram)
+            result << mProgram->describe();
+        for(Parts::const_iterator it = mVertex.begin(); it != mVertex.end(); ++it) {
+            const std::string sub = (*it)->describe();
+            if(!sub.empty())
+                result << ": " << sub;
+        }
+        for(Parts::const_iterator it = mFragment.begin(); it != mFragment.end(); ++it) {
+            const std::string sub = (*it)->describe();
+            if(!sub.empty())
+                result << ": " << sub;
+        }
+        return result.str();
+    }
+
+    OpenGLProgram::SharedPtr program() const { return mProgram; }
+    OpenGLContext *context() const { return mContext; }
+
+    inline bool isValid() const { return mProgram && mProgram->isValid(); }
+
+    virtual void render() { }
+    virtual void bind()
+    {
+        for(Parts::const_iterator vit = mVertex.begin(); vit != mVertex.end(); ++vit)
+            (*vit)->bind(shared_from_this());
+        for(Parts::const_iterator fit = mFragment.begin(); fit != mFragment.end(); ++fit)
+            (*fit)->bind(shared_from_this());
+    }
+
+    void invalidate()
+    {
+        mProgram.reset();
+    }
+    void generate();
+    inline void use()
+    {
+        if(!mProgram)
+            generate();
+        if(isValid())
+            mProgram->use();
+    }
+
+    class Scope
+    {
+    public:
+        inline Scope(const std::shared_ptr<OpenGLShader> &ptr) : shader(ptr)
+        {
+            oldshader = OpenGLShader::current();
+            OpenGLShader::setCurrent(shader);
+            shader->use();
+            shader->bind();
+        }
+        inline ~Scope()
+        {
+            if(std::shared_ptr<OpenGLShader> s = oldshader.lock()) {
+                OpenGLShader::setCurrent(s);
+                s->use();
+                s->bind();
+            } else {
+                OpenGLShader::setCurrent(std::shared_ptr<OpenGLShader>());
+            }
+        }
+    private:
+        std::shared_ptr<OpenGLShader> shader;
+        std::weak_ptr<OpenGLShader> oldshader;
+    };
+
+    inline static std::shared_ptr<OpenGLShader> current() { return sCurrentShader.lock(); }
+
+protected:
+    OpenGLProgram::SharedPtr mProgram;
+    virtual std::string vertexDeclarations() const {
+        std::string result = ("uniform mat4   u_projectionMatrix;\n"
+                              "uniform mat4   u_mvMatrix;\n");
+        for(Parts::const_iterator vit = mVertex.begin(); vit != mVertex.end(); ++vit)
+            result += (*vit)->declarations() + "\n";
+        return result;
+    }
+    virtual std::string vertexBody() const {
+        std::string result;
+        for(Parts::const_iterator vit = mVertex.begin(); vit != mVertex.end(); ++vit)
+            result += (*vit)->body() + "\n";
+        return result;
+    }
+    virtual std::string fragmentDeclarations() const {
+        std::string result;
+        for(Parts::const_iterator fit = mFragment.begin(); fit != mFragment.end(); ++fit)
+            result += (*fit)->declarations() + "\n";
+        return result;
+    }
+    virtual std::string fragmentBody() const {
+        std::string result;
+        for(Parts::const_iterator fit = mFragment.begin(); fit != mFragment.end(); ++fit)
+            result += (*fit)->body();
+        return result;
+    }
+    virtual void define()
+    {
+        mProgram->defineUniform(OpenGLShader::ProjMatrix, "u_projectionMatrix");
+        mProgram->defineUniform(OpenGLShader::MVMatrix, "u_mvMatrix");
+        for(Parts::const_iterator vit = mVertex.begin(); vit != mVertex.end(); ++vit)
+            (*vit)->define(shared_from_this());
+        for(Parts::const_iterator fit = mFragment.begin(); fit != mFragment.end(); ++fit)
+            (*fit)->define(shared_from_this());
+    }
+    virtual void setup()
+    {
+        for(Parts::const_iterator vit = mVertex.begin(); vit != mVertex.end(); ++vit)
+            (*vit)->setup(shared_from_this());
+        for(Parts::const_iterator fit = mFragment.begin(); fit != mFragment.end(); ++fit)
+            (*fit)->setup(shared_from_this());
+    }
+
+private:
+    inline static void setCurrent(const std::shared_ptr<OpenGLShader> &shader) { sCurrentShader = shader; }
+
+    static std::weak_ptr<OpenGLShader> sCurrentShader;
+
+    OpenGLContext *mContext;
+    Parts mVertex, mFragment;
+    std::string mName;
+};
+
+class RectShader : public OpenGLShader
+{
+public:
+    enum Uniforms { Rect=Last+1, Position, Last = Position };
+
+    RectShader(OpenGLContext *ctx, const std::string &name) : OpenGLShader(ctx, name)
+    {
+        init();
+    }
+
+    RectShader(OpenGLContext *ctx, const Parts &vertex, const Parts &fragment, const std::string &name)
+        : OpenGLShader(ctx, vertex, fragment, name)
+    {
+        init();
+    }
+
+    RectShader(const OpenGLProgram::SharedPtr& program)
+        : OpenGLShader(program)
+    {
+        init();
+    }
+
+    ~RectShader()
+    {
+    }
+
+    void bindVertexBuffer() const
+    {
+        context()->state()->bindBuffer(GL_ARRAY_BUFFER, mVertexBuffer->vbo());
+    }
+
+    virtual void bind() override
+    {
+        OpenGLShader::bind();
+
+        bindVertexBuffer();
+
+        const GLuint pos = program()->variable(RectShader::Position);
+        glVertexAttribPointer(pos, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(GLfloat), (GLvoid*)(0*sizeof(GLfloat)));
+        context()->state()->enableVAA(pos);
+    }
+
+    virtual void render() override
+    {
+        glDrawArrays(GL_TRIANGLE_FAN, 0, 4);
+    }
+
+protected:
+
+    virtual std::string vertexDeclarations() const override {
+        std::string result = ("attribute vec2 a_position;\n"
+                              "uniform   vec4 u_rect;\n");
+        result += OpenGLShader::vertexDeclarations();
+        return result;
+    }
+    virtual std::string vertexBody() const  override {
+        std::string result = ("  gl_Position = vec4(u_rect[int(2.0 * (1.0 - abs(sign(a_position.x - 1.0))))],\n"
+                              "                 u_rect[int(2.0 * (1.0 - abs(sign(a_position.y + 1.0))))+1],\n"
+                              "                 0.0, 1.0);\n");
+        result += OpenGLShader::vertexBody();
+        return result;
+    }
+    virtual void define() override
+    {
+        OpenGLShader::define();
+        mProgram->defineUniform(RectShader::Rect, "u_rect");
+        mProgram->defineAttribute(RectShader::Position, "a_position");
+    }
+
+    void init()
+    {
+        mVertexBuffer = context()->vbo();
+    }
+
+protected:
+    std::shared_ptr<OpenGLVBO> mVertexBuffer;
+};
+
+class RGBConvertPart : public OpenGLShader::Part
+{
+public:
+    enum Conversion {
+        Conversion_None,
+        Conversion_BT709ToPQ2020,
+        Conversion_PQ2020ToBT709
+    };
+    enum Debug {
+        Debug_None,
+        Debug_SDRClip,
+        Debug_SDRToneMap,
+        Debug_SDRToneMapKnee,
+        Debug_HDRHighlight15,
+        Debug_HDRHighlight100
+    };
+
+    RGBConvertPart(Conversion conversion, Debug debug = Debug_None, int id=0) : OpenGLShader::Part(id), mDebug(debug), mConversion(conversion) { }
+    virtual std::string name() const override {
+        std::string result;
+        if(mConversion == Conversion_BT709ToPQ2020)
+            result = "BT709ToPQ2020";
+        else if(mConversion == Conversion_PQ2020ToBT709)
+            result = "PQ2020ToBT709";
+        if(mDebug == Debug_HDRHighlight15)
+            result += ":HDRHighlight:15";
+        else if(mDebug == Debug_HDRHighlight100)
+            result += ":HDRHighlight:100";
+        else if(mDebug == Debug_SDRClip)
+            result += ":SDRClip";
+        else if(mDebug == Debug_SDRToneMap)
+            result += ":SDRToneMap";
+        else if(mDebug == Debug_SDRToneMapKnee)
+            result += ":SDRToneMap:Knee";
+        return result;
+    }
+    virtual std::string declarations() const override
+    {
+        std::string result;
+        if(mConversion == Conversion_BT709ToPQ2020 || mConversion == Conversion_PQ2020ToBT709) {
+            result += ("const float kRefWhiteLevel = 300.0;\n"
+                       "const float c1 = 0.8359375;\n"
+                       "const float c2 = 18.8515625;\n"
+                       "const float c3 = 18.6875;\n"
+                       "const float m1 = 0.159301758125;\n"
+                       "const float m2 = 78.84375;\n"
+                       "const float gamma = 2.4;\n");
+            if(mConversion == Conversion_BT709ToPQ2020) {
+                result += ("vec3 applyGamma(vec3 x)\n"
+                           "{\n"
+                           "  return pow(abs(x), vec3(gamma));\n"
+                           "}\n"
+                           "const mat3 BT709_TO_BT2020 = mat3(0.627403896, 0.329283038, 0.043313066, 0.069097289, 0.919540395, 0.011362316, 0.016391439, 0.088013308, 0.895595253);\n"
+                           "vec3 bt709ToBt2020(vec3 L)\n"
+                           "{\n"
+                           "  return L * BT709_TO_BT2020;\n"
+                           "}\n"
+                           "vec3 PQ_OETF(vec3 O)\n"
+                           "{\n"
+                           "  vec3 L = O * kRefWhiteLevel / 10000.0;\n"
+                           "  vec3 Lm1 = pow(abs(L), vec3(m1));\n"
+                           "  vec3 X = (c1 + c2 * Lm1) / (1.0 + c3 * Lm1);\n"
+                           "  vec3 E = pow(abs(X), vec3(m2));\n"
+                           "  return E;\n"
+                           "}\n"
+                           "vec3 rgbConvert(vec3 sdr)\n"
+                           "{\n"
+                           "  vec3 L = applyGamma(sdr);\n"
+                           "  vec3 bt2020 = bt709ToBt2020(L);\n"
+                           "  vec3 hdr = PQ_OETF(bt2020);\n"
+                           "  return hdr;\n"
+                           "}\n");
+            } else {
+                result += ("vec3 PQ_EOTF(vec3 E)\n"
+                           "{\n"
+                           "  vec3 M = c2 - c3 * pow(abs(E), vec3(1.0 / m2));\n"
+                           "  vec3 N = max(pow(abs(E), vec3(1.0 / m2)) - c1, 0.0);\n"
+                           "  vec3 res = pow(abs(N / M), vec3(1.0 / m1));\n"
+                           "  vec3 O = res * 10000.0 / kRefWhiteLevel;\n"
+                           "  return O;\n"
+                           "}\n"
+                           "const mat3 BT2020_TO_BT709 = mat3(1.66049, -0.58764, -0.07285, -0.12455, 1.13290, -0.00835, -0.01815, -0.10058, 1.11873);\n"
+                           "vec3 bt2020ToBt709(vec3 O)\n"
+                           "{\n"
+                           "  return O * BT2020_TO_BT709;\n"
+                           "}\n"
+                           "vec3 reinhardTonemap(vec3 L)\n"
+                           "{\n"
+                           "  return L / (vec3(1.0) + L);\n"
+                           "}\n"
+                           "vec3 applyInverseGamma(vec3 x)\n"
+                           "{\n"
+                           "  return pow(abs(x), vec3(1.0 / gamma));\n"
+                           "}\n"
+                           "vec3 rgbConvert(vec3 hdr)\n"
+                           "{\n"
+                           "  vec3 O = PQ_EOTF(hdr);\n"
+                           "  vec3 L = bt2020ToBt709(O);\n"
+                           "  L = reinhardTonemap(L);\n"
+                           "  vec3 sdr = applyInverseGamma(L);\n"
+                           "  return sdr;\n"
+                           "}\n");
+            }
+            result += ("vec4 rgbaConvert(vec4 sample)\n"
+                       "{\n"
+                       "  if(sample.a > 0.0)\n"
+                       "     sample.rgb = sample.rgb / sample.a;\n"
+                       "  sample.rgb = rgbConvert(sample.rgb) * sample.a;\n"
+                       "  return sample;\n"
+                       "}\n");
+        }
+        return result;
+    }
+
+protected:
+    Debug mDebug;
+    Conversion mConversion;
+};
+
+class FillShader : public RectShader
+{
+public:
+    enum Uniforms { Color = RectShader::Last+1, Last = Color };
+
+    enum Feature {
+        Feature_None              = 0x00,
+        Feature_Convert_709TO2020 = 0x10
+    };
+    typedef Flags<Feature> Features;
+    static std::shared_ptr<FillShader> create(OpenGLContext *context, Features features);
+    inline Features features() const { return mFeatures; }
+
+    FillShader(OpenGLContext *ctx, Features features=Features(), const std::string &name="FillShader") : RectShader(ctx, name), mFeatures(features)
+    {
+    }
+
+    FillShader(OpenGLContext *ctx, const Parts &vertex, const Parts &fragment, Features features=Features(), const std::string &name = "FillShader")
+        : RectShader(ctx, vertex, fragment, name), mFeatures(features)
+    {
+    }
+
+protected:
+    virtual std::string fragmentDeclarations() const override
+    {
+        std::string result = RectShader::fragmentDeclarations();
+        result += "uniform vec4 u_color;\n";
+        return result;
+
+    }
+    virtual std::string fragmentBody() const override
+    {
+        std::string result = "  gl_FragColor = u_color;\n";
+        if(mFeatures & Feature_Convert_709TO2020)
+            result += "  gl_FragColor = rgbaConvert(gl_FragColor);\n";
+        result += RectShader::fragmentBody();
+        return result;
+    }
+    virtual void define() override
+    {
+        assert(isValid());
+        mProgram->reserveVariables(FillShader::Last);
+        RectShader::define();
+        mProgram->defineUniform(FillShader::Color, "u_color");
+    }
+
+protected:
+    Features mFeatures;
+};
+NRDP_FLAGS(FillShader::Feature);
+
+class LineShader : public FillShader
+{
+public:
+    static std::shared_ptr<LineShader> create(OpenGLContext *context, Features features);
+
+    LineShader(OpenGLContext *ctx, Features features=Features()) : FillShader(ctx, features, "LineShader")
+    {
+        init();
+    }
+
+    LineShader(OpenGLContext *ctx, const Parts &vertex, const Parts &fragment, Features features=Features())
+        : FillShader(ctx, vertex, fragment, features, "LineShader")
+    {
+        init();
+    }
+
+    ~LineShader()
+    {
+        OpenGLContext::deleteBuffer(mElementsBuffer);
+    }
+
+    virtual void render() override
+    {
+        bindElementBuffer();
+        glDrawElements(GL_LINES, 8, GL_UNSIGNED_BYTE, 0);
+    }
+
+    void bindElementBuffer() const
+    {
+        context()->state()->bindBuffer(GL_ELEMENT_ARRAY_BUFFER, mElementsBuffer);
+    }
+
+protected:
+    void init()
+    {
+        mElementsBuffer = context()->createVBO();
+        bindElementBuffer();
+        GLubyte indices[8] = {1, 2, 2, 3, 3, 0, 0, 1};
+        glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
+    }
+
+protected:
+    GLuint mElementsBuffer;
+};
+
+class TextureShader : public RectShader
+{
+public:
+    enum Uniforms { TexCoord = RectShader::Last+1, TextureTransform, Opacity, Color, Mask, Last = Mask };
+
+    enum Feature {
+        Feature_None              = 0x00,
+        Feature_Mask              = 0x01,
+        Feature_Mask_AlphaOnly    = 0x02,
+        Feature_Colorize          = 0x04,
+        Feature_Convert_709TO2020 = 0x10,
+        Feature_Convert_2020TO709 = 0x20
+    };
+    typedef Flags<Feature> Features;
+    static std::shared_ptr<TextureShader> create(OpenGLContext *context, Features features);
+    inline Features features() const { return mFeatures; }
+
+    class RGBPart : public Part
+    {
+    public:
+        RGBPart(int id=0) : Part(id) { }
+        virtual std::string name() const override { return "RGB"; }
+
+        virtual std::string declarations() const override {
+            return "uniform sampler2D s_texture;\n";
+        }
+
+        virtual void define(const std::shared_ptr<OpenGLShader> &shader) override {
+            glUniform1i(shader->program()->uniformLocation("s_texture"), 0);
+        }
+
+        virtual std::string body() const override
+        {
+            return "  gl_FragColor = texture2D(s_texture, v_texCoord);\n";
+        }
+    };
+    class ColorizePart : public Part
+    {
+    public:
+        ColorizePart(int id=0) : Part(id) { }
+        virtual std::string name() const override { return "Colorize"; }
+
+        virtual std::string declarations() const override
+        {
+            return "uniform vec4      u_color;\n";
+        }
+        virtual std::string body() const override
+        {
+            return "  gl_FragColor = gl_FragColor * u_color;\n";
+        }
+        virtual void define(const std::shared_ptr<OpenGLShader> &shader) override
+        {
+            shader->program()->defineUniform(TextureShader::Color, "u_color");
+        }
+    };
+    class MaskPart : public Part
+    {
+    public:
+        enum Mode {
+            Mode_Alpha,
+            Mode_RGB
+        };
+        MaskPart(Mode mode, int id=0) : Part(id), mMode(mode) { }
+        virtual std::string name() const override {
+            if(mMode == Mode_Alpha)
+                return "AlphaMask";
+            return "RGBMask";
+        }
+
+        virtual std::string declarations() const override
+        {
+            return "uniform sampler2D s_mask;\n";
+        }
+        virtual std::string body() const override
+        {
+            std::string result = "  vec4 mask_sample = texture2D(s_mask, v_texCoord);\n";
+            if(mMode == Mode_Alpha)
+                result += "  gl_FragColor = gl_FragColor * mask_sample.a;\n";
+            else
+                result += "  gl_FragColor = gl_FragColor * ((mask_sample.r+mask_sample.g+mask_sample.b)/3.0);\n";
+            return result;
+        }
+        virtual void define(const std::shared_ptr<OpenGLShader> &shader) override
+        {
+            glUniform1i(shader->program()->uniformLocation("s_mask"), 1);
+        }
+    protected:
+        Mode mMode;
+    };
+
+    TextureShader(OpenGLContext *ctx, Features features=Features()) : RectShader(ctx, "TextureShader"), mFeatures(features)
+    {
+    }
+
+    TextureShader(OpenGLContext *ctx, const Parts &vertex, const Parts &fragment, Features features=Features())
+        : RectShader(ctx, vertex, fragment, "TextureShader"), mFeatures(features)
+    {
+    }
+
+    TextureShader(OpenGLContext *ctx, const Parts &vertex, const Parts &fragment, const std::string &name, Features features=Features())
+        : RectShader(ctx, vertex, fragment, name), mFeatures(features)
+    {
+    }
+
+    virtual void bind() override
+    {
+        RectShader::bind();
+
+        bindVertexBuffer();
+
+        const GLuint tex = program()->variable(TextureShader::TexCoord);
+        glVertexAttribPointer(tex, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(GLfloat), (GLvoid*)(2*sizeof(GLfloat)));
+        context()->state()->enableVAA(tex);
+    }
+
+protected:
+    virtual std::string vertexDeclarations() const override
+    {
+        std::string result = ("uniform vec4   u_ts;\n"
+                              "attribute vec2 a_texCoord;\n"
+                              "varying vec2   v_texCoord;\n");
+        result += RectShader::vertexDeclarations();
+        return result;
+    }
+    virtual std::string vertexBody() const override
+    {
+        std::string result = ("  v_texCoord.x = (a_texCoord.x * u_ts.z) + u_ts.x;\n"
+                              "  v_texCoord.y = (a_texCoord.y * u_ts.w) + u_ts.y;\n");
+        result += RectShader::vertexBody();
+        return result;
+    }
+    virtual std::string fragmentDeclarations() const override
+    {
+        std::string result = ("varying vec2      v_texCoord;\n"
+                              "uniform vec4      u_opacity;\n");
+        result += RectShader::fragmentDeclarations();
+        return result;
+    }
+    virtual std::string fragmentBody() const override
+    {
+        std::string result = RectShader::fragmentBody();
+        result += "  gl_FragColor = gl_FragColor * u_opacity;\n";
+        if((mFeatures & (Feature_Convert_709TO2020) || (mFeatures & Feature_Convert_2020TO709)))
+            result += "  gl_FragColor = rgbaConvert(gl_FragColor);\n";
+        return result;
+    }
+    virtual void define() override
+    {
+        mProgram->reserveVariables(TextureShader::Last);
+        mProgram->defineUnused(TextureShader::Mask);
+        mProgram->defineUnused(TextureShader::Color);
+        RectShader::define();
+        mProgram->defineUniform(TextureShader::TextureTransform, "u_ts");
+        mProgram->defineUniform(TextureShader::Opacity, "u_opacity");
+        mProgram->defineAttribute(TextureShader::TexCoord, "a_texCoord");
+    }
+
+private:
+    Features mFeatures;
+    friend class OpenGLShader;
+};
+NRDP_FLAGS(TextureShader::Feature);
+
+class VBOShader : public OpenGLShader
+{
+public:
+    enum Uniforms { TexCoord = OpenGLShader::Last+1, Position, TexSize, Opacity, Color, Mask, Last = Mask };
+
+    enum Feature {
+        Feature_None              = 0x00,
+        Feature_Mask              = 0x01,
+        Feature_Mask_AlphaOnly    = 0x02,
+        Feature_Colorize  	      = 0x04,
+        Feature_Bicubic           = 0x08,
+        Feature_AlphaOnly         = 0x10,
+        Feature_Convert_709TO2020 = 0x20,
+        Feature_Convert_2020TO709 = 0x40
+    };
+    typedef Flags<Feature> Features;
+    static std::shared_ptr<VBOShader> create(OpenGLContext *context, Features features);
+    inline Features features() const { return mFeatures; }
+
+    class RGBPart : public Part
+    {
+    public:
+        RGBPart(int id=0) : Part(id) { }
+        virtual std::string name() const override { return "RGB"; }
+        virtual std::string declarations() const override
+        {
+            return "uniform sampler2D s_texture;\n";
+        }
+        virtual std::string body() const override
+        {
+            return "  gl_FragColor = texture2D(s_texture, v_texCoord);\n";
+        }
+        virtual void define(const std::shared_ptr<OpenGLShader> &shader) override
+        {
+            glUniform1i(shader->program()->uniformLocation("s_texture"), 0);
+        }
+    };
+    class ColorizePart : public Part
+    {
+    public:
+        ColorizePart(int id=0) : Part(id) { }
+        virtual std::string name() const override { return "Colorize"; }
+        virtual std::string declarations() const override
+        {
+            return "uniform vec4      u_color;\n";
+        }
+        virtual std::string body() const override
+        {
+            return "  gl_FragColor = gl_FragColor * u_color;\n";
+        }
+        virtual void define(const std::shared_ptr<OpenGLShader> &shader) override
+        {
+            shader->program()->defineUniform(VBOShader::Color, "u_color");
+        }
+    };
+    class AlphaOnlyPart : public Part
+    {
+    public:
+        AlphaOnlyPart(int id=0) : Part(id) { }
+        virtual std::string name() const override { return "AlphaOnly"; }
+        virtual std::string declarations() const override
+        {
+            return "uniform sampler2D s_texture;\n";
+        }
+        virtual std::string body() const override
+        {
+            return
+                "  float a = texture2D(s_texture, v_texCoord).a;\n"
+                "  gl_FragColor = vec4(a, a, a, a);\n";
+        }
+        virtual void define(const std::shared_ptr<OpenGLShader> &shader) override
+        {
+            glUniform1i(shader->program()->uniformLocation("s_texture"), 0);
+        }
+
+    };
+    class RGBBicubicPart : public Part
+    {
+    public:
+        RGBBicubicPart(int id=0) : Part(id) { }
+        virtual std::string name() const override { return "RGBBicubic"; }
+
+        virtual std::string declarations() const override
+        {
+            return
+                "uniform sampler2D s_texture;\n"
+                "uniform vec2 u_texSize;\n"
+                // 4x4 bicubic filter using 4 linear lookups texture
+                // inspired by GPU Gems 2,
+                // http://http.developer.nvidia.com/GPUGems2/gpugems2_chapter20.html
+                "vec4 cubic(float x)\n"
+                "{\n"
+                "  float x2 = x * x;\n"
+                "  float x3 = x2 * x;\n"
+                "  vec4 w;\n"
+                "  w.x =  -x3 + 3.0 * x2 - 3.0 * x + 1.0;\n"
+                "  w.y =  3.0 * x3 - 6.0 * x2 + 4.0;\n"
+                "  w.z = -3.0 * x3 + 3.0 * x2 + 3.0 * x + 1.0;\n"
+                "  w.w =  x3;\n"
+                "  return w / 6.0;\n"
+                "}\n"
+                "vec4 filter(sampler2D texture, vec2 texCoord, vec2 texSize)\n"
+                "{\n"
+                "  texCoord = texCoord * texSize - 1.0;\n"
+                "  float fx = fract(texCoord.x);\n"
+                "  float fy = fract(texCoord.y);\n"
+                "  texCoord.x -= fx;\n"
+                "  texCoord.y -= fy;\n"
+
+                "  vec4 cx = cubic(fx);\n"
+                "  vec4 cy = cubic(fy);\n"
+
+                "  vec4 c = vec4(texCoord.x - 0.5, texCoord.x + 1.5, texCoord.y - 0.5, texCoord.y + 1.5);\n"
+                "  vec4 s = vec4(cx.x + cx.y, cx.z + cx.w, cy.x + cy.y, cy.z + cy.w);\n"
+                "  vec4 off = c + vec4(cx.y, cx.w, cy.y, cy.w) / s;\n"
+
+                "  vec4 s0 = texture2D(texture, vec2(off.x, off.z) / texSize);\n"
+                "  vec4 s1 = texture2D(texture, vec2(off.y, off.z) / texSize);\n"
+                "  vec4 s2 = texture2D(texture, vec2(off.x, off.w) / texSize);\n"
+                "  vec4 s3 = texture2D(texture, vec2(off.y, off.w) / texSize);\n"
+
+                "  float sx = s.x / (s.x + s.y);\n"
+                "  float sy = s.z / (s.z + s.w);\n"
+
+                "  return mix(mix(s3, s2, sx), mix(s1, s0, sx), sy);\n"
+                "}\n";
+        }
+        virtual std::string body() const override
+        {
+            return "  gl_FragColor = filter(s_texture, v_texCoord, u_texSize);\n";
+        }
+        virtual void define(const std::shared_ptr<OpenGLShader> &shader) override
+        {
+            shader->program()->defineUniform(VBOShader::TexSize, "u_texSize");
+            glUniform1i(shader->program()->uniformLocation("s_texture"), 0);
+        }
+    };
+    class MaskPart : public Part
+    {
+    public:
+        enum Mode {
+            Mode_Alpha,
+            Mode_RGB
+        };
+        MaskPart(Mode mode, int id=0) : Part(id), mMode(mode) { }
+        virtual std::string name() const override {
+            if(mMode == Mode_Alpha)
+                return "AlphaMask";
+            return "RGBMask";
+        }
+
+        virtual std::string declarations() const override
+        {
+            return "uniform sampler2D s_mask;\n";
+        }
+        virtual std::string body() const override
+        {
+            std::string result = "  vec4 mask_sample = texture2D(s_mask, v_texCoord);\n";
+            if(mMode == Mode_Alpha)
+                result += "  gl_FragColor = gl_FragColor * mask_sample.a;\n";
+            else
+                result += "  gl_FragColor = gl_FragColor * ((mask_sample.r+mask_sample.g+mask_sample.b)/3.0);\n";
+            return result;
+        }
+        virtual void define(const std::shared_ptr<OpenGLShader> &shader) override
+        {
+            glUniform1i(shader->program()->uniformLocation("s_mask"), 1);
+        }
+    protected:
+        Mode mMode;
+    };
+
+    VBOShader(OpenGLContext *ctx, Features features=Features()) : OpenGLShader(ctx, "VBOShader"), mFeatures(features)
+    {
+        init();
+    }
+
+    VBOShader(OpenGLContext *ctx, const Parts &vertex, const Parts &fragment, Features features=Features())
+        : OpenGLShader(ctx, vertex, fragment, "VBOShader"), mFeatures(features)
+    {
+        init();
+    }
+
+    ~VBOShader()
+    {
+        OpenGLContext::deleteBuffer(mVertexBuffer);
+    }
+
+    void bindVertexBuffer()
+    {
+        context()->state()->bindBuffer(GL_ARRAY_BUFFER, mVertexBuffer);
+    }
+
+    void updateVBO(const OpenGLFloats &data, size_t triangles)
+    {
+        mTriangles = triangles;
+        bindVertexBuffer();
+        glBufferData(GL_ARRAY_BUFFER, mTriangles * 4 * sizeof(GLfloat), data.base(), GL_DYNAMIC_DRAW);
+    }
+
+    virtual void bind() override
+    {
+        OpenGLShader::bind();
+
+        bindVertexBuffer();
+
+        const GLuint pos = program()->variable(VBOShader::Position);
+        glVertexAttribPointer(pos, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(GLfloat), (GLvoid*)(0*sizeof(GLfloat)));
+        context()->state()->enableVAA(pos);
+
+        const GLuint tex = program()->variable(VBOShader::TexCoord);
+        glVertexAttribPointer(tex, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(GLfloat), (GLvoid*)(2*sizeof(GLfloat)));
+        context()->state()->enableVAA(tex);
+    }
+
+    virtual void render() override
+    {
+        glDrawArrays(GL_TRIANGLES, 0, mTriangles);
+    }
+
+protected:
+    void init()
+    {
+        mTriangles = 0;
+        mVertexBuffer = context()->createVBO();
+    }
+
+    virtual std::string vertexDeclarations() const override
+    {
+        std::string result = ("varying vec2 v_texCoord;\n"
+                              "attribute vec2 a_position;\n"
+                              "attribute vec2 a_texCoord;\n");
+        result += OpenGLShader::vertexDeclarations();
+        return result;
+    }
+    virtual std::string vertexBody() const override
+    {
+        std::string result = ("  gl_Position = vec4(a_position, 0, 1);\n"
+                              "  v_texCoord = a_texCoord;\n");
+        result += OpenGLShader::vertexBody();
+        return result;
+    }
+    virtual std::string fragmentDeclarations() const override
+    {
+        std::string result = ("uniform vec4 u_opacity;\n"
+                              "varying vec2 v_texCoord;\n");
+        result += OpenGLShader::fragmentDeclarations();
+        return result;
+    }
+    virtual std::string fragmentBody() const override
+    {
+        std::string result = OpenGLShader::fragmentBody();
+        result += "  gl_FragColor = gl_FragColor * u_opacity;\n";
+        if((mFeatures & (Feature_Convert_709TO2020) || (mFeatures & Feature_Convert_2020TO709)))
+            result += "  gl_FragColor = rgbaConvert(gl_FragColor);\n";
+        return result;
+    }
+    virtual void define() override
+    {
+        mProgram->reserveVariables(VBOShader::Last);
+        mProgram->defineUnused(VBOShader::Mask);
+        mProgram->defineUnused(VBOShader::TexSize);
+        mProgram->defineUnused(VBOShader::Color);
+        OpenGLShader::define();
+        mProgram->defineUniform(VBOShader::Opacity, "u_opacity");
+        mProgram->defineAttribute(VBOShader::Position, "a_position");
+        mProgram->defineAttribute(VBOShader::TexCoord, "a_texCoord");
+    }
+
+private:
+    Features mFeatures;
+    GLsizei mTriangles;
+    GLuint mVertexBuffer;
+
+    friend class OpenGLShader;
+};
+NRDP_FLAGS(VBOShader::Feature);
+
+class OpenGLShaders
+{
+public:
+    static void init(OpenGLContext *context);
+    static void cleanup();
+
+    static OpenGLProgram::SharedPtr findProgramByName(const std::string &name)
+    {
+        ProgramCache::const_iterator program = sProgramCache.find(name);
+        if(program != sProgramCache.end()) {
+            if((*program)->isValid())
+                (*program)->use();
+            return *program;
+        }
+        return std::shared_ptr<OpenGLProgram>();
+    }
+    static void cacheProgram(const std::string &name, const OpenGLProgram::SharedPtr &shader)
+    {
+        sProgramCache.insert(name, shader);
+    }
+
+    static void dump(const DumpInfo &dump=DumpInfo());
+
+    static const std::shared_ptr<FillShader> &fillShader(FillShader::Features features) {
+        std::shared_ptr<FillShader> &ref = sFillShaders[features];
+        if(!ref) {
+            ref = FillShader::create(OpenGLContext::context(), features);
+            assert(ref);
+        }
+        return ref;
+    }
+    static const std::shared_ptr<LineShader> &lineShader(LineShader::Features features) {
+        std::shared_ptr<LineShader> &ref = sLineShaders[features];
+        if(!ref) {
+            ref = LineShader::create(OpenGLContext::context(), features);
+            assert(ref);
+        }
+        return ref;
+    }
+    static const std::shared_ptr<TextureShader> &textureShader(TextureShader::Features features) {
+        std::shared_ptr<TextureShader> &ref = sTextureShaders[features];
+        if(!ref) {
+            ref = TextureShader::create(OpenGLContext::context(), features);
+            assert(ref);
+        }
+        return ref;
+    }
+    static const std::shared_ptr<VBOShader> &vboShader(VBOShader::Features features) {
+        std::shared_ptr<VBOShader> &ref = sVBOShaders[features];
+        if(!ref) {
+            ref = VBOShader::create(OpenGLContext::context(), features);
+            assert(ref);
+        }
+        return ref;
+    }
+
+private:
+    static std::shared_ptr<OpenGLShadersDumper> dumper(const DumpInfo &dump=DumpInfo());
+
+    class ProgramPurgable
+    {
+    public:
+        inline bool operator()(const std::shared_ptr<OpenGLProgram> &ptr) { return ptr.use_count() == 1; }
+    };
+    typedef LRU<std::string, std::shared_ptr<OpenGLProgram>, LRUOne<std::shared_ptr<OpenGLProgram> >, ProgramPurgable> ProgramCache;
+
+    static ProgramCache sProgramCache;
+    static std::map<LineShader::Features, std::shared_ptr<LineShader> > sLineShaders;
+    static std::map<FillShader::Features, std::shared_ptr<FillShader> > sFillShaders;
+    static std::map<VBOShader::Features, std::shared_ptr<VBOShader> > sVBOShaders;
+    static std::map<TextureShader::Features, std::shared_ptr<TextureShader> > sTextureShaders;
+};
+
+}} // netflix::gibbon
+
+#endif
diff --git a/partner/graphics/rpi/OpenGLState.h b/partner/graphics/rpi/OpenGLState.h
new file mode 100644
index 00000000..f4fb737a
--- /dev/null
+++ b/partner/graphics/rpi/OpenGLState.h
@@ -0,0 +1,717 @@
+/* (c) 2013 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+
+#ifndef OPENGLSTATE_H
+#define OPENGLSTATE_H
+
+#include <map>
+#include <set>
+#include <algorithm>
+#include <gibbon/config.h>
+
+#ifdef GIBBON_GRAPHICSENGINE_GLES2_EGL
+# include <GLES2/gl2.h>
+# include <GLES2/gl2ext.h>
+# include <EGL/egl.h>
+# include <EGL/eglext.h>
+#endif
+
+#ifdef GIBBON_GRAPHICSENGINE_GLES2_IOS
+# include <OpenGLES/ES2/gl.h>
+#endif
+
+#ifdef GIBBON_GRAPHICSENGINE_GLES2_OSX
+# include <OpenGL/gl.h>
+#endif
+
+#ifdef GIBBON_GRAPHICSENGINE_GLES2_GLX
+# ifndef GL_GLEXT_PROTOTYPES
+#  define GL_GLEXT_PROTOTYPES 1
+# endif
+# include <GL/gl.h>
+# include <GL/glext.h>
+#endif
+
+#define GL_ASSERT(state) state->glCheck(true, __PRETTY_FUNCTION__, __FILE__, __LINE__);
+#define GL_CHECK(state) state->glCheck(false, __PRETTY_FUNCTION__, __FILE__, __LINE__);
+#define GL_CHECK_CREATE(var, function) if(!(var = function)) { netflix::Log::fatal(TRACE_GIBBON_GRAPHICS, "Failure to create: %s", #function); abort(); }
+
+struct OpenGLResourceCount : public netflix::ObjectCount::Record
+{
+public:
+    OpenGLResourceCount(const std::string &n) : netflix::ObjectCount::Record(n) {}
+    virtual std::string describe(const void *object) const override;
+};
+NRDP_DECLARE_OBJECTCOUNT_RECORD(OpenGLResourceCount, OpenGLResourceTexture);
+NRDP_DECLARE_OBJECTCOUNT_RECORD(OpenGLResourceCount, OpenGLResourceProgram);
+NRDP_DECLARE_OBJECTCOUNT_RECORD(OpenGLResourceCount, OpenGLResourceVBO);
+NRDP_DECLARE_OBJECTCOUNT_RECORD(OpenGLResourceCount, OpenGLResourceFBO);
+
+namespace netflix {
+namespace gibbon {
+
+class OpenGLState
+{
+public:
+    OpenGLState();
+    ~OpenGLState();
+
+    inline void useProgram(GLuint program);
+    inline void deleteProgram(GLuint program);
+    inline void bindBuffer(GLenum target, GLuint buffer);
+    inline void deleteBuffer(GLuint buffer);
+    inline void deleteTexture(GLuint texture);
+    inline void notifyDeleteTextures(const std::vector<GLuint> &texs);
+    inline void unbindTexture(GLuint texture);
+    inline void bindFramebuffer(GLuint fbo);
+
+    inline void enableVAA(GLuint index, bool enable = true);
+    inline void disableVAA(GLuint index) { enableVAA(index, false); }
+
+    inline void activeTexture(GLenum texture, bool force=false);
+    inline void bindTexture(GLuint texture, bool force=false);
+    inline void blendFunc(GLenum sfactor, GLenum dfactor, bool force=false)
+    {
+        blendFunc(sfactor, dfactor, sfactor, dfactor, force);
+    }
+    inline void blendFunc(GLenum sRGB, GLenum dRGB, GLenum sAlpha, GLenum dAlpha, bool force=false);
+    inline void blendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha, bool force=false);
+    inline void blendColor(const Color &color, bool force=false)
+    {
+        blendColor(GLfloat(color.r) / 255, GLfloat(color.g) / 255, GLfloat(color.b) / 255, GLfloat(color.a) / 255, force);
+    }
+    inline void blendEquation(GLenum rgb, GLenum alpha, bool force=false);
+    inline void viewport(GLint x, GLint y, GLsizei width, GLsizei height, bool force=false);
+    inline void face(GLenum cull, GLenum front, bool force=false);
+
+    inline GLuint texture() const {
+        std::map<GLenum, GLuint>::const_iterator t = mTextures.find(mActiveTexture);
+        if(t != mTextures.end())
+            return t->second;
+        return 0;
+    }
+
+    inline void reset();
+    inline void flush();
+
+    // per texture
+    inline void resetTexture(GLuint texture);
+    inline void setSmoothScale(bool smooth);
+    inline void setSmoothScale(GLuint tex, bool smooth);
+    inline void setFilter(GLuint tex, GLint min_filter, GLint mag_filter, bool force=false);
+    inline void setFilter(GLint min_filter, GLint mag_filter, bool force=false);
+    inline void setWrap(GLuint tex, GLint wrap_s, GLint wrap_t, bool force=false);
+    inline void setWrap(GLint wrap_s, GLint wrap_t, bool force=false);
+
+    enum ScissorMode { ScissorInclusive, ScissorExclusive };
+    inline void setClip(const Rect& r) { mClip = r; }
+    inline Rect clip() const { return mClip; }
+
+    inline GLenum screenReadBuffer() const { return mScreenReadBuffer; }
+    inline void setScreenReadBuffer(GLenum b) { mScreenReadBuffer = b; }
+
+    inline bool capEnabled(GLenum cap) { return mStates.caps.count(cap) > 0; }
+
+    inline bool glCheckEnabled() const
+    {
+        if(GibbonDebug::DebugGLCheck)
+            return true;
+        if(!mScopes.empty())
+            return mScopes.back()->states.glCheck;
+        return false;
+    }
+    inline void glCheck(bool fatal, const char *function, const char *file, int line)
+    {
+        if(glCheckEnabled()) {
+            const GLenum e = glGetError();
+            if(e != GL_NO_ERROR) {
+                Variant graphicsError;
+                graphicsError["error"] = "GL ERROR " + StringFormatter::hex(e);
+                graphicsError["function"] = function;
+                graphicsError["file"] = file;
+                graphicsError["line"] = line;
+                gibbonApp()->graphicsError(graphicsError, fatal);
+            }
+        }
+    }
+
+    class Scope
+    {
+    public:
+        inline Scope(OpenGLState *state) : mChanges(0), mState(state)
+        {
+            states.glCheck = state->glCheckEnabled();
+            states.sformat = states.dformat = Surface::Format_None;
+            states.mode = GraphicsEngine::CompositionMode_Source;
+            mState->startScope(this);
+        }
+        inline ~Scope() { assert(!mChanges); mState->endScope(this); }
+
+        inline OpenGLState *state() const { return mState; }
+
+        inline void enableCap(GLenum cap, bool enable = true)
+        {
+            ++mChanges;
+#if 0
+            if(cap == GL_SCISSOR_TEST)
+                enable = false;
+#endif
+            if(enable)
+                states.caps.insert(cap);
+            else
+                states.caps.erase(cap);
+        }
+        inline void setScreenReadBuffer(GLenum b)
+        {
+            mState->setScreenReadBuffer(b);
+        }
+        inline void enableScissor(bool enable = true, OpenGLState::ScissorMode mode = ScissorInclusive)
+        {
+            enableCap(GL_SCISSOR_TEST, enable);
+            if(enable)
+                mState->scissor(mode);
+        }
+        inline void disableScissor()
+        {
+            enableCap(GL_SCISSOR_TEST, false);
+        }
+        inline void disableCap(GLenum cap) { enableCap(cap, false); }
+        inline bool hasCap(GLenum cap) const { return states.caps.count(cap); }
+
+        inline void flush() {
+            if(mChanges) {
+                mState->flushScope();
+                mChanges = 0;
+            }
+        }
+
+        inline void setGLCheck(bool glCheck)
+        {
+            if(states.glCheck != glCheck) {
+                states.glCheck = glCheck;
+                ++mChanges;
+            }
+        }
+
+        inline void setCompositionMode(GraphicsEngine::CompositionMode compositionMode)
+        {
+            if(states.mode != compositionMode) {
+                states.mode = compositionMode;
+                ++mChanges;
+            }
+        }
+
+        inline void setFormat(Surface::Format sformat, Surface::Format dformat)
+        {
+            setSourceFormat(sformat);
+            setDestFormat(dformat);
+        }
+
+        inline void setSourceFormat(Surface::Format format)
+        {
+            if(states.sformat != format) {
+                states.sformat = format;
+                ++mChanges;
+            }
+        }
+
+        inline void setDestFormat(Surface::Format format)
+        {
+            if(states.dformat != format) {
+                states.dformat = format;
+                ++mChanges;
+            }
+        }
+
+    private:
+        uint8_t mChanges;
+        OpenGLState *mState;
+
+        struct States
+        {
+            bool glCheck;
+            Surface::Format sformat, dformat;
+            GraphicsEngine::CompositionMode mode;
+            std::set<GLenum> caps;
+        };
+        States states;
+
+        friend class OpenGLState;
+    };
+
+private:
+    inline void flushScope() {
+        assert(!mScopes.empty());
+        flushScope(mScopes.back());
+    }
+    inline void startScope(Scope *scope);
+    inline void flushScope(Scope *scope);
+    inline void endScope(Scope *scope);
+    inline void scissor(ScissorMode mode, bool force = false);
+
+private:
+    Rect mClip;
+    std::vector<Scope*> mScopes;
+    Scope::States mStates;
+    GLenum mActiveTexture;
+    std::map<GLenum, GLuint> mTextures;
+    GLuint mProgram, mFbo;
+    std::set<GLuint> mVAA;
+    struct {
+        GLenum source_function_rgb, source_function_alpha;
+        GLenum dest_function_rgb, dest_function_alpha;
+        GLenum equation_rgb, equation_alpha;
+        GLfloat red, green, blue, alpha;
+    } mBlend;
+    struct {
+        GLenum cull;
+        GLenum front;
+    } mFace;
+    GLenum mScreenReadBuffer;
+    std::map<GLenum, GLuint> mBuffers;
+
+    struct TexParams
+    {
+        TexParams() : mag_filter(GL_INVALID_VALUE), min_filter(GL_INVALID_VALUE),
+                      wrap_s(GL_INVALID_VALUE), wrap_t(GL_INVALID_VALUE) {  }
+        GLint mag_filter, min_filter;
+        GLint wrap_s, wrap_t;
+    };
+    std::map<GLuint, TexParams> mTexParams;
+
+    struct GLRect
+    {
+        GLRect() : x(0), y(0), width(-1), height(-1) { }
+        GLint x, y;
+        GLsizei width, height;
+    };
+    GLRect mViewport, mScissor;
+
+    friend class Scope;
+};
+
+inline OpenGLState::OpenGLState() : mProgram(0), mFbo(0)
+{
+    mActiveTexture = GL_TEXTURE0;;
+    mTextures[mActiveTexture] = 0;
+    mBlend.source_function_rgb = mBlend.source_function_alpha = GL_INVALID_ENUM;
+    mBlend.dest_function_rgb = mBlend.dest_function_alpha = GL_INVALID_ENUM;
+    mBlend.red = mBlend.green = mBlend.blue = mBlend.alpha = 0.0f;
+    mBlend.equation_rgb = mBlend.equation_alpha = GL_FUNC_ADD;
+    mScreenReadBuffer = GL_FRONT;
+    mFace.front = GL_CCW;
+    mFace.cull = GL_BACK;
+    mStates.sformat = mStates.dformat = Surface::Format_None;
+    mStates.mode = GraphicsEngine::CompositionMode_Source;
+}
+
+inline OpenGLState::~OpenGLState()
+{
+}
+
+inline void OpenGLState::reset()
+{
+    blendColor(0.0f, 0.0f, 0.0f, 0.0f);
+    blendEquation(GL_FUNC_ADD, GL_FUNC_ADD);
+    mScreenReadBuffer = GL_FRONT;
+    face(GL_BACK, GL_CCW);
+    if(int t = texture())
+        resetTexture(t);
+    GL_ASSERT(this);
+}
+
+inline void OpenGLState::resetTexture(GLuint tex)
+{
+    setWrap(tex, GL_CLAMP_TO_EDGE, GL_CLAMP_TO_EDGE);
+    setFilter(tex, GL_NEAREST, GL_NEAREST);
+    GL_ASSERT(this);
+}
+
+inline void OpenGLState::viewport(GLint x, GLint y, GLsizei width, GLsizei height, bool force)
+{
+    if(!force && mViewport.x == x && mViewport.y == y && mViewport.width == width && mViewport.height == height)
+        return;
+    mViewport.x = x;
+    mViewport.y = y;
+    mViewport.width = width;
+    mViewport.height = height;
+    glViewport(x, y, width, height);
+    GL_ASSERT(this);
+}
+
+inline void OpenGLState::scissor(ScissorMode mode, bool force)
+{
+    GLRect rclip;
+    if(mode == ScissorInclusive) {
+        rclip.x = floorf(mClip.x);
+        rclip.y = floorf(mClip.y);
+        rclip.width = ceilf(mClip.width + (mClip.x - rclip.x));
+        rclip.height = ceilf(mClip.height + (mClip.y - rclip.y));
+    } else {
+        rclip.x = ceilf(mClip.x);
+        rclip.y = ceilf(mClip.y);
+        rclip.width = floorf(mClip.width - (rclip.x - mClip.x));
+        rclip.height = floorf(mClip.height - (rclip.y - mClip.y));
+    }
+    if(!force && mScissor.x == rclip.x && mScissor.y == rclip.y && mScissor.width == rclip.width && mScissor.height == rclip.height)
+        return;
+    mScissor = rclip;
+    glScissor(rclip.x, rclip.y, rclip.width, rclip.height);
+    GL_ASSERT(this);
+}
+
+inline void OpenGLState::useProgram(GLuint prog)
+{
+    if(prog == mProgram)
+        return;
+    for(std::set<GLuint>::const_iterator it = mVAA.begin(); it != mVAA.end(); ++it)
+        glDisableVertexAttribArray(*it);
+    mVAA.clear();
+    mProgram = prog;
+    if(mProgram)
+        glUseProgram(mProgram);
+    GL_ASSERT(this);
+}
+
+inline void OpenGLState::deleteProgram(GLuint prog)
+{
+    useProgram(0);
+    NRDP_OBJECTCOUNT_DEREF(OpenGLResourceProgram, prog);
+    glDeleteProgram(prog);
+    GL_ASSERT(this);
+}
+
+inline void OpenGLState::enableVAA(GLuint index, bool enable)
+{
+    if(enable) {
+        if(mVAA.find(index) != mVAA.end())
+            return;
+        mVAA.insert(index);
+        glEnableVertexAttribArray(index);
+    } else {
+        if(mVAA.find(index) == mVAA.end())
+            return;
+        mVAA.erase(index);
+        glDisableVertexAttribArray(index);
+    }
+}
+
+inline void OpenGLState::activeTexture(GLenum tex, bool force)
+{
+    if(!force && tex == mActiveTexture)
+        return;
+    mActiveTexture = tex;
+    glActiveTexture(mActiveTexture);
+    GL_ASSERT(this);
+}
+
+inline void OpenGLState::bindTexture(GLuint tex, bool force)
+{
+    if(!force && tex == texture())
+        return;
+
+    mTextures[mActiveTexture] = tex;
+    glBindTexture(GL_TEXTURE_2D, tex);
+    GL_ASSERT(this);
+}
+
+inline void OpenGLState::unbindTexture(GLuint tex)
+{
+    GL_ASSERT(this);
+    for(std::map<GLenum, GLuint>::iterator it = mTextures.begin(); it != mTextures.end(); ++it) {
+        if(it->second == tex) {
+            glActiveTexture(it->first);
+            GL_ASSERT(this);
+            glBindTexture(GL_TEXTURE_2D, 0);
+            it->second = 0;
+            GL_ASSERT(this);
+        }
+    }
+    glActiveTexture(mActiveTexture);
+    GL_ASSERT(this);
+}
+
+inline void OpenGLState::bindFramebuffer(GLuint f)
+{
+    if(f == mFbo)
+        return;
+    mFbo = f;
+    glBindFramebuffer(GL_FRAMEBUFFER, f);
+    GL_ASSERT(this);
+}
+
+inline void OpenGLState::setWrap(GLuint tex, GLint wrap_s, GLint wrap_t, bool force)
+{
+    TexParams &params = mTexParams[tex];
+    if(force || params.wrap_s != wrap_s || params.wrap_t != wrap_t) {
+        const GLuint oldTexture = texture();
+        if(NRDP_UNLIKELY(tex != oldTexture))
+            glBindTexture(GL_TEXTURE_2D, tex);
+        if(force || params.wrap_t != wrap_t) {
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, wrap_t);
+            params.wrap_t = wrap_t;
+        }
+        if(force || params.wrap_s != wrap_s) {
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, wrap_s);
+            params.wrap_s = wrap_s;
+        }
+        if(NRDP_UNLIKELY(tex != oldTexture))
+            glBindTexture(GL_TEXTURE_2D, oldTexture);
+        GL_ASSERT(this);
+    }
+}
+
+inline void OpenGLState::setWrap(GLint wrap_s, GLint wrap_t, bool force)
+{
+    setWrap(texture(), wrap_s, wrap_t, force);
+}
+
+inline void OpenGLState::setFilter(GLuint tex, GLint min_filter, GLint mag_filter, bool force)
+{
+    TexParams &params = mTexParams[tex];
+    if(force || params.min_filter != min_filter || params.mag_filter != mag_filter) {
+        const GLuint oldTexture = texture();
+        if(NRDP_UNLIKELY(tex != oldTexture))
+            glBindTexture(GL_TEXTURE_2D, tex);
+        if(force || params.mag_filter != mag_filter) {
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, mag_filter);
+            params.mag_filter = mag_filter;
+        }
+        if(force || params.min_filter != min_filter) {
+            glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, min_filter);
+            params.min_filter = min_filter;
+        }
+        if(NRDP_UNLIKELY(tex != oldTexture))
+            glBindTexture(GL_TEXTURE_2D, oldTexture);
+        GL_ASSERT(this);
+    }
+}
+
+inline void OpenGLState::setFilter(GLint min_filter, GLint mag_filter, bool force)
+{
+    setFilter(texture(), min_filter, mag_filter, force);
+}
+
+inline void OpenGLState::setSmoothScale(GLuint tex, bool smooth)
+{
+    const GLint filter = (smooth ? GL_LINEAR : GL_NEAREST);
+    setFilter(tex, filter, filter);
+}
+
+inline void OpenGLState::setSmoothScale(bool smooth)
+{
+    setSmoothScale(texture(), smooth);
+}
+
+inline void OpenGLState::blendFunc(GLenum source_function_rgb, GLenum dest_function_rgb,
+                                    GLenum source_function_alpha, GLenum dest_function_alpha, bool force)
+{
+    if(!force &&
+       mBlend.source_function_rgb == source_function_rgb && mBlend.source_function_alpha == source_function_alpha &&
+       mBlend.dest_function_rgb == dest_function_rgb && mBlend.dest_function_alpha == dest_function_alpha)
+        return;
+    mBlend.source_function_rgb = source_function_rgb;
+    mBlend.dest_function_rgb = dest_function_rgb;
+    mBlend.source_function_alpha = source_function_alpha;
+    mBlend.dest_function_alpha = dest_function_alpha;
+    if(GibbonDebug::DebugGLState)
+        Log::error(TRACE_LOG) << "glBlendFuncSeparate" << " -- "
+                              << StringFormatter::hex(source_function_rgb) << StringFormatter::hex(dest_function_rgb)
+                              << StringFormatter::hex(source_function_alpha) << StringFormatter::hex(dest_function_alpha);
+    glBlendFuncSeparate(source_function_rgb, dest_function_rgb, source_function_alpha, dest_function_alpha);
+    GL_ASSERT(this);
+}
+
+inline void OpenGLState::blendEquation(GLenum rgb, GLenum alpha, bool force)
+{
+    if(!force && mBlend.equation_rgb == rgb && mBlend.equation_alpha == alpha)
+        return;
+    mBlend.equation_rgb = rgb;
+    mBlend.equation_alpha = alpha;
+    if(GibbonDebug::DebugGLState)
+        Log::error(TRACE_LOG) << "glBlendEquationSeparate" << " -- " << StringFormatter::hex(rgb) << StringFormatter::hex(alpha);
+    glBlendEquationSeparate(rgb, alpha);
+    GL_ASSERT(this);
+}
+
+inline void OpenGLState::face(GLenum cull, GLenum front, bool force)
+{
+    if(!force && mFace.front == front && mFace.cull == cull)
+        return;
+    mFace.cull = cull;
+    mFace.front = front;
+    if(GibbonDebug::DebugGLState)
+        Log::error(TRACE_LOG) << "glFace" << " -- " << StringFormatter::hex(cull) << StringFormatter::hex(front);
+    glFrontFace(front);
+    glCullFace(cull);
+    GL_ASSERT(this);
+}
+
+inline void OpenGLState::blendColor(GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha, bool force)
+{
+    if(!force && mBlend.red == red && mBlend.green == green && mBlend.blue == blue && mBlend.alpha == alpha)
+        return;
+    mBlend.red = red;
+    mBlend.green = green;
+    mBlend.blue = blue;
+    mBlend.alpha = alpha;
+    if(GibbonDebug::DebugGLState)
+        Log::error(TRACE_LOG) << "glBlendColor" << " -- " << red << green << blue << alpha;
+    glBlendColor(red, green, blue, alpha);
+    GL_ASSERT(this);
+}
+
+inline void OpenGLState::bindBuffer(GLenum target, GLuint buffer)
+{
+    std::map<GLenum, GLuint>::iterator entry = mBuffers.find(target);
+    if(entry != mBuffers.end()) {
+        if(entry->second == buffer)
+            return;
+        entry->second = buffer;
+    } else {
+        mBuffers[target] = buffer;
+    }
+    glBindBuffer(target, buffer);
+    GL_ASSERT(this);
+}
+
+inline void OpenGLState::deleteTexture(GLuint tex)
+{
+    unbindTexture(tex);
+    NRDP_OBJECTCOUNT_DEREF(OpenGLResourceTexture, tex);
+    glDeleteTextures(1, &tex);
+    mTexParams.erase(tex);
+    GL_ASSERT(this);
+}
+
+inline void OpenGLState::deleteBuffer(GLuint buffer)
+{
+    NRDP_OBJECTCOUNT_DEREF(OpenGLResourceVBO, buffer);
+    glDeleteBuffers(1, &buffer);
+    for(std::map<GLenum, GLuint>::iterator it = mBuffers.begin(); it != mBuffers.end(); ) {
+        if(it->second == buffer)
+            it = mBuffers.erase(it);
+        else
+            ++it;
+    }
+    GL_ASSERT(this);
+}
+
+inline void OpenGLState::startScope(Scope *s)
+{
+    mScopes.push_back(s);
+}
+
+template<typename T>
+inline void nf_gl_flushEntries(const std::set<T> &s, void (*func)(T), const char *desc)
+{
+    NRDP_UNUSED(desc);
+    typename std::set<T>::const_iterator r = s.begin();
+    const typename std::set<T>::const_iterator e = s.end();
+    while(r != e) {
+        if(GibbonDebug::DebugGLState)
+            Log::error(TRACE_LOG) << "nf_gl_flushEntries::" << desc << " -- " << StringFormatter::hex(*r);
+        func(*r);
+        ++r;
+    }
+}
+
+template<typename T>
+inline void nf_gl_flushEntries(const std::set<T> &s1, const std::set<T> &s2, void (*func)(T), const char *desc)
+{
+    std::set<T> result;
+    std::set_difference(s1.begin(), s1.end(), s2.begin(), s2.end(), std::inserter(result, result.end()));
+    nf_gl_flushEntries(result, func, desc);
+}
+
+inline void OpenGLState::flush()
+{
+    nf_gl_flushEntries<GLenum>(mStates.caps, glEnable, "flush::glEnable");
+    mScissor = GLRect();
+    GL_ASSERT(this);
+}
+
+inline void OpenGLState::flushScope(Scope *scope)
+{
+    bool blend = true;
+    switch(scope->states.mode) {
+    case GraphicsEngine::CompositionMode_Clear:
+        blendFunc(GL_ZERO, GL_ZERO);
+        break;
+    case GraphicsEngine::CompositionMode_Source:
+        blend = false;
+#if 1
+        if((scope->states.sformat & Surface::Flag_Alpha) && !(scope->states.sformat & Surface::Flag_Premultiplied)) {
+            blendFunc(GL_SRC_ALPHA, GL_ZERO, GL_ONE, GL_ZERO);
+            blend = true;
+        }
+#endif
+        break;
+    case GraphicsEngine::CompositionMode_SourceOver: {
+        GLenum sRGB = GL_ONE, dRGB = GL_ONE_MINUS_SRC_ALPHA, sAlpha = GL_ONE, dAlpha = GL_ONE_MINUS_SRC_ALPHA;
+#if 1
+        if(!(scope->states.sformat & Surface::Flag_Premultiplied)) {
+            sRGB = GL_SRC_ALPHA;
+            dRGB = GL_ONE_MINUS_SRC_ALPHA;
+            sAlpha = GL_ONE;
+            dAlpha = GL_ONE_MINUS_SRC_ALPHA;
+        }
+#endif
+        blendFunc(sRGB, dRGB, sAlpha, dAlpha);
+        break; }
+    case GraphicsEngine::CompositionMode_DestinationOver: {
+        GLenum sRGB = GL_ONE_MINUS_DST_ALPHA, dRGB = GL_ONE;
+        GLenum sAlpha = sRGB, dAlpha = dRGB;
+#if 1
+        if(!(scope->states.sformat & Surface::Flag_Premultiplied))
+            sAlpha = GL_DST_ALPHA;
+        // if(!(scope->states.dformat & Surface::Flag_Premultiplied))
+        //     dRGB = GL_DST_ALPHA;
+#endif
+        blendFunc(sRGB, dRGB, sAlpha, dAlpha);
+        break; }
+    case GraphicsEngine::CompositionMode_SourceIn:
+        blendFunc(GL_DST_ALPHA, GL_ZERO);
+        break;
+    case GraphicsEngine::CompositionMode_DestinationIn:
+        blendFunc(GL_ZERO, GL_SRC_ALPHA);
+        break;
+    case GraphicsEngine::CompositionMode_SourceOut:
+        blendFunc(GL_ONE_MINUS_DST_ALPHA, GL_ZERO);
+        break;
+    case GraphicsEngine::CompositionMode_DestinationOut:
+        blendFunc(GL_ZERO, GL_ONE_MINUS_SRC_ALPHA);
+        break;
+    case GraphicsEngine::CompositionMode_SourceAtop:
+        blendFunc(GL_ONE_MINUS_DST_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+        break;
+    case GraphicsEngine::CompositionMode_Add:
+        blendFunc(GL_ONE, GL_ONE);
+        break;
+    case GraphicsEngine::CompositionMode_XOR:
+        blendFunc(GL_ONE_MINUS_DST_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
+        break;
+    case GraphicsEngine::CompositionMode_Destination:
+        blendFunc(GL_ONE, GL_ZERO);
+        break;
+    }
+    if(!scope->hasCap(GL_BLEND))
+        scope->enableCap(GL_BLEND, blend);
+
+    nf_gl_flushEntries<GLenum>(mStates.caps, scope->states.caps, glDisable, "glDisable");
+    nf_gl_flushEntries<GLenum>(scope->states.caps, mStates.caps, glEnable, "glEnable");
+    mStates = scope->states;
+    GL_ASSERT(this);
+}
+
+inline void OpenGLState::endScope(Scope *scope)
+{
+    assert(!mScopes.empty());
+    assert(mScopes.back() == scope);
+    NRDP_UNUSED(scope);
+    mScopes.pop_back();
+}
+
+}
+}
+
+#endif
diff --git a/partner/graphics/rpi/OpenGLVBO.cpp b/partner/graphics/rpi/OpenGLVBO.cpp
new file mode 100644
index 00000000..5ca9819e
--- /dev/null
+++ b/partner/graphics/rpi/OpenGLVBO.cpp
@@ -0,0 +1,19 @@
+/* (c) 2017 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+
+#include "OpenGLVBO.h"
+#include "OpenGLContext.h"
+
+using namespace netflix;
+using namespace netflix::gibbon;
+
+OpenGLVBO::OpenGLVBO(OpenGLContext *ctx)
+{
+    mVbo = ctx->createVBO();
+}
+
+OpenGLVBO::~OpenGLVBO()
+{
+    OpenGLContext::deleteBuffer(mVbo);
+}
+
+
diff --git a/partner/graphics/rpi/OpenGLVBO.h b/partner/graphics/rpi/OpenGLVBO.h
new file mode 100644
index 00000000..427ba117
--- /dev/null
+++ b/partner/graphics/rpi/OpenGLVBO.h
@@ -0,0 +1,28 @@
+/* (c) 2017 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+
+#ifndef __OPENGLVBO_H__
+#define __OPENGLVBO_H__
+
+#include <GraphicsEngine.h>
+
+namespace netflix {
+namespace gibbon {
+
+class OpenGLVBO : public std::enable_shared_from_this<OpenGLVBO>
+{
+public:
+    typedef std::shared_ptr<OpenGLVBO> SharedPtr;
+    typedef std::weak_ptr<OpenGLVBO> WeakPtr;
+
+    OpenGLVBO(OpenGLContext *ctx);
+    ~OpenGLVBO();
+
+    GLuint vbo() const { return mVbo; }
+
+private:
+    GLuint mVbo;
+};
+
+}} // namespace netflix::gibbon
+
+#endif /* __OPENGLVBO_H__ */
diff --git a/partner/graphics/rpi/PlayerGLES2.cpp b/partner/graphics/rpi/PlayerGLES2.cpp
new file mode 100644
index 00000000..237bb3ac
--- /dev/null
+++ b/partner/graphics/rpi/PlayerGLES2.cpp
@@ -0,0 +1,94 @@
+/* (c) 2015 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+
+#include "Player.h"
+#include "Screen.h"
+#include "Widget.h"
+#include "OpenGLState.h"
+#include "SurfaceCache.h"
+#include "OpenGLContext.h"
+
+using namespace netflix;
+using namespace netflix::gibbon;
+
+void Player::init()
+{
+    mTexture = 0;
+}
+
+class PlayerLazyCleanup : public OpenGLContext::LazyCleanup
+{
+public:
+    inline PlayerLazyCleanup(std::shared_ptr<netflix::mediacontrol::IMediaSourcePlayer> &player) : mPlayer(player) { }
+    virtual void execute() override {
+        if(std::shared_ptr<netflix::mediacontrol::IMediaSourcePlayer> player = mPlayer.lock())
+            cleanup(player);
+    }
+    static void cleanup(const std::shared_ptr<netflix::mediacontrol::IMediaSourcePlayer> &player) {
+        NRDP_UNUSED(player);
+#if 0
+        OpenGLContext::ensureContext();
+        player->cleanup();
+#endif
+    }
+private:
+    std::weak_ptr<netflix::mediacontrol::IMediaSourcePlayer> mPlayer;
+};
+
+void Player::cleanup()
+{
+    if(mTexture) {
+        if(mPlayer) {
+            if(Animation::isAnimationThread())
+                PlayerLazyCleanup::cleanup(mPlayer);
+            else
+                OpenGLContext::addLazyCleanup(new PlayerLazyCleanup(mPlayer));
+        }
+        OpenGLContext::deleteTexture(mTexture);
+    }
+}
+
+void Player::renderTexture(GraphicsEngine *graphics, const Rect &dst)
+{
+    int width, height;
+    if(!graphics) {
+        mPlayer->render(0, &width, &height, false);
+        return;
+    }
+
+    OpenGLState *glstate = OpenGLContext::context()->state();
+    bool force = false;
+    if(!mTexture) {
+        mTexture = OpenGLContext::context()->createTexture();
+        force = true;
+    } else {
+        glstate->bindTexture(mTexture);
+    }
+    GL_ASSERT(glstate);
+    PlayerGLES2TextureStruct texture = { mTexture, false };
+    mPlayer->render(&texture, &width, &height, force);
+    GL_ASSERT(glstate);
+    if(width && height) {
+        Surface::Flags videoTextureFlags = Surface::Flags::construct(gibbonApp()->getScreen()->getSurfaceFormat(Screen::SurfaceFormat_Video));
+        if(texture.bt2020)
+            videoTextureFlags |= Surface::Flag_PQ2020;
+
+        const float hratio = static_cast<float>(dst.width) / static_cast<float>(width);
+        const float vratio = static_cast<float>(dst.height) / static_cast<float>(height);
+
+        const Point dstCenter = dst.center();
+        Coordinate dstWidth = width, dstHeight = height;
+        if(getMode() == Mode_Plane) {
+            const float ratio = (hratio <= vratio ? hratio : vratio);
+            dstWidth *= ratio;
+            dstHeight *= ratio;
+        } else {
+            dstWidth *= hratio;
+            dstHeight *= vratio;
+        }
+
+        const GLfloat texTransform[4] = { 0, 0, 1, 1 };
+        OpenGLContext::context()->loadEngineState(graphics, true);
+        graphics->drawTexture(mTexture, texTransform, Rect(dstCenter.x-(dstWidth/2), dstCenter.y-dstHeight/2, dstWidth, dstHeight), videoTextureFlags);
+    }
+}
+
diff --git a/partner/graphics/rpi/ScreenGLES2.cpp b/partner/graphics/rpi/ScreenGLES2.cpp
new file mode 100644
index 00000000..3b96422a
--- /dev/null
+++ b/partner/graphics/rpi/ScreenGLES2.cpp
@@ -0,0 +1,440 @@
+/* (c) 2012 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+
+#include <Screen.h>
+#include "OpenGLFBO.h"
+#include "OpenGLContext.h"
+#include "EffectsGLES2.h"
+#ifdef GIBBON_NVIDIA_CAPTURE
+#include "OpenGLCapture.h"
+#endif
+
+using namespace netflix::gibbon;
+using namespace netflix;
+
+#if !defined(GIBBON_NO_THREADANIMATION)
+class FocusEvent : public Application::Event
+{
+public:
+    FocusEvent(const Screen::SharedPtr& s)
+        : screen(s)
+    {
+    }
+
+    virtual void eventFired() override
+    {
+        if (Screen::SharedPtr s = screen.lock()) {
+            s->focus();
+        }
+    }
+
+private:
+    Screen::WeakPtr screen;
+};
+#endif
+
+class ColorSpaceConvertGLES2 : public netflix::device::IColorSpaceConvert
+{
+    class Shader : public RectShader
+    {
+    public:
+        enum { TexCoord = RectShader::Last+1, Alpha, Coefficients, SignalRange_Offsets, SignalRange_Scales, Scale_YA, Scale_UV, Last = Scale_UV };
+
+        Shader(OpenGLContext *ctx, const std::string &name="ColorSpaceConverter::Shader") : RectShader(ctx, name)
+        {
+        }
+
+    protected:
+
+        virtual std::string vertexDeclarations() const override
+        {
+            return RectShader::vertexDeclarations() +
+                "attribute vec2 a_texCoord;\n"
+                "varying vec2   v_texCoord;\n";
+        }
+
+        virtual std::string vertexBody() const override
+        {
+            return RectShader::vertexBody() +
+                "  v_texCoord = a_texCoord;\n";
+        }
+
+        virtual std::string fragmentDeclarations() const override
+        {
+            return RectShader::fragmentDeclarations() +
+                "varying vec2      v_texCoord;\n"
+                "uniform vec2      u_scale_ya;\n"
+                "uniform vec2      u_scale_uv;\n"
+                "uniform mat3      u_yuv_coefficients;\n"
+                "uniform vec3      u_yuv_signalrange_offsets;\n"
+                "uniform vec3      u_yuv_signalrange_scales;\n"
+                "uniform int       u_alpha;\n"
+                "uniform sampler2D s_texture_y;\n"
+                "uniform sampler2D s_texture_u;\n"
+                "uniform sampler2D s_texture_v;\n"
+                "uniform sampler2D s_texture_a;\n";
+        }
+        virtual std::string fragmentBody() const override
+        {
+            return RectShader::fragmentBody() +
+                "  vec3 yuv = vec3(texture2D(s_texture_y, v_texCoord * u_scale_ya)[0],\n"
+                "                  texture2D(s_texture_u, v_texCoord * u_scale_uv)[0],\n"
+                "                  texture2D(s_texture_v, v_texCoord * u_scale_uv)[0]);\n"
+                "  yuv = (yuv - u_yuv_signalrange_offsets) * u_yuv_signalrange_scales;\n"
+                "  yuv = clamp(yuv, 0.0, 1.0);\n"
+                "  yuv = yuv + vec3(0.0, -0.5, -0.5);\n"
+                "  fragcolor.a = (u_alpha == 1) ? texture2D(s_texture_a, v_texCoord * u_scale_ya)[0] : 1.0;\n"
+                "  fragcolor.rgb = yuv * u_yuv_coefficients * fragcolor.a;\n";
+        }
+        virtual void define() override
+        {
+            assert(isValid());
+            mProgram->reserveVariables(Shader::Last);
+
+            RectShader::define();
+            mProgram->defineUniform(Shader::Alpha, "u_alpha");
+            mProgram->defineUniform(Shader::Coefficients, "u_yuv_coefficients");
+            mProgram->defineUniform(Shader::SignalRange_Offsets, "u_yuv_signalrange_offsets");
+            mProgram->defineUniform(Shader::SignalRange_Scales, "u_yuv_signalrange_scales");
+            mProgram->defineUniform(Shader::Scale_YA, "u_scale_ya");
+            mProgram->defineUniform(Shader::Scale_UV, "u_scale_uv");
+            mProgram->defineAttribute(Shader::TexCoord, "a_texCoord");
+            glUniform1i(mProgram->uniformLocation("s_texture_y"), 1);
+            glUniform1i(mProgram->uniformLocation("s_texture_u"), 2);
+            glUniform1i(mProgram->uniformLocation("s_texture_v"), 3);
+            glUniform1i(mProgram->uniformLocation("s_texture_a"), 4);
+        }
+
+        virtual void bind() override
+        {
+            RectShader::bind();
+
+            bindVertexBuffer();
+
+            const GLint tex = program()->variable(Shader::TexCoord);
+            glVertexAttribPointer(tex, 2, GL_FLOAT, GL_FALSE, 4 * sizeof(GLfloat), (GLvoid*)(2*sizeof(GLfloat)));
+            context()->state()->enableVAA(tex);
+        }
+    };
+
+public:
+    ColorSpaceConvertGLES2() : mTexturesSize(0) {
+        mShader.reset(new Shader(OpenGLContext::context()));
+        memset(mTextures, 0, sizeof(mTextures));
+    }
+    ~ColorSpaceConvertGLES2() {
+        if(std::shared_ptr<SurfaceCache> surfaceCache = GibbonApplication::instance()->getSurfaceCache())
+            surfaceCache->reserve(-mTexturesSize);
+        for(int i = 0; i < 4; ++i) {
+            if(mTextures[i])
+                OpenGLContext::deleteTexture(mTextures[i]);
+        }
+    }
+
+    virtual void convert(void *priv, const uint8_t *const srcChannel[], const uint32_t srcStride[], const uint32_t srcWidth[], const uint32_t srcHeight[]) override
+    {
+        assert(priv);
+        const PlayerGLES2TextureStruct *texture = (PlayerGLES2TextureStruct*)priv;
+        OpenGLContext *context = OpenGLContext::context();
+        OpenGLState *glstate = context->state();
+        GL_ASSERT(glstate);
+
+        OpenGLShader::Scope scope(mShader);
+        GL_ASSERT(glstate);
+        OpenGLProgram::SharedPtr program = mShader->program();
+        GL_ASSERT(glstate);
+
+        glUniformMatrix4fv(program->variable(Shader::ProjMatrix), 1, GL_FALSE, Transform().matrix());
+        glUniformMatrix4fv(program->variable(Shader::MVMatrix), 1, GL_FALSE, Transform().matrix());
+
+        static GLfloat const yuv_signalrange_offsets[3] = {
+            16.0f / 255.0f, // y
+            16.0f / 255.0f, // u
+            16.0f / 255.0f  // v
+        };
+        glUniform3fv(program->variable(Shader::SignalRange_Offsets), 1, yuv_signalrange_offsets);
+
+        static GLfloat const yuv_signalrange_scales[3] = {
+            255.0f / (235.0f - 16.0f), // y
+            255.0f / (240.0f - 16.0f), // u
+            255.0f / (240.0f - 16.0f)  // v
+        };
+        glUniform3fv(program->variable(Shader::SignalRange_Scales), 1, yuv_signalrange_scales);
+
+        static GLfloat const yuv_coefficients[9] = {
+            //     y          u          v
+            1.00000f,  0.00000f,  1.40200f, // red
+            1.00000f, -0.34413f, -0.71413f, // green
+            1.00000f,  1.77120f,  0.00000f  // blue
+        };
+        glUniformMatrix3fv(program->variable(Shader::Coefficients), 1, GL_FALSE, yuv_coefficients);
+
+        glUniform2f(program->variable(Shader::Scale_YA), static_cast<GLfloat>(srcWidth[0])/srcStride[0], 1.0f);
+        glUniform2f(program->variable(Shader::Scale_UV), static_cast<GLfloat>(srcWidth[1])/srcStride[1], 1.0f);
+        glUniform1i(program->variable(Shader::Alpha), srcChannel[3] ? 1 : 0);
+
+        OpenGLState::Scope stateScope(glstate);
+        stateScope.enableScissor(false);
+
+        const Surface::Format format = gibbonApp()->getScreen()->getSurfaceFormat(Screen::SurfaceFormat_Video);
+        stateScope.setFormat(format, format);
+        stateScope.setCompositionMode(GraphicsEngine::CompositionMode_Source);
+
+        const GLfloat vertices[4] = { -1, -1, 1, 1 };
+        glUniform4fv(program->variable(Shader::Rect), 1, vertices);
+
+        glstate->setSmoothScale(false);
+
+        ssize_t texturesSize = 0;
+        for(uint32_t i = 0; (i < 4) && srcChannel[i]; ++i) {
+            glstate->activeTexture(GL_TEXTURE0+i+1);
+            if(!mTextures[i])
+                mTextures[i] = context->createTexture();
+            else
+                glstate->bindTexture(mTextures[i]);
+            glTexImage2D(GL_TEXTURE_2D, 0, GL_LUMINANCE, srcStride[i], srcHeight[i], 0, GL_LUMINANCE, GL_UNSIGNED_BYTE, srcChannel[i]);
+            texturesSize += srcStride[i] * srcHeight[i];
+        }
+
+        stateScope.flush();
+
+        glstate->activeTexture(GL_TEXTURE0);
+        glstate->bindTexture(texture->texture);
+        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, srcWidth[0], srcHeight[0], 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
+        texturesSize += srcWidth[0] * srcHeight[0] * 4;
+        GL_ASSERT(glstate);
+
+        if(std::shared_ptr<SurfaceCache> surfaceCache = GibbonApplication::instance()->getSurfaceCache()) {
+            if(mTexturesSize)
+                surfaceCache->reserve(-mTexturesSize);
+            surfaceCache->reserve(mTexturesSize = texturesSize);
+        }
+
+        OpenGLFBO::SharedPtr fbo = OpenGLFBO::take(texture->texture, Size(srcWidth[0], srcHeight[0]), GraphicsEngine::ColorBuffer);
+        glstate->bindFramebuffer(fbo->fbo());
+        glstate->viewport(0, 0, srcWidth[0], srcHeight[0]);
+        GL_ASSERT(glstate);
+
+        mShader->render();
+        GL_ASSERT(glstate);
+    }
+
+private:
+    GLuint mTextures[4];
+    ssize_t mTexturesSize;
+    std::shared_ptr<Shader> mShader;
+};
+
+Screen::Configuration Screen::sConfiguration(-1);
+
+std::shared_ptr<netflix::device::IColorSpaceConvert> Screen::createColorSpaceConvert()
+{
+    return std::shared_ptr<netflix::device::IColorSpaceConvert>(new ColorSpaceConvertGLES2);
+}
+
+Effect::SharedPtr Screen::createEffect(Effect::Type type)
+{
+    Effect::SharedPtr effect;
+    switch (type) {
+    case Effect::Type_Desaturate: {
+        effect.reset(new EffectDesaturateGLES2);
+        break; }
+    case Effect::Type_ChromaKey: {
+        effect.reset(new EffectChromaKeyGLES2);
+        break; }
+    case Effect::Type_Blur: {
+        effect.reset(new EffectBlurGLES2);
+        break; }
+    case Effect::Type_Tint: {
+        effect.reset(new EffectTintGLES2);
+        break; }
+    case Effect::Type_Shader: {
+        effect.reset(new EffectShaderGLES2);
+        break; }
+    default:
+        break;
+    }
+    return effect;
+}
+
+static void initParts(OpenGLShader::Parts &vertex, OpenGLShader::Parts &fragment)
+{
+    vertex.clear();
+    fragment.clear();
+    fragment.push_back(std::shared_ptr<OpenGLShader::Part>(new TextureShader::RGBPart));
+}
+
+static inline void commitParts(EffectRenderers &result, OpenGLShader::Parts &vertex, OpenGLShader::Parts &fragment)
+{
+    if(vertex.empty() && fragment.size() <= 2)
+        return;
+    result.push_back(std::shared_ptr<Effect::Renderer>(new OpenGLShaderManagerRenderer(vertex, fragment)));
+    initParts(vertex, fragment);
+}
+
+EffectRenderers Screen::createEffectRenderers(const Effects &effects)
+{
+    // combine multiple shaders into one if possible
+    OpenGLShader::Parts vertexParts, fragParts;
+    initParts(vertexParts, fragParts);
+
+    int id = 0;
+    std::string name;
+    EffectRenderers result;
+    for(Effects::const_iterator it = effects.begin(); it != effects.end(); ++it) {
+        Effect::SharedPtr effect = (*it);
+        if(effect->isVisible()) {
+            switch (effect->getType()) {
+            case Effect::Type_Tint: {
+                const std::shared_ptr<EffectTintGLES2>& tint = std::static_pointer_cast<EffectTintGLES2>(effect);
+                tint->collectParts(id, vertexParts, fragParts);
+                break; }
+            case Effect::Type_Desaturate: {
+                const std::shared_ptr<EffectDesaturateGLES2>& desaturate = std::static_pointer_cast<EffectDesaturateGLES2>(effect);
+                desaturate->collectParts(id, vertexParts, fragParts);
+                break; }
+            case Effect::Type_ChromaKey: {
+                const std::shared_ptr<EffectChromaKeyGLES2>& chromaKey = std::static_pointer_cast<EffectChromaKeyGLES2>(effect);
+                chromaKey->collectParts(id, vertexParts, fragParts);
+                break; }
+            default:
+                commitParts(result, vertexParts, fragParts);
+                result.push_back(effect->getDefaultRenderer());
+                id = 0;
+                continue;
+            }
+        }
+        ++id;
+    }
+    commitParts(result, vertexParts, fragParts);
+    return result;
+}
+
+Variant Screen::graphicsInfo() const
+{
+    OpenGLContext *ctx = OpenGLContext::context();
+    assert(ctx);
+
+    Variant result;
+    {
+        Variant glLibrary;
+        glLibrary["name"] = "opengl";
+        glLibrary["compiled"] = "";
+        glLibrary["runtime"] = ctx->version();
+        if(ctx->supportsExtension("GL_NVX_gpu_memory_info")) {
+            glLibrary["options"]["GPU_MEMORY_INFO_DEDICATED_VIDMEM_NVX"] = ctx->getIntegerv(0x9047);
+            glLibrary["options"]["GPU_MEMORY_INFO_TOTAL_AVAILABLE_VIDMEM_NVX"] = ctx->getIntegerv(0x9048);
+            glLibrary["options"]["GPU_MEMORY_INFO_CURRENT_AVAILABLE_VIDMEM_NVX"] = ctx->getIntegerv(0x9049);
+        }
+        glLibrary["options"]["formats"] = ctx->formats();
+        glLibrary["options"]["limits"] = ctx->limits();
+        glLibrary["options"]["extensions"] = ctx->extensions();
+        glLibrary["options"]["renderer"] = (const char*)glGetString(GL_RENDERER);
+        glLibrary["options"]["vendor"] = (const char*)glGetString(GL_VENDOR);
+        ctx->graphicsInfo(glLibrary["options"]);
+        result["libraries"] = glLibrary;
+    }
+    result["opengl"]["samples"] = sConfiguration.targetSamples;
+    return result;
+}
+
+void Screen::setConfiguration(const Configuration &config)
+{
+    ScopedMutex screenLock(&Screen::lock());
+    sConfiguration = config;
+    if(GibbonApplication::instance()) {
+        if(std::shared_ptr<Screen> screen = GibbonApplication::instance()->getScreen())
+            screen->mFlags |= Flag_NeedsRestart;
+    }
+}
+
+void Screen::init()
+{
+    mIgnoreNextFocus = false;
+#if !defined(GIBBON_VSYNC_GRAPHICS)
+    mFlags |= Flag_NeedsVsync;
+#endif
+}
+
+void Screen::start_sys()
+{
+    if (!GibbonConfiguration::takeFocus()) {
+        ScopedMutex _lock(&lock());
+        mIgnoreNextFocus = true;
+    }
+    if (sConfiguration.targetSamples == -1)
+        sConfiguration.targetSamples = GibbonConfiguration::multisampleBuffers();
+
+    // Grab a GL context so we have one for the current thread
+    const Size size = getSize();
+    OpenGLContext::setScreenSize(size.width, size.height);
+
+    OpenGLContext *context = OpenGLContext::context();
+    assert(context);
+    if(GibbonDebug::TestGLSurfaceYUV)
+        setSupportedTextureFormat(CustomFormat_YUV);
+    {
+        const std::vector<int> formats = context->formats();
+        for(std::vector<int>::const_iterator it = formats.begin(); it != formats.end(); ++it)
+            setSupportedTextureFormat(*it);
+    }
+
+#ifdef GIBBON_NVIDIA_CAPTURE
+    OpenGLCapture::initialize();
+#endif
+}
+
+void Screen::focus()
+{
+#if !defined(GIBBON_NO_THREADANIMATION)
+    if (!Animation::isAnimationThread()) {
+        if(std::shared_ptr<Screen> screen = GibbonApplication::instance()->getScreen()) {
+            std::shared_ptr<FocusEvent> event(new FocusEvent(screen));
+            Animation::postEvent(event);
+            return;
+        }
+    }
+#endif
+    if (!GibbonConfiguration::takeFocus()) {
+        ScopedMutex _lock(&lock());
+        if (mIgnoreNextFocus) {
+            mIgnoreNextFocus = false;
+            return;
+        }
+    }
+    OpenGLContext *ctx = OpenGLContext::context();
+    ctx->focus();
+}
+
+void Screen::stop_sys()
+{
+#ifdef GIBBON_NVIDIA_CAPTURE
+    OpenGLCapture::cleanup();
+#endif
+    OpenGLContext::shutdown();
+}
+
+void Screen::initWindow()
+{
+    OpenGLContext::createWindow();
+}
+
+bool Screen::prerender_sys(Flags<PreRenderFlag>) const
+{
+    return true;
+}
+
+void Screen::postrender_sys(Flags<PostRenderFlag> flags) const
+{
+    if(flags & PostRenderFlag_Vsync)
+        vsync_internal();
+}
+
+void Screen::flip_sys(const Rect &/*rect*/) const
+{
+    OpenGLContext::context()->flip();
+}
+
+void Screen::setSuspended_sys(bool suspend)
+{
+    setSuspended_internal(suspend);
+}
diff --git a/partner/graphics/rpi/SurfaceGLES2.cpp b/partner/graphics/rpi/SurfaceGLES2.cpp
new file mode 100644
index 00000000..6bcce459
--- /dev/null
+++ b/partner/graphics/rpi/SurfaceGLES2.cpp
@@ -0,0 +1,410 @@
+/* (c) 2012 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+
+#include <gibbon/config.h>
+
+#include <GibbonApplication.h>
+#include <SurfaceDecoder.h>
+#include <OpenGLContext.h>
+#include <OpenGLShaders.h>
+#include <OpenGLState.h>
+#include <Animation.h>
+#include <Surface.h>
+#include <Screen.h>
+
+#include <nrdbase/ConditionData.h>
+
+#include <assert.h>
+
+#ifndef GL_BGRA_EXT
+#define GL_BGRA_EXT 0x80E1
+#endif
+
+#define GL_GPU_MEM_INFO_TOTAL_AVAILABLE_MEM_NVX   0x9048
+#define GL_GPU_MEM_INFO_CURRENT_AVAILABLE_MEM_NVX 0x9049
+
+using namespace netflix;
+using namespace netflix::gibbon;
+
+template <typename UnsignedType>
+static inline UnsignedType round_up_to_power_of_two(UnsignedType value)
+{
+    static_assert(std::is_unsigned<UnsignedType>::value, "Only works for unsigned types");
+    value--;
+    for(size_t i = 1; i < sizeof(value) * CHAR_BIT; i *= 2)
+        value |= value >> i;
+    return ++value;
+}
+namespace netflix {
+namespace gibbon {
+class GLSyncEvent : public GibbonApplication::Event
+{
+public:
+    GLSyncEvent(const Surface::SharedPtr& surface) : mSurface(surface) { }
+
+    virtual void eventFired() override
+    {
+        if(Surface::SharedPtr surface = SurfaceCache::requestSurface(mSurface)) {
+            OpenGLContext::context()->state()->bindTexture(surface->getTexture(), true);
+        }
+    }
+
+private:
+    Surface::WeakPtr mSurface;
+};
+
+class GLReadEvent : public GibbonApplication::Event, public ConditionData<bool>
+{
+public:
+    GLReadEvent(const Surface::SharedPtr& surface, DataBuffer &pixels) : mSurface(surface), mPixels(pixels)
+    {
+    }
+
+    virtual void eventFired() override
+    {
+        assert(OpenGLContext::hasContext());
+        const bool valid = OpenGLContext::context()->readPixels(mSurface, mPixels);
+        signal(valid);
+    }
+    virtual void eventCanceled() override
+    {
+        signal(false);
+    }
+
+    bool isValid() { return value(); }
+
+private:
+    Surface::SharedPtr mSurface;
+    DataBuffer &mPixels;
+};
+}} // netflix::gibbon
+
+static bool  sGLLimits_init = false;
+static GLint sTextureCapacity = -1;
+static GLint sMaxTextureSize = -1;
+
+inline static void initGLLimits()
+{
+    if(Animation::isAnimationThread() && !sGLLimits_init) {
+        glGetIntegerv(GL_MAX_TEXTURE_SIZE, &sMaxTextureSize);
+        if(OpenGLContext::supportsExtension("GL_NVX_gpu_memory_info"))
+            glGetIntegerv(GL_GPU_MEM_INFO_TOTAL_AVAILABLE_MEM_NVX, &sTextureCapacity);
+        sGLLimits_init = true;
+    }
+}
+
+llong Surface::getGraphicsMemoryUsed()
+{
+#if 0
+    initGLLimits();
+    if(Animation::isAnimationThread()) {
+        static bool hasNVXGPUMEMORYINFO = OpenGLContext::supportsExtension("GL_NVX_gpu_memory_info");
+        if(hasNVXGPUMEMORYINFO && sTextureCapacity != -1) {
+            GLint currentTextureAvailable;
+            glGetIntegerv(GL_GPU_MEM_INFO_CURRENT_AVAILABLE_MEM_NVX, &currentTextureAvailable);
+            assert(currentTextureAvailable <= sTextureCapacity);
+            return static_cast<llong>(sTextureCapacity - currentTextureAvailable) * 1024;
+        }
+    }
+#endif
+    return -1;
+}
+
+llong Surface::getGraphicsMemoryCapacity()
+{
+#if 0
+    initGLLimits();
+    if(sTextureCapacity != -1)
+        return static_cast<llong>(sTextureCapacity) * 1024;
+#endif
+    return -1;
+}
+
+bool Surface::validSize(const Size &size)
+{
+    initGLLimits();
+    return (size.width <= sMaxTextureSize && size.height <= sMaxTextureSize);
+}
+
+size_t Surface::estimateSize(Coordinate width, Coordinate height, Surface::Flags flags)
+{
+    return size_t(width * height * bytesPerPixel(flags));
+}
+
+size_t Surface::calculateSize() const
+{
+    if(mTexture) {
+        if(mCompressedTexture)
+            return mCompressedTexture;
+        Coordinate width = getWidth(), height = getHeight();
+        if(GibbonConfiguration::surfaceSizePowerOfTwo()) {
+            width = round_up_to_power_of_two(static_cast<uint32_t>(width));
+            height = round_up_to_power_of_two(static_cast<uint32_t>(height));
+        }
+        return estimateSize(width, height, mFlags);
+    }
+    return 0;
+}
+
+static inline bool hasBGRA8888()
+{
+    static bool has = OpenGLContext::supportsExtension("GL_EXT_texture_format_BGRA8888");
+    return has;
+}
+
+GLenum Surface::internalTextureFormat() const
+{
+    if(mFlags & Surface::Flag_AlphaOnly)
+        return GL_ALPHA;
+    static bool bgra8888 = hasBGRA8888();
+    assert(!(mFlags & Surface::Flag_AlphaFirst));
+    switch(getFormat()) {
+    case Surface::Format_RGBX32:
+    case Surface::Format_RGBA32:
+    case Surface::Format_RGBA32_Premultiplied:
+        return GL_RGBA;
+    case Surface::Format_RGB24:
+        return GL_RGB;
+    case Surface::Format_BGRX32:
+    case Surface::Format_BGRA32:
+    case Surface::Format_BGRA32_Premultiplied:
+        return bgra8888 ? GL_BGRA_EXT : GL_RGBA;
+    default:
+        assert(false);
+        break;
+    }
+    return GL_RGB;
+}
+
+GLenum Surface::textureFormat() const
+{
+    if(mFlags & Surface::Flag_AlphaOnly)
+        return GL_ALPHA;
+    assert(!(mFlags & Surface::Flag_AlphaFirst));
+    switch(getFormat()) {
+    case Surface::Format_RGBX32:
+    case Surface::Format_RGBA32:
+    case Surface::Format_RGBA32_Premultiplied:
+        return GL_RGBA;
+    case Surface::Format_RGB24:
+        return GL_RGB;
+    case Surface::Format_BGRX32:
+    case Surface::Format_BGRA32:
+    case Surface::Format_BGRA32_Premultiplied:
+        return GL_BGRA_EXT;
+    default:
+        assert(false);
+        break;
+    }
+    return GL_RGB;
+}
+
+void Surface::createTexture_internal(bool realize)
+{
+    assert(!mTexture);
+    assert(!isScreen());
+    assert(validSize(mSize));
+    mTexture = OpenGLContext::context()->createTexture(internalTextureFormat(), textureFormat(), getWidth(), getHeight());
+    if(!mTexture)
+        mValid = false;
+    if(realize)
+        sizeChanged();
+}
+
+void Surface::init()
+{
+    mCompressedTexture = 0;
+    mTexture = 0;
+    mValid = false;
+    if(isScreen()) {
+        mValid = true;
+    } else if(!mSize.empty()) {
+        mValid = true;
+        if(GibbonConfiguration::uploadInDecodeThreads() || Animation::isAnimationThread())
+            createTexture(true);
+    }
+}
+
+void Surface::cleanup()
+{
+    if(mValid) {
+        if(mTexture)
+            OpenGLContext::deleteTexture(mTexture);
+        mValid = false;
+    }
+}
+
+bool Surface::isValid() const
+{
+    return mValid;
+}
+
+bool Surface::isAccelerated() const
+{
+    return true;
+}
+
+bool Surface::matches(Surface::Flags flags) const
+{
+    if(mCompressedTexture)
+        return false;
+    return bytesPerPixel(flags) == bytesPerPixel();
+}
+
+void Surface::upload(int x, int y, int width, int height, const DataBuffer &data, int bpl, int format)
+{
+    NRDP_UNUSED(bpl);
+    assert(bpl == width * bytesPerPixel() || (!bpl && format));
+    assert(!format || gibbonApp()->getScreen()->isSupportedTextureFormat(format));
+
+    modify();
+
+    OpenGLContext *ctx = OpenGLContext::context();
+    OpenGLState *glstate = ctx->state();
+    createTexture(false);
+
+    glstate->bindTexture(mTexture);
+
+    if(x == 0 && y == 0 && fuzzy_compare(Coordinate(width), mSize.width) && fuzzy_compare(Coordinate(height), mSize.height)) {
+        if(format) {
+            if(format == CustomFormat_YUV) {
+                const uint8_t *channels[4];
+                uint32_t strides[4], widths[4], heights[4];
+                if(Surface::Data::decodeYUV(data, widths, heights, channels, strides)) {
+                    std::shared_ptr<netflix::device::IColorSpaceConvert> csc = Screen::createColorSpaceConvert();
+                    assert(csc);
+                    PlayerGLES2TextureStruct texture = { mTexture, false };
+                    csc->convert(&texture, channels, strides, widths, heights);
+                    assert(!texture.bt2020);
+                }
+            } else {
+                glCompressedTexImage2D(GL_TEXTURE_2D, 0, format, width, height, 0, data.size(), data.constData());
+                if(glGetError() != GL_NO_ERROR)
+                    Log::error(TRACE_LOG, "Unable to upload content: %d to %s", format, describe().c_str());
+            }
+        } else {
+            glTexImage2D(GL_TEXTURE_2D, 0, internalTextureFormat(), width, height, 0, textureFormat(), GL_UNSIGNED_BYTE, data.constData());
+        }
+    } else if(format) {
+        assert(format != CustomFormat_YUV);
+        glCompressedTexSubImage2D(GL_TEXTURE_2D, 0, x, y, width, height, format, data.size(), data.constData());
+        if(glGetError() != GL_NO_ERROR)
+            Log::error(TRACE_LOG, "Unable to upload content: %d to %s", format, describe().c_str());
+    } else {
+        glTexSubImage2D(GL_TEXTURE_2D, 0, x, y, width, height, textureFormat(), GL_UNSIGNED_BYTE, data.constData());
+    }
+    GL_CHECK(glstate);
+
+    const size_t compressedTextureSize = format && format != CustomFormat_YUV ? data.size() : 0;
+    if(mCompressedTexture != compressedTextureSize)
+        mCompressedTexture = compressedTextureSize;
+    sizeChanged();
+}
+
+Surface::SharedPtr Surface::duplicate_sys(const Rect &rect) const
+{
+    return duplicate_internal(rect);
+}
+
+void Surface::setMask_sys(const Surface::SharedPtr &)
+{
+}
+
+void Surface::reuse_sys()
+{
+}
+
+void Surface::copy_sys(const Rect &srcRect, const Rect &dstRect)
+{
+    copy_internal(srcRect, dstRect);
+}
+
+bool Surface::Data::lock_sys(LockType type)
+{
+    if(!mSurface->isValid())
+        return false;
+    mFormat = mSurface->getFormat();
+    const bool hasPixels = (!mPixels.isEmpty());
+    mBytesPerLine = getWidth() * bytesPerPixel();
+    if(!hasPixels)
+        lock_internal();
+    assert(!mPixels.isEmpty());
+
+    if(!hasPixels && (type & Surface::Data::ReadLock)) { // we need to read back
+        const bool isGLThread = Animation::isAnimationThread();
+        if(isGLThread || GibbonConfiguration::uploadInDecodeThreads()) {
+            if(!OpenGLContext::context()->readPixels(mSurface, mPixels)) {
+                unlock_internal();
+                mBytesPerLine = 0;
+                return false;
+            }
+        } else { // need to post an event and wait
+            std::shared_ptr<GLReadEvent> event(new GLReadEvent(mSurface, mPixels));
+            if(Animation::postEvent(event))
+                event->wait();
+            if(!event->isValid()) {
+                unlock_internal();
+                mBytesPerLine = 0;
+                return false;
+            }
+        }
+    }
+
+    return true;
+}
+
+void Surface::Data::unlock_sys()
+{
+    if(!mPixels.isEmpty()) {
+        const bool isGLThread = Animation::isAnimationThread();
+        if(!GibbonConfiguration::uploadInDecodeThreads() && !isGLThread) {
+            assert(!OpenGLContext::hasContext());
+            return;
+        }
+        if(!isGLThread)
+            OpenGLContext::ensureContext();
+        if(mSurface && (mLockType & WriteLock)) {
+            mSurface->upload(0, 0, mWidth, mHeight, mPixels, mBytesPerLine, mPixelsFormat);
+            if(!isGLThread)
+                Animation::postEvent(new GLSyncEvent(mSurface));
+        }
+        unlock_internal();
+    }
+}
+
+SurfaceDecoderPlatform::SurfaceDecoderPlatform(const std::shared_ptr<GibbonResource> &resource, GLenum format) : SurfaceDecoder(resource), mFormat(format)
+{
+
+}
+
+SurfaceDecoderPlatform::~SurfaceDecoderPlatform()
+{
+}
+
+SurfaceDecoder::SharedPtr SurfaceDecoderPlatform::decoder(const std::shared_ptr<GibbonResource> &resource, const std::string &format)
+{
+    if(startsWith(format, "GL_")) {
+        char *endptr;
+        const GLenum compressedFormat = strtoull(format.c_str()+3, &endptr, 0);
+        if(!*endptr && OpenGLContext::supportsFormat(compressedFormat))
+            return SurfaceDecoderPlatform::SharedPtr(new SurfaceDecoderPlatform(resource, compressedFormat));
+    }
+    return SurfaceDecoder::SharedPtr();
+}
+
+bool SurfaceDecoderPlatform::decode(const Time &time, DecodeInfo *result) const
+{
+    NRDP_UNUSED(time);
+    assert(!time.ms());
+    assert(result);
+
+    if(result->state == DecodeInfo::State_Decoding) {
+        result->data.setPixels(mResource->responseData(), mFormat);
+        result->state = DecodeInfo::State_DecodeSuccess;
+    } else {
+        result->info.size = Size(229, 129);
+        //return false;
+    }
+    return true;
+}
+
+
diff --git a/partner/graphics/rpi/gibbon_graphics.cmake b/partner/graphics/rpi/gibbon_graphics.cmake
new file mode 100644
index 00000000..0c7d6150
--- /dev/null
+++ b/partner/graphics/rpi/gibbon_graphics.cmake
@@ -0,0 +1,46 @@
+# (c) 2013 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc.
+
+set(GIBBON_GRAPHICSENGINE_GLES2 TRUE)
+set_property(GLOBAL PROPERTY NRDP_USE_OPENGL TRUE)
+include_directories("${NRDP_ROOT_DIR}/src/platform/gibbon")
+
+add_definitions(-DGIBBON_SCREEN_FULLRENDER
+                -DGIBBON_COORDINATE_FLOAT
+                -DGIBBON_SURFACE_COPY_PINGPONG
+                -DGIBBON_SURFACE_OPTIMIZED_RENDERERS
+                -DGIBBON_SURFACEDECODER_PLATFORM
+)
+
+get_filename_component(CURRENT_DIRECTORY ${CMAKE_CURRENT_LIST_FILE} PATH)
+include_directories(${CURRENT_DIRECTORY})
+
+if(NOT GIBBON_IMAGE_KTX)
+    set(GIBBON_IMAGE_KTX ON CACHE STRING "GL")
+endif()
+if(NOT GIBBON_IMAGE_DDS)
+    set(GIBBON_IMAGE_DDS ON CACHE STRING "GL")
+endif()
+
+gibbon_add_sources(
+    GraphicsEngineGLES2.cpp
+    ScreenGLES2.cpp
+    SurfaceGLES2.cpp
+    EffectsGLES2.cpp
+    OpenGLContext.cpp
+    OpenGLShaders.cpp
+    OpenGLFBO.cpp
+    OpenGLVBO.cpp
+    PlayerGLES2.cpp
+)
+
+set(GIBBON_GRAPHICS_GL_WSYS "egl")
+
+if(GIBBON_GRAPHICS_GL_WSYS STREQUAL "egl")
+    gibbon_add_sources(OpenGLContextEGL.cpp)
+
+    set(GIBBON_GRAPHICSENGINE_GLES2_EGL TRUE)
+	gibbon_add_libraries(bcm_host vcos vchiq_arm vchostif GLESv2 EGL)
+else()
+    message(FATAL_ERROR "Unrecognized GL subsystem: ${GIBBON_GRAPHICS_GL_WSYS}")
+endif()
+gibbon_copy_resource(graphics.xml ${APP_DATA_DIR}/etc/conf/graphics.xml "")
diff --git a/partner/graphics/rpi/graphics.xml b/partner/graphics/rpi/graphics.xml
new file mode 100644
index 00000000..86c9968e
--- /dev/null
+++ b/partner/graphics/rpi/graphics.xml
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<config_root>
+  <config_data>
+    <platform_surface_decoders>true</platform_surface_decoders>
+    <alpha_format>RGBA32_PM</alpha_format>
+    <opaque_format>RGBX32</opaque_format>
+    <alpha_only_format>A8</alpha_only_format>
+    <video_format>RGBX32</video_format>
+    <capabilities>
+      <gibbon>
+        <transform>true</transform>
+        <effects>
+          <blur>
+            <accelerated>true</accelerated>
+          </blur>
+          <desaturate>
+            <accelerated>true</accelerated>
+          </desaturate>
+          <tint>
+            <accelerated>true</accelerated>
+          </tint>
+          <shader>
+            <accelerated>true</accelerated>
+            <language>glsl</language>
+          </shader>
+          <chromakey>
+            <accelerated>true</accelerated>
+          </chromakey>
+        </effects>
+      </gibbon>
+    </capabilities>
+  </config_data>
+</config_root>
diff --git a/partner/graphics/rpi/test.cpp b/partner/graphics/rpi/test.cpp
new file mode 100644
index 00000000..139c0ccb
--- /dev/null
+++ b/partner/graphics/rpi/test.cpp
@@ -0,0 +1,535 @@
+/* (c) 2013 Netflix, Inc. Do not copy or use without prior written permission from Netflix, Inc. */
+
+#include <iostream>
+#include <sstream>
+#include <string>
+#include <cstdlib>
+#include <cassert>
+#include <cstring>
+
+#define GL_GLEXT_PROTOTYPES 1
+#include <GL/glx.h>
+using namespace netflix;
+
+
+//#define USE_PBO 1
+
+#ifdef USE_PBO
+#define GLX_DIRECT_RENDERING    GL_TRUE
+#else
+#define GLX_DIRECT_RENDERING    GL_FALSE
+#endif
+
+#define LOG(s)      (std::cout << s << std::endl)
+#define FAIL(e,s)   if (!e) { LOG(s); exit(1); }
+
+static void GL_CHECK(const std::string & s = std::string())
+{
+    GLenum e = glGetError();
+    FAIL(e == GL_NO_ERROR, "GL ERROR 0x" << std::hex << e << " : " << s);
+    LOG(s);
+}
+
+class Platform
+{
+public:
+    static Platform * initialize(unsigned width, unsigned height);
+
+    virtual ~Platform() {}
+    virtual bool hasCurrentContext() = 0;
+    virtual void setCurrentContext() = 0;
+    virtual void clearCurrentContext() = 0;
+    virtual void swap() = 0;
+    unsigned width() const { return mWidth; }
+    unsigned height() const { return mHeight; }
+protected:
+    Platform(unsigned width, unsigned height) : mWidth(width), mHeight(height) {}
+    unsigned mWidth;
+    unsigned mHeight;
+};
+
+
+
+
+class PlatformGLX : public Platform
+{
+public:
+
+    PlatformGLX( unsigned width , unsigned height )
+    :
+        Platform( width , height )
+    {
+        XInitThreads();
+
+        LOG("Opening display");
+
+        mXDisplay = XOpenDisplay(0);
+        FAIL(mXDisplay, "Failed to open display");
+        LOG("Display is good");
+
+        int screen = DefaultScreen( mXDisplay );
+
+        LOG( "GLX client "
+            << glXGetClientString( mXDisplay , GLX_VERSION )
+            << " : "
+            << glXGetClientString( mXDisplay , GLX_VENDOR ));
+
+        LOG( "GLX server "
+            << glXQueryServerString( mXDisplay , screen , GLX_VERSION )
+            << " : "
+            << glXQueryServerString( mXDisplay , screen , GLX_VENDOR ));
+
+        const int attributes[] =
+        {
+                GLX_DOUBLEBUFFER,   True,
+                GLX_STENCIL_SIZE,   1,
+                GLX_RED_SIZE,       1,
+                GLX_GREEN_SIZE,     1,
+                GLX_BLUE_SIZE,      1,
+                GLX_ALPHA_SIZE,     1,
+                GLX_DEPTH_SIZE,     1,
+                GLX_RENDER_TYPE,    GLX_RGBA_BIT,
+                GLX_DRAWABLE_TYPE,  GLX_WINDOW_BIT,
+
+                None,
+        };
+
+        int nelements = 0;
+
+        /* Find a FBConfig that uses RGBA.  Note that no attribute list is */
+        /* needed since GLX_RGBA_BIT is a default attribute.               */
+        GLXFBConfig * fbc = glXChooseFBConfig( mXDisplay , screen , attributes , &nelements );
+        FAIL(fbc, "Return value of glXChooseFBConfig is NULL");
+        FAIL(nelements, "glXChooseFBConfig returned 0 elements");
+        LOG("Got " << nelements << " FB configurations");
+
+        XVisualInfo * vi = glXGetVisualFromFBConfig( mXDisplay , fbc[0] );
+        FAIL(vi, "Got NULL visual from FB config 0");
+        LOG("Got visual from FB config");
+
+        Window root = RootWindow( mXDisplay , screen );
+        FAIL(root, "Root window is NULL");
+
+        /* Create a colormap */
+        Colormap cmap = XCreateColormap( mXDisplay , root , vi->visual , AllocNone );
+        LOG("Created color map");
+
+        /* Create a window */
+        XSetWindowAttributes swa;
+        swa.colormap = cmap;
+        swa.border_pixel = 0;
+        swa.event_mask = StructureNotifyMask | ExposureMask | KeyPressMask | KeyReleaseMask
+                | PointerMotionMask | ButtonPressMask | ButtonReleaseMask;
+
+        mXWindow = XCreateWindow( mXDisplay , root , 0, 0, width, height ,0 , vi->depth, InputOutput,
+                            vi->visual, CWBorderPixel|CWColormap|CWEventMask, &swa);
+
+        FAIL(mXWindow, "Failed to create X window");
+        LOG("Created X window");
+
+        /* Create a GLX context using the first FBConfig in the list. */
+        mGLXContext = glXCreateNewContext( mXDisplay , fbc[0] , GLX_RGBA_TYPE , 0 , GLX_DIRECT_RENDERING );
+        FAIL(mGLXContext, "Failed to create GLX context");
+        LOG("Created GLX context");
+
+        XFree( vi );
+        LOG("Freed visual");
+
+        /* Create a GLX window using the same FBConfig that we used for the */
+        /* the GLX context.                                                 */
+        mGLXWindow = glXCreateWindow( mXDisplay , fbc[0], mXWindow, 0);
+        FAIL(mGLXWindow, "Failed to create GLX window");
+        LOG("Created GLX window");
+
+        XFree( fbc );
+        LOG("Freed FB config");
+
+        Atom wmDeleteMessage = XInternAtom( mXDisplay, "WM_DELETE_WINDOW", False);
+        XSetWMProtocols( mXDisplay, mXWindow, &wmDeleteMessage, 1);
+        LOG("Set delete window protocol");
+
+        XSetStandardProperties( mXDisplay , mXWindow , "Netflix (GLX)" , "Netflix (GLX)" , None, NULL , 0 , NULL );
+        LOG("Set window standard properties");
+
+        XMapWindow( mXDisplay , mXWindow );
+        LOG("Mapping window");
+
+        LOG("Waiting for map notification");
+        XEvent event;
+        XIfEvent( mXDisplay , &event, WaitForNotify, reinterpret_cast< char* >( mXWindow )  );
+        LOG("Mapped");
+
+        /* Connect the context to the window for read and write */
+        Bool r = glXMakeContextCurrent( mXDisplay, mGLXWindow, mGLXWindow, mGLXContext );
+        FAIL(r, "Failed to make context current");
+        LOG("Context is current, initialization is done");
+    }
+
+    virtual ~PlatformGLX()
+    {
+        LOG("Destroying platform");
+        glXMakeCurrent( mXDisplay , None , NULL );
+        LOG("Destroying GLX window");
+        glXDestroyWindow( mXDisplay , mGLXWindow );
+        LOG("Destroying context");
+        glXDestroyContext( mXDisplay , mGLXContext );
+        LOG("Destroying X window");
+        XDestroyWindow( mXDisplay , mXWindow );
+        LOG("Closing display");
+        XCloseDisplay( mXDisplay );
+        LOG("Done");
+    }
+
+    virtual bool hasCurrentContext()
+    {
+        return mGLXContext == glXGetCurrentContext();
+    }
+
+    virtual void setCurrentContext()
+    {
+        glXMakeContextCurrent( mXDisplay , mGLXWindow , mGLXWindow , mGLXContext );
+    }
+
+    virtual void clearCurrentContext()
+    {
+        glXMakeCurrent( mXDisplay , None , NULL );
+    }
+
+    virtual void swap()
+    {
+        glXSwapBuffers( mXDisplay , mGLXWindow );
+    }
+
+private:
+
+    static Bool WaitForNotify( Display * , XEvent *e , char * arg )
+    {
+       return ( e->type == MapNotify ) && ( e->xmap.window == (Window) arg );
+    }
+
+    Display *   mXDisplay;
+    Window      mXWindow;
+    GLXWindow   mGLXWindow;
+    GLXContext  mGLXContext;
+};
+
+
+static GLuint createShader(GLenum type, const char * source)
+{
+    LOG("Creating " << (type == GL_VERTEX_SHADER ? "VERTEX" : "FRAGMENT") << " shader");
+
+    GLuint shader = glCreateShader( type );
+    GL_CHECK("Created shader");
+    FAIL(shader,"glCreateShader returned 0");
+    glShaderSource( shader , 1 , & source , 0 );
+    GL_CHECK("Set shader source");
+    glCompileShader( shader );
+    GL_CHECK("Compiled shader");
+    GLint status = GL_TRUE;
+    glGetShaderiv( shader , GL_COMPILE_STATUS ,  & status );
+    GL_CHECK("Got shader compile status");
+    LOG("Compile status is " << status);
+    if ( GL_FALSE == status )
+    {
+        LOG("Failed to compile shader, source follows");
+        LOG(source);
+        GLint length = 0;
+        glGetShaderiv( shader , GL_INFO_LOG_LENGTH , & length );
+        GL_CHECK("Got shader info log length");
+        if ( length <= 1 )
+        {
+            LOG("No info log available");
+        }
+        else
+        {
+            char * log = new char[ length ];
+            glGetShaderInfoLog( shader , length , 0 , log );
+            LOG("Info log is : " << log);
+            delete [] log;
+        }
+        FAIL(false,"Failed to compile shader");
+    }
+    return shader;
+}
+
+static GLuint createProgram( const char * vertexShaderSource , const char * fragmentShaderSource )
+{
+    GLuint vertexShader = createShader( GL_VERTEX_SHADER , vertexShaderSource );
+    GLuint fragmentShader = createShader( GL_FRAGMENT_SHADER , fragmentShaderSource );
+
+    GLuint program = glCreateProgram();
+    GL_CHECK("Create program");
+    glAttachShader( program , vertexShader );
+    GL_CHECK("Attach vertex shader");
+    glAttachShader( program , fragmentShader );
+    GL_CHECK("Attach fragment shader");
+    glLinkProgram( program );
+    GL_CHECK("Link program");
+
+    GLint status = GL_TRUE;
+    glGetProgramiv( program , GL_LINK_STATUS , & status );
+    GL_CHECK("Got program link status");
+    LOG("Program link status is " << status);
+    if ( GL_FALSE == status )
+    {
+        LOG("Failed to link program");
+        GLint length = 0;
+        glGetProgramiv( program , GL_INFO_LOG_LENGTH , & length );
+        GL_CHECK("Get program info log");
+        if ( length <= 1 )
+        {
+            LOG("No info log available");
+        }
+        else
+        {
+            char * log = new char[ length ];
+            glGetProgramInfoLog( program , length , 0 , log );
+            LOG("Info log is : " << log);
+            delete [] log;
+        }
+        FAIL(false, "Failed to link program");
+    }
+    return program;
+}
+
+
+int main(int argc, char * argv[] )
+{
+    const int screenWidth = 1280;
+    const int screenHeight = 720;
+
+    Platform * platform = new PlatformGLX(screenWidth, screenHeight);
+
+    FAIL(platform->hasCurrentContext(), "Platform does not have current context");
+    LOG("Platform current context is good");
+
+    GL_CHECK("After initialization");
+
+    LOG("GL vendor " << glGetString(GL_VENDOR));
+    LOG("GL renderer " << glGetString(GL_RENDERER));
+    LOG("GL version " << glGetString(GL_VERSION));
+    LOG("GLSL version " << glGetString(GL_SHADING_LANGUAGE_VERSION));
+
+    GLint maxTextureSize = 0;
+    glGetIntegerv(GL_MAX_TEXTURE_SIZE, &maxTextureSize);
+    LOG("Max texture size " << maxTextureSize);
+
+    //.........................................................................
+
+    GLuint  mVertexBuffer;
+    GLuint  mIndexBuffer;
+    GLuint  mTextureCoordinatesBuffer;
+
+    glBlendFunc( GL_ONE , GL_ONE_MINUS_SRC_ALPHA );
+    glDisable( GL_BLEND );
+    glPixelStorei( GL_UNPACK_ALIGNMENT, 1 );
+    glViewport( 0 , 0 , screenWidth , screenHeight );
+    glClearColor( 0 , 0 , 0 , 0 );
+    glActiveTexture( GL_TEXTURE0 );
+    glDisable( GL_DEPTH_TEST );
+
+    GL_CHECK("Initial GL state");
+
+    //.........................................................................
+    // Create the vertex and index buffers for a rectangle
+
+    glGenBuffers( 1 , & mVertexBuffer );
+    glGenBuffers( 1 , & mIndexBuffer );
+    glGenBuffers( 1 , & mTextureCoordinatesBuffer );
+
+
+    GLfloat vertices[12] =
+    {
+        -1.0,  1.0, 0.0,
+        -1.0, -1.0, 0.0,
+        1.0, -1.0, 0.0,
+        1.0,  1.0, 0.0,
+    };
+
+    glBindBuffer( GL_ARRAY_BUFFER , mVertexBuffer );
+    glBufferData( GL_ARRAY_BUFFER , sizeof( vertices ) , vertices , GL_STATIC_DRAW );
+
+    GL_CHECK("Set up vertex buffer");
+
+    GLubyte textureCoordinates[8] =
+    {
+            0, 0,
+            0, 1,
+            1, 1,
+            1, 0
+    };
+
+    glBindBuffer( GL_ARRAY_BUFFER , mTextureCoordinatesBuffer );
+    glBufferData( GL_ARRAY_BUFFER , sizeof( textureCoordinates ) , textureCoordinates , GL_STATIC_DRAW );
+
+    GL_CHECK("Set up default texture coordinate buffer");
+
+    glBindBuffer( GL_ARRAY_BUFFER , 0 );
+
+    GLubyte indices[6] = {0, 1, 2, 0, 2, 3};
+
+    glBindBuffer( GL_ELEMENT_ARRAY_BUFFER , mIndexBuffer );
+    glBufferData( GL_ELEMENT_ARRAY_BUFFER , sizeof( indices ) , indices , GL_STATIC_DRAW );
+
+    GL_CHECK("Set up index buffer");
+
+    glBindBuffer( GL_ELEMENT_ARRAY_BUFFER , 0 );
+
+    GLfloat identity[4][4];
+    memset(identity, 0x0, sizeof(identity));
+    identity[0][0] = 1.0f;
+    identity[1][1] = 1.0f;
+    identity[2][2] = 1.0f;
+    identity[3][3] = 1.0f;
+
+    const char * svertex  =
+            "uniform mat4   u_projectionMatrix;\n"
+            "uniform mat4   u_mvMatrix;\n"
+            "uniform vec4   u_ts;\n"
+            "attribute vec4 a_position;\n"
+            "attribute vec2 a_texCoord;\n"
+            "varying vec2   v_texCoord;\n"
+            "void main()\n"
+            "{\n"
+            "  gl_Position = ( u_mvMatrix * u_projectionMatrix ) * a_position;\n"
+            "  v_texCoord.x = ( a_texCoord.x * u_ts.z ) + u_ts.x;\n"
+            "  v_texCoord.y = ( a_texCoord.y * u_ts.w ) + u_ts.y;\n"
+            "}\n";
+
+
+    const char * sfragment =
+                "#ifdef GL_ES\n"
+                "precision highp float;\n"
+                "#endif\n"
+                "varying vec2 v_texCoord;\n"
+                "uniform float  u_opacity;\n"
+                "uniform sampler2D s_texture;\n"
+                "void main()\n"
+                "{\n"
+                "  gl_FragColor = texture2D( s_texture, v_texCoord ) * u_opacity;\n"
+                "}\n";
+
+    LOG( "Creating surface program" );
+    GLuint mSurfaceProgram = createProgram( svertex , sfragment );
+
+    LOG( "Getting attribute and uniform locations" );
+    GLint mSurfacePositionAttributeLocation = glGetAttribLocation( mSurfaceProgram , "a_position" );
+    GLint mSurfaceTextureCoordinatesAttributeLocation = glGetAttribLocation( mSurfaceProgram , "a_texCoord" );
+    GLint mSurfaceMatrixUniformLocation = glGetUniformLocation( mSurfaceProgram , "u_mvMatrix" );
+    GLint mSurfaceTextureTransformUniformLocation = glGetUniformLocation( mSurfaceProgram , "u_ts" );
+    GLint mSurfaceOpacityUniformLocation = glGetUniformLocation( mSurfaceProgram , "u_opacity" );
+
+    glUseProgram( mSurfaceProgram );
+    GL_CHECK( "Use surface program" );
+
+    glUniformMatrix4fv( glGetUniformLocation( mSurfaceProgram , "u_projectionMatrix" ) , 1 , GL_FALSE, & identity[0][0] );
+    glUniform1i( glGetUniformLocation( mSurfaceProgram , "s_texture" ) , 0 );
+    GL_CHECK( "Set surface uniforms" );
+
+    glUseProgram( 0 );
+    GL_CHECK( "Use no program" );
+
+    //LOG("\t\t\tIF WE GOT HERE, WE'RE IN GOOD SHAPE");
+
+    // A 2x2 red, greeN, blue, white RGB image
+    const GLubyte pixels[] = {
+        0xFF, 0x00, 0x00, 0x00, 0xFF, 0x00,
+        0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF
+    };
+
+    const size_t pixelBufferSize = sizeof(pixels) * sizeof(GLubyte);
+
+#ifdef USE_PBO
+
+    glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
+    GL_CHECK("Bind no PBO");
+
+    GLuint pbo;
+    glGenBuffers(1, &pbo);
+    LOG("PBO IS " << pbo);
+    GL_CHECK("Gen PBO");
+
+    glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pbo);
+    GL_CHECK("Bind PBO");
+
+    glBufferData(GL_PIXEL_UNPACK_BUFFER, pixelBufferSize, 0, GL_DYNAMIC_DRAW);
+    GL_CHECK("Reset PBO data");
+
+    void * pboMemory = glMapBuffer(GL_PIXEL_UNPACK_BUFFER, GL_WRITE_ONLY);
+    GL_CHECK("Map PBO");
+    FAIL(pboMemory, "Failed to map buffer memory");
+    memcpy(pboMemory, pixels, pixelBufferSize);
+
+    glUnmapBuffer(GL_PIXEL_UNPACK_BUFFER);
+    GL_CHECK("Unmap PBO");
+
+    glBindBuffer(GL_PIXEL_UNPACK_BUFFER, 0);
+    GL_CHECK("Bind no PBO");
+
+#endif
+
+    GLuint texture;
+    glGenTextures(1, &texture);
+    GL_CHECK("Gen texture");
+
+    glBindTexture(GL_TEXTURE_2D, texture);
+    GL_CHECK("Bind texture");
+
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
+    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
+
+#ifdef USE_PBO
+    glBindBuffer(GL_PIXEL_UNPACK_BUFFER, pbo);
+    GL_CHECK("Bind PBO");
+
+    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 2, 2, 0, GL_RGB, GL_UNSIGNED_BYTE, 0);
+    GL_CHECK("Upload pixels");
+
+    glBindBuffer(GL_PIXEL_UNPACK_BUFFER_ARB, 0);
+    GL_CHECK("Bind no PBO");
+#else
+    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, 2, 2, 0, GL_RGB, GL_UNSIGNED_BYTE, pixels);
+    GL_CHECK("Upload pixels directly");
+#endif
+
+    glBindTexture(GL_TEXTURE_2D, 0);
+    GL_CHECK("Bind no texture");
+
+    // Now set-up for rendering
+
+    glClearColor(0xFF, 0, 0, 0xFF);
+    glUseProgram(mSurfaceProgram);
+
+    glUniformMatrix4fv(mSurfaceMatrixUniformLocation, 1, GL_FALSE, & identity[0][0]);
+    glUniform1f(mSurfaceOpacityUniformLocation, 1);
+    const GLfloat textureTransform[4] = { 0 , 0 , 1 , 1 };
+    glUniform4fv(mSurfaceTextureTransformUniformLocation, 1, textureTransform);
+
+
+    glBindBuffer(GL_ARRAY_BUFFER, mVertexBuffer);
+    glVertexAttribPointer(mSurfacePositionAttributeLocation, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(GLfloat), 0);
+    glEnableVertexAttribArray(mSurfacePositionAttributeLocation);
+
+    glBindBuffer(GL_ARRAY_BUFFER, mTextureCoordinatesBuffer);
+    glVertexAttribPointer(mSurfaceTextureCoordinatesAttributeLocation, 2, GL_UNSIGNED_BYTE, GL_FALSE, 2 * sizeof(GLubyte), 0);
+    glEnableVertexAttribArray(mSurfaceTextureCoordinatesAttributeLocation);
+
+    glBindBuffer(GL_ARRAY_BUFFER, 0);
+
+    glBindTexture(GL_TEXTURE_2D, texture);
+
+    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mIndexBuffer);
+
+    while (1) {
+        glClear(GL_COLOR_BUFFER_BIT);
+        glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_BYTE, 0);
+
+        platform->swap();
+    }
+
+    delete platform;
+
+    return 0;
+}
-- 
2.17.1

